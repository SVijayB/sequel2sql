{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_0", "db_id": "financial", "query": "I'm trying to identify accounts with significant transaction variability in our PostgreSQL database. Specifically, I need to find accounts that have made at least two transactions where the difference between their highest and lowest transaction amounts exceeds 12000. I've tried writing a query to find this information, but I'm getting incorrect results. The issue seems to be with how I'm filtering the data or calculating the differences. Could someone help me fix the following issue SQL to properly identify accounts meeting these criteria?", "issue_sql": ["SELECT account_id, MAX(payments) AS max_payment, MIN(payments) AS min_payment FROM loan GROUP BY account_id HAVING COUNT(account_id) > 1 AND (MAX(payments) - MIN(payments)) > 2;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT account_id FROM trans GROUP BY account_id HAVING COUNT(trans_id) > 1 AND (MAX(amount) - MIN(amount)) > 12000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_1", "db_id": "codebase_community", "query": "I'm trying to format time values from a datetime column in PostgreSQL. I need to extract just the time portion (hours:minutes:seconds) without any leading zeros for the hours. For example, I want results like: 0:00:00 10:00:00 4:00:00 Instead of: 00:00:00 10:00:00 04:00:00 The issue with my current query is that it's always including leading zeros for hours under 10. How can I format this correctly to achieve the desired output?", "issue_sql": ["SELECT CreationDate::time FROM comments;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT to_char(creationdate, 'FMHH24:MI:SS') AS time_only FROM comments;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_2", "db_id": "financial", "query": "I'm having trouble with PostgreSQL triggers that need to update summary data when a specific column changes. I want to create a trigger that does the following: 1. Fire when the 'status' column of a loan record is updated 2. Count how many loans with status 'A' exist for the account associated with the updated record 3. Update a summary table with this count My current attempt isn't working correctly. When I update a loan's status, the summary table doesn't reflect the correct count. I think there might be an issue with my trigger definition or the way I'm calculating the count. Can anyone help identify what's wrong with my approach to this PostgreSQL trigger?", "issue_sql": ["CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER\n    AS $$\n    BEGIN\n        UPDATE loan_summary\n        SET total_loan_count = (SELECT COUNT(CASE WHEN status = 'A' THEN 1 END) FROM loan WHERE loan_summary.account_id = loan.account_id) WHERE account_id = NEW.account_id; RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;", "CREATE TRIGGER tr_total_loans AFTER UPDATE OF status FOR EACH ROW EXECUTE PROCEDURE total_loans();"], "preprocess_sql": ["DROP TABLE IF EXISTS loan_summary;", "CREATE TABLE loan_summary (account_id INT PRIMARY KEY, total_loan_count INT, last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, summary_version INT DEFAULT 1, notes TEXT DEFAULT '', metadata JSONB DEFAULT '{}'::jsonb, summary_uuid UUID DEFAULT gen_random_uuid(), total_amount_loaned NUMERIC(12, 4) DEFAULT 0.0, average_loan_duration INT DEFAULT 0, high_risk_flag BOOLEAN DEFAULT FALSE, last_status_change DATE DEFAULT CURRENT_DATE, verification_status VARCHAR(50) DEFAULT 'pending', processing_priority INT DEFAULT 5, archived BOOLEAN DEFAULT FALSE);", "INSERT INTO loan_summary (account_id, total_loan_count, last_updated, created_at, is_active, summary_version, notes, metadata, summary_uuid, total_amount_loaned, average_loan_duration, high_risk_flag, last_status_change, verification_status, processing_priority, archived) SELECT l.account_id, COUNT(*), CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, TRUE, 1, 'Auto-generated summary', jsonb_build_object('source', 'system_init', 'timestamp', CURRENT_TIMESTAMP), gen_random_uuid(), COALESCE(SUM(l.amount), 0), COALESCE(AVG(l.duration), 0)::INT, FALSE, CURRENT_DATE, 'verified', 3, FALSE FROM loan l WHERE l.status = 'A' GROUP BY l.account_id;"], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION total_loans()\n    RETURNS TRIGGER\n    AS $$\n    BEGIN\n        UPDATE loan_summary\n        SET total_loan_count = (\n            SELECT COUNT(*)\n            FROM loan\n            WHERE loan.account_id = loan_summary.account_id\n              AND loan.status = 'A')\n        WHERE loan_summary.account_id = NEW.account_id;\n        RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;", "CREATE TRIGGER tr_total_loans AFTER UPDATE OF status ON loan FOR EACH ROW EXECUTE PROCEDURE total_loans();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT account_id, total_loan_count FROM loan_summary ORDER BY account_id LIMIT 1;\"], db_name,conn)\n    account_id, loan_count = res[0][0], res[0][1]\n    res, _, _ = execute_queries([f\"SELECT loan_id, account_id FROM loan WHERE account_id = {account_id} AND status = 'A' LIMIT 1;\"], db_name,conn)\n    loan_id = res[0][0]\n    check_sql = [f\"UPDATE loan SET status = 'B' WHERE loan_id = {loan_id};\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT total_loan_count FROM loan_summary WHERE account_id = {account_id};\"], db_name,conn)\n    new_count = res[0][0]\n    assert new_count == (loan_count - 1), f\"The trigger does not work.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_3", "db_id": "european_football_2", "query": "In the context of managing team attributes in the European Football database, a user attempted to add a new value 'Very Fast' to an existing ENUM type for 'buildupplayspeedclass' in the 'team_attributes' table. The user tried an approach: renaming the existing ENUM and creating a new one with the additional value, and switch the data type in place. The approach resulted in locks that caused application downtime, especially considering the table's size in the millions of rows. The user is seeking a solution that avoids such downtime, possibly by considering a different approach than using ENUMs.", "issue_sql": ["ALTER TABLE Team_Attributes ALTER COLUMN buildupplayspeedclass SET DATA TYPE buildupplayspeedclass USING buildupplayspeedclass::text::buildupplayspeedclass;"], "preprocess_sql": ["CREATE TYPE buildupplayspeedclass_enum AS ENUM ('Balanced', 'Fast', 'Slow');", "\n    ALTER TABLE team_attributes\n    ALTER COLUMN buildupplayspeedclass\n    TYPE buildupplayspeedclass_enum\n    USING buildupplayspeedclass::buildupplayspeedclass_enum;"], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["CREATE UNIQUE INDEX unique_name_location ON event(event_name, location, event_date) WHERE coalesce(event_name, location) is not null;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_queries = [\n        \"\"\"\n        INSERT INTO event (event_id, event_name, location, event_date)\n        VALUES ('test1', 'test_name', 'test_location', 'test_date');\n        \"\"\"\n    ]\n    execute_queries(check_queries, db_name, conn)\n    \n    check_queries = [\n        \"\"\"\n        insert into event (event_id, event_name, location, event_date)\n\n        values('test2', 'test_name', 'test_location', 'test_date')\n        on conflict (event_name, location, event_date)        \n        where coalesce(event_name, location) is not null \n        do update set\n            event_id = excluded.event_id,\n            event_name = excluded.event_name,\n            location = excluded.location,\n            event_date = excluded.event_date \"\"\"\n    ]\n    res, exec_err, _ = execute_queries(check_queries, db_name, conn)\n    assert exec_err == False\n    queries = [\"SELECT event_id, event_name, location, event_date FROM event WHERE event_name = 'test_name';\"]\n    res, _, _ = execute_queries(queries, db_name, conn)\n    assert len(res) == 1\n    assert res[0][0] == 'test2'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_4", "db_id": "student_club", "query": "In the student_club database, I created a unique index on the `event` table using the following queries 'CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null; CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;'. However, when I attempt to insert a new record using an UPSERT operation using the query 'insert into event (event_id, event_name, location, event_date) values('test1', 'test_name', 'test_location', 'test_date')on conflict (event_name, location, event_date) do update set event_id = 'test1', event_name = 'test_name', location = 'test_location', event_date = 'test_date'', I encounter an error stating that there is no unique or exclusion constraint matching the ON CONFLICT specification.", "issue_sql": ["CREATE UNIQUE INDEX unique_name ON event(event_name, event_date) where event_name is not null;CREATE UNIQUE INDEX unique_location ON event(location, event_date) where location is not null;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["UPDATE transactions_1k\n    SET Amount = 100\n    FROM ( SELECT customerid, transactionid FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub\n    JOIN customers c ON c.customerid = sub.customerid WHERE transactions_1k.transactionid = sub.transactionid RETURNING transactions_1k.transactionid, c.Segment;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 2\n    assert pred_query_result == [(947, \"SME\"), (988, \"KAM\")]\n    assert check_sql_function_usage(pred_sqls, [\"RETURNING\"]) == 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_5", "db_id": "debit_card_specializing", "query": "In the following SQL, how could I make the `RETURNING` clause join to something else and return the joined row(s)? Here it only returns the row from `transactions_1k` that was updated, but I'd like it to return that row joined to something in another table, e.g. joined to `customers` tables and get both `transactions_1k.transactionid` and `customers.Segment` columns.", "issue_sql": ["UPDATE transactions_1k\n    SET Amount = 100\n    FROM ( SELECT TransactionID FROM transactions_1k WHERE Amount = 50 ORDER BY Date LIMIT 100 FOR UPDATE ) sub\n    WHERE transactions_1k.TransactionID = sub.TransactionID RETURNING *;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT users.Id, COUNT(posts.Id) FILTER (WHERE AnswerCount > 0) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_6", "db_id": "codebase_community", "query": "I have a query that calculates the number of referrals each user has made. However, I want to count a referral only if the referred user has activated their premium account. How can I achieve this?", "issue_sql": ["SELECT users.Id, COUNT(posts.Id) as answered FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id ORDER BY answered DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["DROP TABLE IF EXISTS users CASCADE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_users_table = execute_queries([\"SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'users';\"], 'codebase_community',conn)[0]\n    assert test_users_table[0][0] == 0, 'Users table should be dropped.'", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_posts_lasteditoruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_1';\"], 'codebase_community',conn)[0] \n    assert test_posts_lasteditoruserid_fkey[0][0] == 0, 'Foreign key posts_lasteditoruserid_fkey should be dropped.'\n    test_posts_owneruserid_fkey = execute_queries([\"SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = 'posts' AND constraint_name = 'posts_ibfk_2';\"], 'codebase_community',conn)[0] \n    assert test_posts_owneruserid_fkey[0][0] == 0, 'Foreign key posts_owneruserid_fkey should be dropped.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_7", "db_id": "codebase_community", "query": "I want to drop the 'users' table from the 'codebase_community' database. However, when I attempt to drop the table using the SQL command `DROP TABLE IF EXISTS users;`, I encounter an error message stating: 'cannot drop table users because other objects depend on it'. This issue arises because the 'users' table is referenced by foreign keys in other tables such as 'badges', 'comments', 'postHistory', 'posts', and 'votes'. I am seeking a solution to drop the 'users' table without having to remove all dependent tables or data.", "issue_sql": ["DROP TABLE IF EXISTS users;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["WITH RECURSIVE nodes AS (SELECT u.id, r.ref FROM users u CROSS JOIN LATERAL (VALUES (u.ref1), (u.ref2)) r(ref)), edges AS (SELECT DISTINCT n1.id AS id1, n2.id AS id2 FROM nodes n1 INNER JOIN nodes n2 ON n1.ref = n2.ref), rcte AS (SELECT id1, id2, ARRAY[id1] AS visited FROM edges WHERE id1 = id2 UNION ALL SELECT r.id1, e.id2, r.visited || e.id2 FROM rcte r INNER JOIN edges e ON e.id1 = r.id2 WHERE e.id2 <> ALL(r.visited)), groups AS (SELECT id1 AS id, ARRAY_AGG(DISTINCT id2 ORDER BY id2) AS ids FROM rcte GROUP BY id1) SELECT g.ids, array_agg(DISTINCT u.username) AS usernames, array_agg(DISTINCT u.ref1) AS refs1, CASE WHEN g.ids IS NULL THEN array_agg(DISTINCT a.owner) ELSE array_agg(DISTINCT u.ref2) END AS refs2, array_agg(DISTINCT a.id) AS asset_ids, COUNT(DISTINCT a.id) AS asset_count FROM assets a LEFT JOIN users u ON a.owner IN (u.ref1, u.ref2) LEFT JOIN groups g ON g.id = u.id GROUP BY g.ids;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_8", "db_id": "student_club", "query": "In database student_club, there is a set of users. A student can have multiple users, but ref1 and ref2 might be alike and can therefore link users together. ref1 and ref2 does not overlap, one value in ref1 does not exist in ref2.  A user can own multiple assets. I want to \"merge\" users that has one or more refs alike and then count how many assets they own together. There could be missing entries in the user table, in that case I just want to propagate the owner into ref2 and set the asset_count and asset_ids.", "issue_sql": ["SELECT  ARRAY_AGG(DISTINCT u.id) AS ids, ARRAY_AGG(DISTINCT u.username) AS usernames, ARRAY_AGG(DISTINCT u.ref1) AS refs1, ARRAY_AGG(DISTINCT u.ref2) AS refs2,  COUNT(DISTINCT a.id) AS asset_count FROM assets a JOIN users u ON a.owner = u.ref1 OR a.owner = u.ref2 GROUP BY a.owner ORDER BY MIN(a.id);"], "preprocess_sql": ["CREATE TABLE assets (id serial, name text, owner text, PRIMARY KEY(id));", "CREATE TABLE users (id serial, username text, ref1 text, ref2 text, PRIMARY KEY(id));", "INSERT INTO assets (name, owner) VALUES ('#1', 'a'), ('#2', 'b'), ('#3', 'c'), ('#4', 'a'), ('#5', 'c'), ('#6', 'd'), ('#7', 'e'), ('#8', 'd'), ('#9', 'a'), ('#10', 'a'), ('#11', 'z');", "INSERT INTO users (username, ref1, ref2) VALUES ('bobo', 'a', 'd'), ('toto', 'b', 'e'), ('momo', 'c', 'd'), ('lolo', 'a', 'f'), ('popo', 'c', 'f');"], "clean_up_sql": ["drop table if exists users;", "drop table if exists assets;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ), CTE2 AS ( SELECT link_to_event, COUNT(budget_id) AS count FROM budget GROUP BY link_to_event) SELECT CTE.link_to_event, CTE.count AS newCount, CTE2.count AS oldCount FROM CTE2 JOIN CTE ON CTE2.link_to_event = CTE.link_to_event WHERE CTE2.count != CTE.count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_9", "db_id": "student_club", "query": "I am trying to compare the number of attendees for each event between two different tables: 'attendance' and 'budget'. I want to find events where the number of attendees in the 'attendance' table does not match the number of attendees recorded in the 'budget' table. My query follows this structure:", "issue_sql": ["WITH CTE AS ( SELECT link_to_event, COUNT(link_to_member) AS count FROM attendance GROUP BY link_to_event ) SELECT CTE.link_to_event, CTE.count AS newCount, budget.count AS oldCount FROM budget JOIN CTE ON budget.link_to_event = CTE.link_to_event WHERE budget.count != CTE.count;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["INSERT INTO attendance (link_to_event, link_to_member, attend) VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1) ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET attend = 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    test_query_result_1 = execute_queries([\"SELECT attend FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi' AND link_to_member = 'rec280Sk7o31iG0Tx'\"], 'student_club', conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} rows.'\n    assert test_query_result_1[0][0] == 1, f'Expected attend is updated to 1, but found it is {test_query_result_1[0][0]}'\n    test_query_result_2 = execute_queries([\"SELECT * FROM attendance WHERE attend = 1\"], 'student_club', conn)[0]\n    assert test_query_result_2[0][0] == 'recEVTik3MlqbvLFi', f'Expected recEVTik3MlqbvLFi, but found {test_query_result_2[0][0]}'\n    assert test_query_result_2[0][1] == 'rec280Sk7o31iG0Tx', f'Expected rec280Sk7o31iG0Tx, but found {test_query_result_2[0][1]}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_10", "db_id": "student_club", "query": "In the student_club database, we have a scenario where a member can attend multiple events, and an event can have multiple attendees. However, a member can only attend an event once. If a member attempts to attend the same event again, the system should update the attendance record with new information, such as status attend. The current approach is to use an INSERT statement, but it fails when the member already has an attendance record for the event. We need to implement an insert statement that updates the existing record if a conflict occurs based on the combination of member_id and event_id.", "issue_sql": ["INSERT INTO attendance VALUES ('recEVTik3MlqbvLFi', 'rec280Sk7o31iG0Tx', 1)"], "preprocess_sql": ["ALTER TABLE attendance ADD COLUMN attend INTEGER DEFAULT 0;"], "clean_up_sql": ["ALTER TABLE attendance DROP COLUMN attend;"], "category": "Personalization", "efficiency": false, "sol_sql": ["ALTER TABLE account\n    ALTER COLUMN date\n    TYPE varchar(30)\n    USING date::varchar;", "ALTER TABLE account\n    ALTER COLUMN date\n    TYPE timestamp\n    USING date::timestamp;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n    \"\"\"\n    SELECT  data_type\n    FROM information_schema.columns\n    WHERE table_name = 'account'\n    AND column_name = 'date';\n    \"\"\"\n    ]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    data_type = res[0][0]\n    assert 'timestamp' in data_type\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_11", "db_id": "financial", "query": "In the financial database, there is a need to convert the data from a `BIGINT` column to a `TIMESTAMP` column. The `date` column in the `account` table is currently stored as a `BIGINT` representing the date in the format YYMMDD. The goal is to update this column to a `TIMESTAMP` type to store the date and time information.", "issue_sql": ["UPDATE account\n    SET date__timestamp = date__bigint::timestamp;"], "preprocess_sql": ["\n    ALTER TABLE account\n    ALTER COLUMN date\n    TYPE BIGINT\n    USING to_char(date, 'YYYYMMDD')::bigint;\n    "], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["select t1.*\n    from cards t1\n    join\n    (\n        SELECT min(id) as id\n        FROM cards\n        GROUP BY artist\n    ) t2 on t1.id = t2.id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_12", "db_id": "card_games", "query": "In the card_games database, there is a table named 'cards'. Each card is uniquely identified by a id and includes details about artists and bordercolors. The user wants to group the cards by their 'artist' attribute to get a distinct result for each group. However, when the user tries to use the following SQL query to achieve this, it results in an error or incorrect output: sql SELECT * FROM cards GROUP BY artist;  The user understands that this query is incorrect because it does not group by all the columns that need to be shown. The user is seeking a solution to this problem.", "issue_sql": ["SELECT * FROM cards GROUP BY artist;"], "preprocess_sql": ["\n    DELETE FROM cards\n    WHERE artist NOT IN ('Ralph Horsley', 'Daarken');\n    ", "\n    DELETE FROM cards\n    WHERE artist IS NULL;\n    ", "\n    CREATE TABLE cards_new AS\n    SELECT id, artist, bordercolor\n    FROM cards;\n    DROP TABLE cards;\n    ALTER TABLE cards_new\n    RENAME TO cards;\n    "], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT *\nFROM transactions_1k\nWHERE CustomerID = 3\n  AND Date = '2012-08-24'\n\nUNION ALL\n\nSELECT *\nFROM transactions_1k\nWHERE CustomerID = 7626\n  AND Date = '2012-08-24'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM transactions_1k\n    WHERE CustomerID = 3\n      AND Date = '2012-08-24'\n  );"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_13", "db_id": "debit_card_specializing", "query": "I'm trying to create an SQL query that checks if a SELECT query on the 'transactions_1k' table returns no rows based on a specific criteria involving 'CustomerID' and 'Date'. If no rows are returned, it should then execute another SELECT query with a different criteria. Here's what I mean:\n\nsql\nIF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'\n\n\nIs this possible? I'm not sure if an empty result set counts as 'null', which is causing me some trouble.", "issue_sql": ["IF SELECT * FROM transactions_1k WHERE CustomerID = 3 AND Date = '2012-08-24' RETURNS NO ROWS\nTHEN SELECT * FROM transactions_1k WHERE CustomerID = 7626 AND Date = '2012-08-24'"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT 'SELECT ' || STRING_AGG('a.' || column_name, ', ') || ' FROM account AS a' FROM information_schema.columns WHERE table_name = 'account' AND table_schema = 'public' AND column_name NOT IN ('account_id', 'date');"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_2 = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_2 = execute_queries(sol_sqls, db_name, conn)\n    pred_sqls_2 = remove_distinct(pred_sqls_2[0][0])\n    sol_sqls_2 = remove_distinct(sol_sqls_2[0][0])\n    result = ex_base(pred_sqls_2, sol_sqls_2, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_14", "db_id": "financial", "query": "I need to compare the 'account' table with another table, but there are some columns in the 'account' table that I don't need to compare. Specifically, I want to exclude the 'account_id' and 'date' columns from the comparison. I tried to dynamically generate a SQL query to select all columns except these two, but the output SQL was incorrect. Here's the problematic SQL I used:", "issue_sql": ["SELECT 'SELECT ' || array_to_string(ARRAY(SELECT 'o' || '.' || c.column_name\n    FROM information_schema.columns As c\n        WHERE table_name = 'account'\n        AND  c.column_name NOT IN('account_id', 'date')\n), ',') || ' FROM accountAs o' As sqlstmt"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT *\nFROM\n(\n  SELECT DISTINCT ON (account_id) *\n  FROM\n  (\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        0 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n        AND l.date >= (NOW() - INTERVAL '48 hours')\n      ORDER BY l.date DESC NULLS LAST\n      LIMIT 6\n    )\n    UNION\n    (\n      SELECT\n        account.account_id,\n        account.frequency,\n        l.loan_id,\n        l.date AS loan_date,\n        1 AS priority\n      FROM account\n      LEFT JOIN loan l\n        ON account.account_id = l.account_id\n      WHERE account.district_id = '18'\n    )\n  ) t\n  ORDER BY account_id, priority\n) t\nORDER BY priority, loan_date DESC;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_15", "db_id": "financial", "query": "I have two tables: `account` and `loan`. I need to display the first 6 accounts from a specific district that has loans in the last 48 hours then the rest of the accounts. This works great but I get duplicates from the second query where I repeat these accounts again. I want to make sure `account.account_id` is unique.", "issue_sql": ["(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    0 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n    AND l.date >= (NOW() - INTERVAL '48 hours')\n  ORDER BY l.date DESC NULLS LAST\n  LIMIT 6\n)\nUNION\n(\n  SELECT\n    account.account_id,\n    account.frequency,\n    l.loan_id,\n    l.date AS loan_date,\n    1 AS priority\n  FROM account\n  LEFT JOIN loan l\n    ON account.account_id = l.account_id\n  WHERE account.district_id = '18'\n  ORDER BY account.date DESC\n);"], "preprocess_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (90001, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '30 days'), (90002, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '35 days'), (90003, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '40 days'), (90004, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '45 days'), (90005, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '50 days'), (90006, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '55 days'), (90007, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '60 days'), (90008, 18, 'POPLATEK MESICNE', CURRENT_DATE - INTERVAL '65 days')", "INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (80001, 90001, CURRENT_DATE - INTERVAL '5 hours', 50000, 24, 2500.0, 'A'), (80002, 90002, CURRENT_DATE - INTERVAL '10 hours', 75000, 36, 2500.0, 'A'), (80003, 90003, CURRENT_DATE - INTERVAL '15 hours', 60000, 12, 5500.0, 'A'), (80004, 90004, CURRENT_DATE - INTERVAL '24 hours', 45000, 24, 2200.0, 'A'), (80005, 90005, CURRENT_DATE - INTERVAL '36 hours', 80000, 48, 2000.0, 'A'), (80006, 90006, CURRENT_DATE - INTERVAL '40 hours', 30000, 12, 2800.0, 'A')", "INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (80011, 90001, CURRENT_DATE - INTERVAL '70 days', 25000, 12, 2100.0, 'B'), (80012, 90002, CURRENT_DATE - INTERVAL '80 days', 35000, 24, 1600.0, 'A'), (80013, 90003, CURRENT_DATE - INTERVAL '90 days', 45000, 36, 1400.0, 'C'), (80014, 90004, CURRENT_DATE - INTERVAL '100 days', 55000, 48, 1300.0, 'A')", "INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (80007, 90007, CURRENT_DATE - INTERVAL '5 days', 65000, 24, 3200.0, 'A'), (80008, 90008, CURRENT_DATE - INTERVAL '7 days', 55000, 36, 1800.0, 'A')"], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT json_agg(events_array) AS all_events\nFROM (\n  SELECT\n    json_agg(\n      json_build_object(\n        'link_to_member', link_to_member,\n        'link_to_event',  link_to_event\n      )\n    ) AS events_array\n  FROM attendance\n  GROUP BY link_to_event\n) sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def compare_array_of_arrays(arr1, arr2):\n        assert arr1 == arr2, \"The two array-of-array structures do not match.\"\n        return 1\n    \n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = compare_array_of_arrays(pred_query_result[0][0][0], sol_query_result[0][0][0])\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_16", "db_id": "student_club", "query": "In the student_club database, there is a table named 'attendance' that records the attendance of members to various events. Each record in this table contains a 'link_to_event' which is a unique identifier for the event, and a 'link_to_member' which is a unique identifier for the member. The goal is to generate a  output that aggregates the attendance records by event, where each event's attendance is represented as an array of member objects. Each member object should contain the member's unique identifier ('link_to_member') and the event's unique identifier ('link_to_event'). The desired  output should be an array of these event-based arrays. However, the user encountered an issue where the output was interpreted as text, introducing undesired escape characters, and the outer array was missing. The user's query was adapted from a suggestion on another post, but it did not produce the desired result.", "issue_sql": ["SELECT Array_agg(rw) FROM (SELECT link_to_event, (SELECT To_(Array_agg(Row_to_(t))) FROM (SELECT link_to_member FROM public.attendance WHERE link_to_event = b.link_to_event) t) rw FROM attendance b GROUP BY link_to_event);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT generate_series(\n  EXTRACT(YEAR FROM MIN(date)::timestamptz AT TIME ZONE 'UTC')::int,\n  EXTRACT(YEAR FROM MAX(date)::timestamptz AT TIME ZONE 'UTC')::int\n)::text AS the_year\nFROM loan;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    return pred_sqls_result == sol_sqls_result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_17", "db_id": "financial", "query": "In the financial database, we need to generate a list of all years between two given dates from the 'loan' table. The dates are extracted from the 'date' column, which represents the approval date of loans. The goal is to generate all years between the earliest and latest loan approval dates, regardless of the interval between them. For instance, if the earliest loan was approved on '1994-01-05' and the latest on '1997-12-08', we should get a list of years including '1994', '1995', '1996', and '1997'. However, the initial query only returns the starting year if the interval between the dates is less than a year, which is not the desired outcome.", "issue_sql": ["SELECT to_char(generate_series, 'YYYY') FROM generate_series(MIN(date)::timestamptz, MAX(date)::timestamptz, '1 year') FROM loan;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT *, MAX(amount) OVER (PARTITION BY account_id) \"max\" FROM loan"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_18", "db_id": "financial", "query": "In the financial database, there is a table named 'loan' that records details of loans given to clients. Each loan is associated with an account, and the table contains columns such as 'loan_id', 'account_id', 'date', 'amount', 'duration', 'payments', and 'status'. The 'amount' column represents the loan amount in USD. The task is to retrieve all rows from the 'loan' table, along with an additional column that shows the maximum loan amount per account. This will help in understanding the highest loan amount each account has taken. However, the user attempted to use the ROW_NUMBER() window function to achieve this, which resulted in incorrect results.", "issue_sql": ["SELECT account_id, amount FROM (SELECT account_id, amount, ROW_NUMBER() OVER(PARTITION BY account_id ORDER BY amount DESC) AS rn FROM loan) AS a WHERE rn = 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(101) GENERATED ALWAYS AS  (CASE WHEN first_name IS NULL THEN last_name WHEN last_name  IS NULL THEN first_name ELSE first_name || ' ' || last_name END) STORED, PRIMARY KEY (client_id) );"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'client_information';\"], db_name, conn)[0]\n    assert test_query_result_1[0][0] == 'client_information' , f\"Table client_information not found in database {test_query_result_1}.\"\n    insert_sql = execute_queries([\"INSERT INTO client_information (first_name, last_name) VALUES ('aaa', 'bbb');\"], db_name, conn);\n    test_query_result_2 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_2 == [('aaa bbb',)], f\"Full name not generated correctly. Found {test_query_result_2}\"\n    update_sql = execute_queries([\"UPDATE client_information SET last_name = 'ccc' WHERE first_name = 'aaa'\"], db_name, conn)\n    test_query_result_3 = execute_queries([\"SELECT full_name FROM client_information WHERE first_name = 'aaa'\"], db_name, conn)[0]\n    assert test_query_result_3 == [('aaa ccc',)], f\"Full name not generated correctly. Found {test_query_result_3}\""]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_19", "db_id": "financial", "query": "In the financial database, we need to create a table to store detailed information about clients, including their first name, last name, and a full name that is automatically generated from the first and last names. The full name should be stored as a generated column. However, when attempting to create the table with a generated column using the CONCAT function, an error occurs indicating that the generation expression is not immutable.", "issue_sql": ["CREATE TABLE client_information ( client_id smallserial NOT NULL, first_name character varying(50), last_name character varying(50), full_name character varying(100) GENERATED ALWAYS AS (concat(first_name, ' ', last_name)) STORED, PRIMARY KEY (client_id) );"], "preprocess_sql": [], "clean_up_sql": ["DROP TABLE IF EXISTS client_information;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH ins AS (INSERT INTO cards (uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT (uuid) DO UPDATE SET uuid = NULL WHERE FALSE RETURNING id) SELECT id FROM ins UNION ALL SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' LIMIT 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][0] is not None, 'The returned ID should not be None'\n    test_pred_query_result_1 = execute_queries([\"SELECT id FROM cards WHERE uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c';\"], db_name, conn)[0]\n    assert pred_query_result[0][0] == test_pred_query_result_1[0][0], f'Expected ID to match, but found {pred_query_result[0][0]} and {test_pred_query_result_1[0][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_20", "db_id": "card_games", "query": "In the context of the card_games database, I frequently need to get a card's row based on its unique UUID, and if it does not exist, I want to create it and return its ID. For example, my table might be the 'cards' table. Suppose I want to insert a card with a specific UUID and name, and if the UUID already exists, I want to return the existing card's ID without modifying the row. However, using the following SQL statement, I encounter issues as it does not return the ID when the row already exists:\\nsql \\\\nINSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') \\\\nON CONFLICT DO NOTHING RETURNING id; \\\\n\\nThis statement does not return the ID of the existing row. I need a solution that returns the ID whether the row is inserted or already exists.", "issue_sql": ["INSERT INTO cards(uuid, name) VALUES ('5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 'Ancestor''s Chosen') ON CONFLICT DO NOTHING RETURNING id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    today = execute_queries([\"SELECT CURRENT_DATE\"], db_name, conn)[0][0][0]\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    assert pred_query_result[0][4] == 'UPDATE', f'Expected operation_type to be UPDATE, but found {pred_query_result[0][4]}'\n    assert pred_query_result[0][3] == today, f'Expected date is updated to today {today}, but found {pred_query_result[0][3]}'\n    test_query_result_1 = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (22222, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE RETURNING *, CASE WHEN xmax = 0 THEN 'INSERT' ELSE 'UPDATE' END AS operation_type;\"], db_name, conn)[0]\n    assert test_query_result_1[0][4] == 'INSERT', f'Expected operation_type to be INSERT, but found {test_query_result_1[0][4]}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_21", "db_id": "financial", "query": "In the financial database, I have a table `account` where I need to insert new records or update existing ones based on the `account_id`. The `date` column should be updated to the current date if the record already exists. I want to know whether an `INSERT` or an `UPDATE` operation was performed. I attempted to use an `ON CONFLICT..DO UPDATE` clause but encountered issues with determining the type of operation. I considered adding an `is_update` column to track this, but it feels unnecessary as it is not related to the data itself.", "issue_sql": ["INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 18, 'POPLATEK MESICNE', CURRENT_DATE) ON CONFLICT (account_id) DO UPDATE SET date = CURRENT_DATE"], "preprocess_sql": [], "clean_up_sql": ["UPDATE account SET date = '1995-03-24'", "DELETE FROM account WHERE account_id = 22222"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT (MAX(releaseDate) - MIN(releaseDate)) + 1 AS cnt, MIN(releaseDate) AS date_min, MAX(releaseDate) AS date_max FROM (SELECT x.*, SUM(i) OVER(ORDER BY releaseDate) AS g FROM (SELECT t.*, CASE WHEN releaseDate > LAG(releaseDate) OVER(ORDER BY releaseDate) + 1 THEN 1 ELSE 0 END AS i FROM sets_releaseInfo t) x) y GROUP BY g;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_22", "db_id": "card_games", "query": "I am analyzing the release dates of Magic: The Gathering card sets to identify periods of consecutive releases. The data includes multiple entries for the same release date due to different printings or variations. I want to find the longest consecutive release periods along with their start and end dates. Here is the structure of the relevant table:\\n- id SERIAL, releaseDate DATE, setCode VARCHAR(50)\\nThe data could have equal release date entries:\\n- id 1, releaseDate 2019-12-28, setCode '10E'\\n- id 2, releaseDate 2019-12-28, setCode '10E'\\n- id 3, releaseDate 2019-12-29, setCode '10E'\\n- id 4, releaseDate 2019-12-29, setCode '10E'\\n- id 5, releaseDate 2019-12-31, setCode '10E'\\n- id 6, releaseDate 2019-12-31, setCode '10E'\\n- id 7, releaseDate 2020-01-01, setCode '10E'\\n- id 8, releaseDate 2020-01-01, setCode '10E'\\n- id 9, releaseDate 2020-01-02, setCode '10E'\\n- id 10, releaseDate 2020-01-03, setCode '10E'\\n- id 11, releaseDate 2020-01-04, setCode '10E'\\n- id 12, releaseDate 2020-01-04, setCode '10E'\\n- id 13, releaseDate 2020-01-05, setCode '10E'\\n- id 14, releaseDate 2020-01-22, setCode '10E'\\n- id 15, releaseDate 2020-01-29, setCode '10E'\\n- id 16, releaseDate 2020-01-30, setCode '10E'\\nI am interested in getting the consecutive release periods with the start and end dates. An output like this:\\n- count | date MIN | date MAX \\\\(6, 2019-12-31, 2020-01-05)\\\\(2, 2019-12-28, 2019-12-29)\\\\(2, 2020-01-29, 2020-01-30)\\nI tried the following SQL query, but it gives incorrect counts and mismatched start/end dates:\\", "issue_sql": ["SELECT COUNT(*) -1 AS count, MAX(releaseDate), MIN(releaseDate) FROM (SELECT *, date(releaseDate) - row_number() OVER (PARTITION BY releaseDate ORDER BY date(releaseDate)) * INTERVAL '1 day' AS filter FROM sets_releaseInfo ) t1 GROUP BY filter HAVING COUNT(*) -1 > 0 ORDER BY count DESC"], "preprocess_sql": ["CREATE TABLE sets_releaseInfo (id SERIAL, releaseDate DATE, setCode VARCHAR(50));", "INSERT INTO sets_releaseInfo (releaseDate, setCode) VALUES ('2019-12-28', '10E'), ('2019-12-28', '10E'), ('2019-12-29', '10E'), ('2019-12-29', '10E'), ('2019-12-31', '10E'), ('2019-12-31', '10E'), ('2020-01-01', '10E'), ('2020-01-01', '10E'), ('2020-01-02', '10E'), ('2020-01-03', '10E'), ('2020-01-04', '10E'), ('2020-01-04', '10E'), ('2020-01-05', '10E'), ('2020-01-22', '10E'), ('2020-01-29', '10E'), ('2020-01-30', '10E');"], "clean_up_sql": ["DROP TABLE IF EXISTS sets_releaseInfo;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE path_cte AS (SELECT id, id::text AS Path, id AS FirstID, 1 AS Lvl FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.id::text || ' --> ' || cte.Path, cte.FirstId, cte.Lvl + 1 FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT DISTINCT ON (FirstID) Path FROM path_cte ORDER BY FirstID, Lvl DESC, id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_23", "db_id": "card_games", "query": "In the card_games database, we have a table named 'collection' where each card can have a reference to another card through the 'nextCardId' column. This column represents the ID of the next card in a sequence. We want to generate a sequence path for each card starting from the card that has no previous card (i.e., no card points to it) and ending at the card that has no next card (i.e., its 'nextCardId' is NULL). The path should be represented as a string of card IDs separated by ' --> '.\\nFor example, if we have the following data:\\n| id  | nextCardId |\\n|-----|------------|\\n| 1   | 5          |\\n| 2   | NULL       |\\n| 3   | 6          |\\n| 4   | 7          |\\n| 5   | 8          |\\n| 6   | 9          |\\n| 7   | NULL       |\\n| 8   | NULL       |\\n| 9   | 10         |\\n| 10  | NULL       |\\nWe want to get the following paths:\\n1 --> 5 --> 8;\\n2;\\n3 --> 6 --> 9 --> 10;\\n4 --> 7;\\nHowever, when we run the following SQL query, we get incorrect results that include incomplete paths:\\nsql;\\nWITH RECURSIVE path_cte AS (\\n  SELECT id, nextCardId, id::TEXT AS Path;\\n  FROM collection\\n  WHERE nextCardId IS NULL\\n  UNION ALL\\n  SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path\\n  FROM collection\\n  JOIN path_cte cte ON collection.nextCardId = cte.id\\n)\\nSELECT Path\\nFROM path_cte\\nORDER BY id;\\n\\nWe need to correct this query to get only the complete paths starting from the cards that have no previous card and ending at the cards that have no next card.", "issue_sql": ["WITH RECURSIVE path_cte AS (SELECT id, nextCardId, id::TEXT AS Path FROM collection WHERE nextCardId IS NULL UNION ALL SELECT collection.id, collection.nextCardId, collection.id || ' --> ' || cte.Path FROM collection JOIN path_cte cte ON collection.nextCardId = cte.id) SELECT Path FROM path_cte ORDER BY id;"], "preprocess_sql": ["CREATE TABLE collection (id INTEGER NOT NULL PRIMARY KEY, nextCardId INTEGER)", "INSERT INTO collection (id, nextCardId) VALUES (1, 5), (2, NULL), (3, 6), (4, 7), (5, 8), (6, 9), (7, NULL), (8, NULL), (9, 10), (10, NULL);"], "clean_up_sql": ["DROP TABLE IF EXISTS collection"], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION what_quarter_is(date_in DATE, start_mon_in INTEGER DEFAULT 1) RETURNS INTEGER LANGUAGE sql AS $$ WITH RECURSIVE qtrs(mq, q, m, c) AS (SELECT 1, 1, start_mon_in, 1 UNION ALL SELECT mq % 3 + 1, CASE WHEN mq % 3 + 1 = 1 THEN q + 1 ELSE q END, CASE WHEN m = 12 THEN 1 ELSE m + 1 END, c + 1 FROM qtrs WHERE c < 12) SELECT q FROM qtrs WHERE m = EXTRACT(MONTH FROM date_in); $$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query_result_1 = execute_queries([\"SELECT proname, proargnames, prorettype::regtype, prosrc FROM pg_proc WHERE proname = 'what_quarter_is';\"], db_name, conn)[0]\n    assert len(test_query_result_1) == 1, f'Expected 1 row, but found {len(test_query_result_1)} row(s).'\n    test_query_result_2 = execute_queries([\"SELECT what_quarter_is('2024-01-01', 4)\"], db_name, conn)[0]\n    assert test_query_result_2[0][0] == 4, f'Expected 4, but found {test_query_result_2[0][0]}'\n    test_query_result_3 = execute_queries([\"SELECT what_quarter_is('2023-07-01', 2)\"], db_name, conn)[0]\n    assert test_query_result_3[0][0] == 2, f'Expected 2, but found {test_query_result_3[0][0]}.'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_24", "db_id": "financial", "query": "In the financial database, I need to classify transactions by quarter, but I want the quarters to start at a configurable month. If I set the quarter to start in April, then April, May, and June should be the first quarter. I think I need a function what_quarter_is(date_in, start_month). For example, what_quarter_is('1995-07-23', 4) = 2. The default EXTRACT(QUARTER FROM date) function in PostgreSQL starts quarters in January, which does not meet my requirements.", "issue_sql": ["SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');"], "preprocess_sql": [], "clean_up_sql": ["DROP FUNCTION what_quarter_is(date, integer);"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table, a.attname as base_col, (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table, UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col, pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey) WHERE c.confrelid = (select oid from pg_class where relname = 'users') AND c.confrelid!=c.conrelid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_25", "db_id": "codebase_community", "query": "In the codebase_community database, I have a table named 'users' with a primary key of 'id'. I need to find all tables, columns, and constraints that reference the 'users' table regardless of which column in 'users' is referenced. For example, if there is a table named 'posts' with a foreign key constraint as follows:\\nCREATE TABLE posts (\\n    id bigint NOT NULL,\\n    owneruserid bigint NULL,\\n    lasteditoruserid bigint NULL,\\n    PRIMARY KEY (id),\\n    FOREIGN KEY (owneruserid) REFERENCES users(id),\\n    FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\n);\\nI should get back rows like the following:\\nbase_table     base_col    referencing_table   referencing_col  constraint_sql\\nusers          id          posts               owneruserid        CONSTRAINT posts_owneruserid_fkey FOREIGN KEY (owneruserid) REFERENCES users(id)\\nusers          id          posts               lasteditoruserid   CONSTRAINT posts_lasteditoruserid_fkey FOREIGN KEY (lasteditoruserid) REFERENCES users(id)\\nNon-primary key references should also be listed and it should handle compound keys.", "issue_sql": ["SELECT (select r.relname from pg_class r where r.oid = c.confrelid) as base_table,\\n       a.attname as base_col,\\n       (select r.relname from pg_class r where r.oid = c.conrelid) as referencing_table,\\n       UNNEST((select array_agg(attname) from pg_attribute where attrelid = c.conrelid and array[attnum] <@ c.conkey)) as referencing_col,\\n       pg_get_constraintdef(c.oid) contraint_sql  FROM pg_constraint c join pg_attribute a on c.confrelid=a.attrelid and a.attnum = ANY(confkey)\\n WHERE c.confrelid = (select oid from pg_class where relname = 'users')\\n   AND c.confrelid!=c.conrelid;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT bank, first_value(bank) over (partition by account_id order by date rows between current row and unbounded following) as next_bank FROM trans WHERE bank is not null ORDER BY account_id, date;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_26", "db_id": "financial", "query": "We have a table 'trans' that records all transactions made by clients in various accounts. Each transaction has a 'trans_id', 'account_id', 'date', 'type', 'operation', 'amount', 'balance', 'k_symbol', 'bank', and 'account'. We need to add a new column 'next_bank' to the 'trans' table that indicates the next non-null 'bank' value for each transaction, ordered by 'date' within each 'account_id'. For example, if a transaction has a null 'bank', the 'next_bank' should be the 'bank' of the next transaction in the same account that has a non-null 'bank'. The user attempted to use the following SQL query, which fails in PostgreSQL due to the lack of support for the 'ignore nulls' clause in the window function. The query is as follows:", "issue_sql": ["SELECT first_value(bank ignore nulls) over (partition by account_id order by date rows unbounded following) as next_bank FROM trans;"], "preprocess_sql": ["ALTER TABLE trans ADD COLUMN next_amount int;"], "clean_up_sql": ["ALTER TABLE trans DROP COLUMN next_amount;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT t1.team_api_id, t1.team_short_name, t2.buildUpPlaySpeed FROM Team t1 INNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_27", "db_id": "european_football_2", "query": "I have two separate queries that I want to combine. The first query retrieves the team_api_id and short names of teams from the Team table. The second query retrieves the buildUpPlaySpeed from the Team_Attributes table, based on the team_api_id. I want to combine these two queries into a single query that outputs theteam_api_id, team long name, and the corresponding buildUpPlaySpeed. I have tried the following sql: \\nsql \\\\\\\\nSELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN ( SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id ) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id; \\\\\\\\n\\n However, when I ran this query, I encountered an error: There is an entry for table 'data' but it cannot be referenced from this part of the query. How can I modify my query so that it properly combines the results of the two queries?", "issue_sql": ["SELECT team_api_id, team_short_name FROM Team as data FULL OUTER JOIN (SELECT buildUpPlaySpeed, team_api_id FROM Team_Attributes ta WHERE team_api_id = data.team_api_id) AS subquery_alias ON data.team_api_id = subquery_alias.team_api_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH years AS ( SELECT date_trunc('year', date) as year, COUNT(*) as count FROM trans GROUP BY 1 UNION ALL SELECT date_trunc('year', date) as year, COUNT(*) as count FROM loan GROUP BY 1 ) SELECT year, SUM(count) as count FROM years GROUP BY year ORDER BY year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_28", "db_id": "financial", "query": "We have two tables in our financial database: `trans` and `loan`. The `trans` table records all transactions made by clients, while the `loan` table records all loans issued to clients. Each transaction and loan has a timestamp indicating when it occurred. We want to combine these two tables into a single dataset, without worrying about clashing IDs, and then count the number of actions (transactions and loans) per year. The goal is to produce a result set that shows the total number of actions in each year (order by year). I attempted to write a query but encountered an error related to the GROUP BY clause.", "issue_sql": ["WITH one AS ( SELECT date_trunc('year', date) as timeOne, COUNT(*) as trans_count FROM trans ORDER BY timeOne ), two AS ( SELECT date_trunc('year', date) as timeTwo, COUNT(*) as loan_count FROM loan ORDER BY timeTwo ) SELECT timeOne as year, SUM(trans_count, loan_count) as count FROM one, two ORDER BY 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH gen_transactions AS ( SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER)) ), shuffle AS ( SELECT CustomerID, Amount, row_number() OVER (ORDER BY CustomerID, Amount) AS rn FROM gen_transactions ) SELECT CustomerID, Amount FROM shuffle WHERE rn <= 5 ORDER BY rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_29", "db_id": "debit_card_specializing", "query": "In the context of the debit_card_specializing database, we need to select 5 customers from the transactions_1k table. The selection method is as follows: first, we generate records for each customer equal to their transaction amount (Amount) value (e.g., if Amount is 10, then 10 records are generated for that customer), then sort by CustomerID and Amount, and select the first 5 records as winners. The result should include CustomerID, Amount, and also a row number column (rn) to indicate each winner's ranking from 1 to 5, ordered by this ranking. The transactions_1k table contains the necessary data with columns such as CustomerID and Amount.", "issue_sql": ["WITH gen_transactions AS ( SELECT CustomerID, Amount FROM transactions_1k CROSS JOIN LATERAL generate_series(1, CAST(Amount AS INTEGER)) ) SELECT CustomerID, Amount, ROW_NUMBER() OVER (ORDER BY random()) AS rn FROM gen_transactions LIMIT 5;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["INSERT INTO card_information(price)\nSELECT jsonb_agg(s.elements)\nFROM (\n  SELECT jsonb_array_elements(price) FROM card_information\n) AS s(elements);\n\nSELECT * FROM card_information;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    assert isinstance(concatenated_json, list), f'Expected result to be a list, but found {type(concatenated_json)}'   \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_json_length = 9\n    assert len(concatenated_json) == expected_json_length, f'Expected {expected_json_length} elements, but found {len(concatenated_json)} elements'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[3][0]\n    expected_values = [{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}, {\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}, {\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_30", "db_id": "card_games", "query": "The data in the table \"card_infomation\" includes one column named \"price\". I am using postgres and I have multiple entries of jsonb inside an array in a single column called price. They're input as the card names and corresponding prices. There are multiple rows, with multiple json elements inside of each one of them. I would like to combine them into one big entry in one row, so that I will just have one row of one column as a result.", "issue_sql": ["INSERT INTO card_information(price) SELECT jsonb_agg(price) FROM (SELECT price FROM card_information) AS subquery;SELECT * FROM card_information;"], "preprocess_sql": ["\nCREATE TABLE card_information (price JSONB); \nINSERT INTO card_information (price) VALUES \n('[{\"a\": 1}, {\"b\": 2}, {\"c\": 0.5}]'::jsonb), \n('[{\"d\": 2.2}, {\"e\": 2.4}, {\"f\": 3.5}]'::jsonb), \n('[{\"g\": 1.7}, {\"h\": 5.4}, {\"i\": 8.9}]'::jsonb);\nSELECT * FROM card_information;\n"], "clean_up_sql": ["DROP TABLE card_information;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency\nFROM (\n    SELECT DISTINCT ON (t.k_symbol)\n           t.k_symbol, t.operation, t.amount, t.balance, t.account_id, t.date\n    FROM trans t\n    WHERE t.account_id = 1\n    AND t.type = 'PRIJEM'\n    ORDER BY t.k_symbol, t.date\n) t\nINNER JOIN account a ON t.account_id = a.account_id LIMIT 100"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_UROK = [i for i, row in enumerate(pred_query_result) if row[0] == 'UROK']\n    row_n = row_with_UROK[0]\n    assert pred_query_result[row_n][1] is None, f'Expected operation to be NULL, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 19, f'Expected amount to be 19, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 17298, f'Expected balance to be 17298, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    row_with_NULL = [i for i, row in enumerate(pred_query_result) if row[0] is None]\n    row_n = row_with_NULL[0]\n    assert pred_query_result[row_n][1] == 'VKLAD', f'Expected operation to be VKLAD, but found {pred_query_result[row_n][1]}'\n    assert pred_query_result[row_n][2] == 1000, f'Expected amount to be 1000, but found {pred_query_result[row_n][2]}'\n    assert pred_query_result[row_n][3] == 1000, f'Expected balance to be 1000, but found {pred_query_result[row_n][3]}'\n    assert pred_query_result[row_n][4] == 'POPLATEK MESICNE', f'Expected frequency to POPLATEK MESICNE, but found {pred_query_result[row_n][4]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_31", "db_id": "financial", "query": "In the financial database, I have two tables: `trans` and `account`. The `trans` table contains transaction details including the `account_id`, `date`, `type`, `operation`, `amount`, `balance`, `k_symbol`, `bank`, and `account`. The `account` table contains account details including `account_id`, `district_id`, `frequency`, and `date`. For each transaction in the `trans` table that matches a specific `account_id` and `type`, I want to join the corresponding record in the `account` table with the minimum transaction date. I want to group the results by `k_symbol` and extract the `k_symbol`, `operation`, `amount`,  `balance`, and `frequency` from the selected transaction record.", "issue_sql": ["SELECT t.k_symbol, t.operation, t.amount, t.balance, a.frequency FROM trans t INNER JOIN account a ON t.account_id = a.account_id WHERE t.account_id = 1 AND t.type = 'PRIJEM' GROUP BY t.k_symbol"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH cte AS (\n    SELECT user_id,\n           TO_DATE(purchase_date || '-01','YYYY-MM-DD') AS date_as_date\n    FROM purchase\n), islands AS (\n    SELECT *,\n           CASE WHEN LAG(date_as_date) OVER(PARTITION BY user_id ORDER BY date_as_date) + INTERVAL '1 month' <> date_as_date\n                THEN 1 ELSE 0\n           END AS new_partition\n    FROM cte\n), partitioned_islands AS (\n    SELECT user_id,\n           SUM(new_partition) OVER(PARTITION BY user_id ORDER BY date_as_date) AS partitions\n    FROM islands\n), count_per_island AS (\n    SELECT COUNT(*) AS num_consecutive_dates\n    FROM partitioned_islands\n    GROUP BY user_id, partitions\n    ORDER BY ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY COUNT(*) DESC)\n    FETCH FIRST 1 ROWS WITH TIES\n)\nSELECT num_consecutive_dates AS streakLength,\n       COUNT(*) AS numOfOccurrences\nFROM count_per_island\nGROUP BY streakLength\nORDER BY streakLength DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 5, f'Expected longest streak length to be 5, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == 1, f'Expected 1 user with longest streak of 5 months, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][0] == 4, f'Expected longest streak length to be 4, but found {pred_query_result[1][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == 2, f'Expected 2 users with longest streak of 4 months, but found {pred_query_result[1][1]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_32", "db_id": "card_games", "query": "I am trying to analyze the purchasing behavior of users in our card_games database to find out the count of sequential monthly purchases and their lengths for each user. I want to identify the longest streaks of consecutive monthly purchases for each user and then count how many users have each longest streak length. For example, if a user made purchases in March, April, May, and June, that would be a streak of 4 months. If another user made purchases in January, February, and March, that would be a streak of 3 months. I need to find the longest streak for each user and then count how many users have the longest streak of a certain length. The expected result should show the streak length and the number of users who have that longest streak length.", "issue_sql": ["SELECT user_id, COUNT(*) AS num_consecutive_months FROM (SELECT user_id, purchase_date, DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')) AS month_date, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD'))) - ROW_NUMBER() OVER(PARTITION BY user_id, DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')) - INTERVAL '1 month' * ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY DATE_TRUNC('month', TO_DATE(purchase_date || '-01', 'YYYY-MM-DD')))) AS grp FROM purchase) sub GROUP BY user_id, grp ORDER BY COUNT(*) DESC LIMIT 1;"], "preprocess_sql": ["\nCREATE TABLE purchase ( purchase_date VARCHAR(255), user_id VARCHAR(255) ); INSERT INTO purchase(purchase_date, user_id) VALUES('2020-03', 'alex01'), ('2020-04', 'alex01'), ('2020-05', 'alex01'), ('2020-06', 'alex01'), ('2020-12', 'alex01'), ('2021-01', 'alex01'), ('2021-02', 'alex01'), ('2021-03', 'alex01'), ('2020-04', 'jon03'), ('2020-05', 'jon03'), ('2020-06', 'jon03'), ('2020-09', 'jon03'), ('2021-11', 'jon03'), ('2021-12', 'jon03'), ('2022-01', 'jon03'), ('2022-02', 'jon03'), ('2020-05', 'mark05'), ('2020-06', 'mark05'), ('2020-07', 'mark05'), ('2020-08', 'mark05'), ('2020-09', 'mark05');\n"], "clean_up_sql": ["DROP TABLE purchase;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH tab_with_cardid AS (\n    SELECT *,\n           REGEXP_REPLACE(cardid, '([^-]+)-[^-]+-(.*)', '\\1-\\2') AS pure_cardid\n    FROM card_info\n),\nranked_visits AS (\n    SELECT *,\n           ROW_NUMBER() OVER (PARTITION BY pure_cardid ORDER BY type) AS rn\n    FROM tab_with_cardid\n)\nSELECT cardid, pure_cardid, type\nFROM ranked_visits\nWHERE rn = 1"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][1] == '1234-HIJK', f'Expected ci_ku to be 1234-HIJK, but found {pred_query_result[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][2] == 'A', f'Expected l1m_visits to be A, but found {pred_query_result[0][2]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][1] == '56457-DF-GH-TC', f'Expected ci_ku to be 56457-DF-GH-TC, but found {pred_query_result[1][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[1][2] == 'D', f'Expected l1m_visits to be D, but found {pred_query_result[1][2]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_33", "db_id": "financial", "query": "I am working with a table (card_info) containing card IDs, company names, and types. My task is to extract the pure card id without company information, \"pure_cardid\", from the cardid field by removing the substring between the first and second hyphens. Afterward, I need to retrieve the minimum value of type for each unique \"pure_cardid\", considering that multiple records may exist for the same \\pure_cardid\". My main challenge is how to correctly perform both the string manipulation and the aggregation in a single query.", "issue_sql": ["WITH tab_with_cardid AS (\n   select split(cardid, '-', 3)ivm_arr,\n\n           type,\n           last_refresh_date\n    FROM db.scema.table\n), ranked_visits AS (\n    SELECT *, ROW_NUMBER() OVER(PARTITION BY CONCAT(ivm_arr[2],item) as temp ORDER BY type) AS rn\n    FROM tab_with_cardid\n)\nSELECT cardid, pure_cardid\nFROM ranked_visits\nWHERE rn = 1"], "preprocess_sql": ["CREATE TABLE card_info (\n    cardid VARCHAR(50),\n    company VARCHAR(10),\n    type CHAR(1),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    is_active BOOLEAN DEFAULT TRUE,\n    expiration_date DATE DEFAULT (CURRENT_DATE + INTERVAL '3 years'),\n    card_status VARCHAR(20) DEFAULT 'active',\n    security_level INTEGER DEFAULT 2,\n    last_used_timestamp TIMESTAMP WITH TIME ZONE,\n    transaction_count BIGINT DEFAULT 0,\n    credit_limit NUMERIC(12, 2) DEFAULT 5000.00,\n    metadata JSONB DEFAULT '{}'::jsonb,\n    card_holder_id UUID DEFAULT gen_random_uuid(),\n    notes TEXT DEFAULT NULL,\n    verification_hash VARCHAR(64) DEFAULT NULL,\n    is_international BOOLEAN DEFAULT FALSE,\n    annual_fee NUMERIC(8, 2) DEFAULT 0.00,\n    reward_points INTEGER DEFAULT 0,\n    last_refresh_date DATE DEFAULT CURRENT_DATE\n);", "INSERT INTO card_info (cardid, company, type, created_at, updated_at, is_active, expiration_date, card_status, security_level, last_used_timestamp, transaction_count, credit_limit, metadata, card_holder_id, notes, verification_hash, is_international, annual_fee, reward_points, last_refresh_date) VALUES\n('1234-5678-HIJK', '1234', 'A', '2022-01-15 08:30:00+00', '2023-05-20 14:45:00+00', TRUE, '2025-01-15', 'active', 3, '2023-06-10 09:15:00+00', 42, 7500.00, '{\"chip_type\": \"EMV\", \"contactless\": true}'::jsonb, 'a1b2c3d4-e5f6-4321-8765-9abcdef01234', 'Premium customer card', 'e8b7c6d5a4f3e2d1c0b9a8f7e6d5c4b3a2f1e0d9c8b7a6f5e4d3c2b1a0', TRUE, 99.99, 1250, '2023-06-15'),\n('1234-9012-HIJK', '1234', 'B', '2021-11-05 10:20:00+00', '2023-04-12 16:30:00+00', TRUE, '2024-11-05', 'active', 2, '2023-06-08 13:45:00+00', 27, 3000.00, '{\"chip_type\": \"EMV\", \"contactless\": false}'::jsonb, 'b2c3d4e5-f6a1-5432-9876-0abcdef12345', 'Standard customer card', 'f7e6d5c4b3a2f1e0d9c8b7a6f5e4d3c2b1a0f9e8d7c6b5a4f3e2d1c0b9', FALSE, 49.99, 750, '2023-06-10'),\n('56457-12456-DF-GH-TC', '56457', 'D', '2022-03-22 09:10:00+00', '2023-06-01 11:25:00+00', FALSE, '2025-03-22', 'suspended', 1, '2023-05-30 17:20:00+00', 8, 1000.00, '{\"chip_type\": \"magnetic\", \"contactless\": false}'::jsonb, 'c3d4e5f6-a1b2-6543-0987-1abcdef23456', 'Corporate expense card', 'a4f3e2d1c0b9a8f7e6d5c4b3a2f1e0d9c8b7a6f5e4d3c2b1a0f9e8d7c6b5', TRUE, 0.00, 100, '2023-06-05');"], "clean_up_sql": ["DROP TABLE card_info;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT player_api_id, date, overall_rating FROM Player_Attributes ORDER BY ROW_NUMBER() OVER(PARTITION BY player_api_id ORDER BY date DESC) FETCH FIRST 1 ROWS WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_34", "db_id": "european_football_2", "query": "Suppose we have the following table in the 'european_football_2' database that records the overall rating of players over time:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|505942       |2015-11-19|67          |\\n|505942       |2015-09-21|62          |\\n|155782       |2016-03-15|75          |\\n|155782       |2015-12-10|74          |\\n|162549       |2016-01-20|70          |\\n|162549       |2015-10-25|68          |\\nFor each player, we want the latest overall rating based on the date. The final table would be:\\n|player_api_id|date|overall_rating|\\n|-------------|----|--------------|\\n|505942       |2016-02-18|67          |\\n|155782       |2016-03-15|75          |\\n|162549       |2016-01-20|70          |\\nI attempted to group by player_api_id while ordering by date and then getting the first value:\\nsql \\\\nSELECT player_api_id, MAX(date), FIRST(overall_rating) \\\\nFROM Player_Attributes \\\\nGROUP BY player_api_id \\\\nORDER BY date desc \\\\n\\nBut this doesn't work.", "issue_sql": ["SELECT player_api_id, MAX(date), FIRST(overall_rating) FROM Player_Attributes GROUP BY player_api_id ORDER BY date desc;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION get_user_ages() RETURNS setof numeric AS $BODY$ DECLARE curr_age  text; BEGIN FOR curr_age IN SELECT Age FROM users LOOP BEGIN RETURN NEXT curr_age::numeric; EXCEPTION WHEN OTHERS THEN NULL; END; END LOOP; END $BODY$  LANGUAGE plpgsql;SELECT * FROM get_user_ages();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT count(*) FROM users;\"], db_name, conn)\n    ori_count = res[0][0]\n    res, _, _ = execute_queries([\"SELECT count(*) FROM get_user_ages();\"], db_name, conn)\n    next_count = res[0][0]\n    assert next_count ==  (ori_count-1), f'Expected 40325 row in get_user_ages table, got {next_count}'\n    res,_, _ = execute_queries([\"SELECT count(get_user_ages) FROM get_user_ages() where get_user_ages = 31 GROUP BY get_user_ages order by get_user_ages;\"], db_name,conn)\n    init_res = res[0][0]\n    res, _, _ = execute_queries([\"select count(age) from users where age = '31' group by age order by age ;\"], db_name,conn)\n    other_res = res[0][0]\n    assert init_res == other_res, f'Expected same result, got {init_res} and {other_res}'\n    \n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_35", "db_id": "codebase_community", "query": "I am using a tool that allows querying user data in our local database using the PostgreSQL interface. I am running a simple query to print all ages of the users on our platform. However, I am getting an error message that says 'ERROR:  invalid input syntax for type numeric: \"text\"'. I am not sure why I am getting this error. Can you help me understand why this error is occurring and how I can fix it?", "issue_sql": ["SELECT Age::numeric FROM users;"], "preprocess_sql": ["ALTER TABLE users ALTER COLUMN Age SET DATA TYPE text; INSERT INTO users VALUES (1212121,3150,'2010-07-19 19:09:39','JMS','2014-09-13 04:03:25',NULL,NULL,NULL,257,138,7,134002,'Invalid Age',NULL);"], "clean_up_sql": ["DELETE FROM users WHERE id = 1212121; ALTER TABLE users ALTER COLUMN age SET DATA TYPE integer USING age::integer;"], "category": "Management", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION profileTrigger() RETURNS TRIGGER AS $profile_table$ begin insert into profiles (id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), strpos(right(new.WebsiteUrl, char_length(new.WebsiteUrl) - 7), '.')-1);return new; end; $profile_table$ LANGUAGE plpgsql;CREATE TRIGGER profile_table AFTER INSERT ON users FOR EACH ROW EXECUTE PROCEDURE profileTrigger();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    check_sql = [\"INSERT INTO users VALUES (341111,185,'2010-07-19 19:11:11','Christopher D. Long','2014-09-13 00:02:35','http://angrystatistician.blogspot.com','Versailles, KY','<p>Consulting analyst for the San Diego Padres, Houston Rockets.</p><p>Twitter:</a></p><p>LinkedIn/p>',27,23,0,509455,NULL,'http://i.stack.imgur.com/km1pr.jpg')\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([\"SELECT * FROM profiles LIMIT 1;\"], db_name,conn)\n    res_id, res_CreationDate, res_WebsiteUrl = res[0][0], res[0][1], res[0][2]\n    assert len(res) == 1, f\"Expected 1 row in profiles table, got {len(res)}\"\n    assert res_id == '341111', f\"Expected id to be '341111', got {res_id}\"\n    assert res_WebsiteUrl == 'angrystatistician', f\"Expected WebsiteUrl to be 'angrystatistician', got {res_WebsiteUrl}\"\n    \n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_36", "db_id": "codebase_community", "query": "In our local database, we have two tables `users` and `profiles`. When a new user is added to the `users` table, we want to automatically create a corresponding profile in the `profiles` table. The `profiles` table has three columns: `id`, `CreationDate`, and `WebsiteUrl`. The `WebsiteUrl` should be derived from the user's WebsiteUrl by taking the part before the '.com'  and after the 'http://'. For example, 'http://stackoverflow.com' should become 'stackoverflow'. To achieve this, I created a trigger on the `users` table with the following function: sql begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.id, new.WebsiteUrl, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1); return new; end;  However, when a new user is added, I encounter the error:  ERROR: function charindex(unknown, text) does not exist (SQLSTATE 42883)", "issue_sql": ["begin insert into profiles (Id, CreationDate, WebsiteUrl) select new.Id, new.CreationDate, left(replace(new.WebsiteUrl, '.', '-'), charindex('@', replace(new.WebsiteUrl, '.', '-')) - 1);return new;end;"], "preprocess_sql": ["DROP TABLE IF EXISTS profiles;", "CREATE TABLE profiles (id varchar(256) NOT NULL, CreationDate text, WebsiteUrl text, last_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, profile_status VARCHAR(50) DEFAULT 'active', verification_level INTEGER DEFAULT 0, metadata JSONB DEFAULT '{}'::jsonb, visit_count BIGINT DEFAULT 0, privacy_settings VARCHAR(100) DEFAULT 'public', theme_preference VARCHAR(50) DEFAULT 'light', notification_enabled BOOLEAN DEFAULT true, profile_completion_percentage NUMERIC(5,2) DEFAULT 0.00, last_login_ip VARCHAR(45) DEFAULT NULL, security_question TEXT DEFAULT NULL, security_answer TEXT DEFAULT NULL, profile_uuid UUID DEFAULT gen_random_uuid(), bio_text TEXT DEFAULT '', subscription_tier VARCHAR(50) DEFAULT 'free', account_locked BOOLEAN DEFAULT false, recovery_email VARCHAR(255) DEFAULT NULL, PRIMARY KEY (id));"], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM cards WHERE  3 = (CASE WHEN availability = 'paper' THEN 1 ELSE 0 END) + (CASE WHEN bordercolor = 'black' THEN 1 ELSE 0 END) + (CASE WHEN rarity = 'uncommon' THEN 1 ELSE 0 END) + (CASE WHEN types = 'Creature' THEN 1 ELSE 0 END);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_37", "db_id": "financial", "query": "We have a large transaction table in our financial database with over 180 million rows and 20 GB in size. The table is structured to store detailed transaction records for various accounts. We are running a query to retrieve specific transactions based on a list of account IDs, a specific bank, and a range of transaction types. The query is taking an unexpectedly long time to execute when the shared buffers are cold, around 9 seconds, but only 25 ms when the data is cached. We suspect that the query planner is not choosing the most optimal execution plan. We have tried adding a covering index and forcing a Bitmap Heap Scan, but we would like to understand why the planner is not making the best choice and find a more permanent solution to improve performance to around 1-2 seconds.", "issue_sql": ["SELECT t.trans_id,       t.account_id,       t.date,       t.type,       t.amount  FROM trans t  JOIN account a    ON t.account_id = a.account_id WHERE a.district_id = 18   AND t.bank = 'AB'  AND t.type IN ('PRIJEM', 'VYDAJ')"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH j AS (INSERT INTO event (event_id, event_name, event_date, type, notes, location, status) VALUES ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') ON CONFLICT (event_id) DO UPDATE SET event_id = event.event_id RETURNING xmax = 0 AS inserted, *) INSERT INTO failure (event, member) SELECT event_id, 'rec280Sk7o31iG0Tx' FROM j WHERE NOT inserted RETURNING *;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1, _, _ = execute_queries([\"SELECT event FROM failure;\"], db_name, conn)\n    pred_query_result_2, _, _  = execute_queries([\"SELECT member FROM failure;\"], db_name, conn)\n    assert len(pred_query_result_1) == 1, f'Expected 1 rows, but found {len(pred_query_result_1)} rows' \n    assert len(pred_query_result_2) == 1, f'Expected 1 rows, but found {len(pred_query_result_2)} rows'\n    assert pred_query_result_1[0][0] == 'recAlAwtBZ0Fqbr5K', f'Expected event ID to match, but found {pred_query_result_1[0][0]}'\n    assert pred_query_result_2[0][0] == 'rec280Sk7o31iG0Tx', f'Expected member ID to match, but found {pred_query_result_2[0][0]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_38", "db_id": "card_games", "query": "A user is working with a table named `cards` in the `card_games` database. They want to find card records that match specific criteria: `availability` is 'paper', `bordercolor` is 'black', `rarity` is 'uncommon', and `type` is 'Creature'. They can write a query to get rows that match all these conditions. However, they also want to find cards that meet 3 out of these 4 criteria. Can this be done in a single SQL query?", "issue_sql": ["SELECT * FROM cards WHERE availability = 'paper' AND bordercolor = 'black' AND rarity = 'uncommon' AND types = 'Creature';"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ LANGUAGE plpgsql;CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([f\"SELECT player_name FROM player WHERE id = 1;\"], db_name,conn)\n    old_p_name = res[0][0]\n    check_sql = [f\"UPDATE player SET player_name = {old_p_name} WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT * FROM player_audits\"], db_name, conn)\n    assert len(res) == 0, f\"The trigger conditioning does not work.\"\n    \n    check_sql = [f\"UPDATE player SET player_name = 'James Higginsons' WHERE id = 1;\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT old_player_name FROM player_audits LIMIT 1\"], db_name,conn)\n    old_name = res[0][0]\n    assert old_name == 'Aaron Appindangoye', f\"The trigger does not work.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_39", "db_id": "student_club", "query": "I want to insert a new event into the 'event' table and, in case of a duplicate event ID (which is unique), log the failure in the 'failure' table with specific event ID and member ID indicating the error. For example, I want to insert an event with the ID 'recAlAwtBZ0Fqbr5K' and name 'Annual Gala'. If it fails due to a duplicate name, log the failure with the member ID 'rec280Sk7o31iG0Tx'. My current SQL statement is producing an error: syntax error at or near 'insert'.", "issue_sql": ["insert into event (event_id, event_name, event_date, type, notes, location, status) values ('recAlAwtBZ0Fqbr5K', 'Annual Gala', '2023-12-15T19:00:00', 'Social', 'Annual Gala for club members', 'Grand Ballroom', 'Open') on conflict (event_id) do insert into failure (event, member) values ('recAlAwtBZ0Fqbr5K', 'rec280Sk7o31iG0Tx');"], "preprocess_sql": ["CREATE TABLE failure (event VARCHAR(255) NOT NULL, member VARCHAR(255) NOT NULL, failure_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, failure_reason TEXT DEFAULT 'Duplicate entry', retry_count INTEGER DEFAULT 0, is_resolved BOOLEAN DEFAULT FALSE, resolution_notes TEXT, resolution_timestamp TIMESTAMP WITH TIME ZONE, reported_by VARCHAR(100) DEFAULT 'system', severity_level VARCHAR(20) DEFAULT 'medium', error_code VARCHAR(50), metadata JSONB DEFAULT '{}'::jsonb, ip_address VARCHAR(45), user_agent TEXT, session_id UUID DEFAULT gen_random_uuid(), PRIMARY KEY (event, member));"], "clean_up_sql": ["DROP TABLE IF EXISTS failure;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT t.userid, t.tag\nFROM   preference_tag t\nWHERE  NOT EXISTS (\n   SELECT FROM unnest('{%friend%, %cat%}'::text[]) AS p(pattern)\n   WHERE  NOT EXISTS (\n      SELECT FROM unnest(t.tag) AS a(elem)\n      WHERE  a.elem LIKE p.pattern\n      )\n   )"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[0][0] == 1, f'Expected id to be 1, but found {pred_query_result[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][1] == ['wildcat', 'potato', 'alices-friend'], f\"Expected value to be ['wildcat', 'potato', 'alices-friend'], but found {pred_query_result[2][1]}\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert pred_query_result[2][0] == 4, f'Expected id to be 4, but found {pred_query_result[2][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_40", "db_id": "european_football_2", "query": "I am new to functions and triggers in PostgreSQL. I am trying to create a trigger function to log changes in the player's name in the Player table. I followed a tutorial but encountered an error. The code block and the error are provided below. The Player table contains detailed information about players. The player_audits table is intended to keep track of any changes to the player's name along with the timestamp of the change.", "issue_sql": ["CREATE OR REPLACE FUNCTION log_player_name_changes() RETURNS trigger AS $BODY$ BEGIN IF NEW.player_name <> OLD.player_name THEN INSERT INTO player_audits(player_id, old_player_name, changed_on) VALUES(OLD.id, OLD.player_name, now()); END IF; RETURN NEW; END; $BODY$ CREATE TRIGGER tr_change_playername AFTER UPDATE OF player_name ON player FOR EACH ROW EXECUTE PROCEDURE log_player_name_changes();"], "preprocess_sql": ["CREATE TABLE player_audits (\n    player_id integer,\n    old_player_name text,\n    changed_on timestamp without time zone,\n    audit_id SERIAL,\n    change_type VARCHAR(50) DEFAULT 'UPDATE',\n    changed_by VARCHAR(100) DEFAULT current_user,\n    change_reason TEXT DEFAULT 'Regular maintenance',\n    system_version VARCHAR(20) DEFAULT '1.0.0',\n    client_ip INET DEFAULT '0.0.0.0',\n    is_approved BOOLEAN DEFAULT false,\n    approval_date TIMESTAMP WITH TIME ZONE,\n    metadata JSONB DEFAULT '{}'::jsonb,\n    revision_number INTEGER DEFAULT 1,\n    is_significant_change BOOLEAN DEFAULT false,\n    audit_hash UUID DEFAULT gen_random_uuid(),\n    previous_audit_id INTEGER,\n    retention_period INTERVAL DEFAULT '1 year'::interval,\n    notes TEXT,\n    priority SMALLINT DEFAULT 3,\n    tags TEXT[] DEFAULT '{}'::text[]\n);"], "clean_up_sql": ["DROP TABLE IF EXISTS player_audits;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM account_info WHERE condition::jsonb @> '[ { \"conditions\": { \"rootcompanyid\": { \"$in\": [5] } } } ]'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} row(s).'\n    assert pred_query_result[0][0] == 1, f'Expected the account_id is 1, but found {pred_query_result[0][0]}'\n    assert pred_query_result[1][0] == 3, f'Expected the account_id is 3, but found {pred_query_result[1][0]}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_41", "db_id": "student_club", "query": "\nI have an event_attendance table and what I am trying to build should be one row for each member.\\nColumn definitions of the expected output:\\nGame_AttendanceDate : Latest attendance date based on date where EventType = 'Game'\\nGame_Attendances: Total number of Game events attended by each member.\\nWorkshop_AttendanceDate: Latest attendance date based on date where EventType = 'Workshop'\\nWorkshop_Attendances: Total number of Workshop events attended by each member.\\nTotal_Attendances: Total events attended by each member. I tried on one categories but I have to do this calculation for another 2 categories then that will add up another 2 sub queries. Is there anyway to optimize the SQL code?\n", "issue_sql": ["SELECT\n    COALESCE(a.MemberID, b.MemberID) AS MemberID,\n    a.AttendanceDate AS Latest_Game_Date,\n    a.Game_Attendance AS Total_Game_Attendance,\n    b.AttendanceDate AS Latest_Workshop_Date,\n    b.Workshop_Attendance AS Total_Workshop_Attendance,\n    a.Game_Attendance + b.Workshop_Attendance AS Total_Attendance\nFROM\n(\n    SELECT\n        MemberID,\n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Game_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Game'\n) a\nFULL JOIN\n(\n    SELECT\n        MemberID,\n        EventType,\n        AttendanceDate,\n        COUNT(EventID) OVER(PARTITION BY MemberID, EventType) AS Workshop_Attendance,\n        ROW_NUMBER() OVER(PARTITION BY MemberID, EventType ORDER BY AttendanceDate DESC) AS RNUM\n    FROM event_attendance\n    WHERE EventType = 'Workshop'\n) b\nON a.MemberID = b.MemberID\nWHERE (a.RNUM = 1 OR a.RNUM IS NULL) AND (b.RNUM = 1 OR b.RNUM IS NULL);"], "preprocess_sql": ["\nCREATE TABLE event_attendance (MemberID int, EventID int, EventType text, AttendanceDate date); INSERT INTO event_attendance (MemberID, EventID, EventType, AttendanceDate) VALUES (1, 101, 'Game', '2023-01-01'), (1, 102, 'Game', '2023-01-10'), (1, 103, 'Game', '2023-02-15'), (1, 104, 'Game', '2023-02-20'), (1, 105, 'Workshop', '2023-03-01'), (1, 106, 'Workshop', '2023-03-20'), (2, 107, 'Game', '2023-01-15'), (2, 108, 'Workshop', '2023-02-06');\n"], "clean_up_sql": ["DROP TABLE event_attendance;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["CREATE UNIQUE INDEX idx_hero_power_active ON hero_power (hero_id, power_id) WHERE active;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    try:\n        insert_sql_1 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, TRUE);'], db_name, conn)[0];\n        assert False, 'Inserting duplicate id should have raised an error'\n    except Exception as err:\n        assert 'duplicate' in str(err), f'Expected duplicate key error, but found {err}.'\n    check_insertion_result_1 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_1[0][0] == 1, 'Expected only 1 entry for hero_id 1 and power_id 1.'\n    insert_sql_2 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_2 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_2[0][0] == 2, 'Expected two entries for hero_id 1 and power_id 1, one active and one inactive.'\n    insert_sql_3 = execute_queries(['INSERT INTO hero_power (hero_id, power_id, active) VALUES (1, 1, FALSE);'], db_name, conn)[0];\n    check_insertion_result_3 = execute_queries(['SELECT COUNT(*) FROM hero_power WHERE hero_id = 1 AND power_id = 1;'], db_name, conn)[0];\n    assert check_insertion_result_3[0][0] == 3, 'Expected three entries for hero_id 1 and power_id 1, one active and two inactive.'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_42", "db_id": "codebase_community", "query": "\nI'm working with a table called `preference_tag`, which contains a `userid` and an array of tags in the `tag` column. \nI need to find rows in the user's tag preference table where the array contains the corresponding tags. \nFor example, when querying with `ARRAY['friend', 'cat']`, it works as expected, returning the rows where the array contains both 'friend' and 'cat'. \nHowever, when I try to use wildcard symbols (e.g., `ARRAY['%friend%', '%cat%']`), it doesn't return the expected results. \nThe issue seems to be related to the `%` symbols, as I want to match any values that contain substrings like 'friend' or 'cat', but I don't need an exact match.\n", "issue_sql": ["SELECT DISTINCT userid, tag\nFROM preference_tag\nWHERE tag @> (ARRAY['friend', 'cat']::VARCHAR[]);"], "preprocess_sql": ["\nCREATE TABLE preference_tag (\n    userid INT PRIMARY KEY,\n    tag TEXT[]\n);\n\nINSERT INTO preference_tag (userid, tag) VALUES\n(1, ARRAY['friend', 'apple', 'cat']),\n(2, ARRAY['cat', 'friend', 'dog']),\n(3, ARRAY['pasta', 'best-friend', 'lizard']),\n(4, ARRAY['wildcat', 'potato', 'alices-friend']);\n\n"], "clean_up_sql": ["DROP TABLE preference_tag;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT DISTINCT o1.user_id, o1.email FROM orders o1 WHERE (o1.segment = 'luxury' AND o1.destination = 'New York') OR (o1.segment = 'luxury' AND o1.destination = 'London') OR (o1.segment = 'basic' AND o1.destination = 'New York' AND o1.user_id IN (SELECT o2.user_id FROM orders o2 WHERE o2.segment = 'basic' AND o2.destination = 'New York' GROUP BY o2.user_id HAVING SUM(o2.revenue) > 2000)) EXCEPT SELECT DISTINCT o3.user_id, o3.email FROM orders o3 WHERE o3.destination = 'Miami'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_43", "db_id": "financial", "query": "In the financial database, there is a table named 'account_info' that stores the detailed information of accounts. Each row in the table includes an array in the 'condition' column, which contains various conditions related to the account. We need to find all qualifying accounts where the 'condition' column contains a condition with a specific 'rootcompanyid' value of 5. The current query is only returning the last row that matches the condition, but we need all rows that have this 'rootcompanyid' value in any part of the array.", "issue_sql": ["SELECT *  FROM account_info WHERE ((condition->0->>'conditions')::json->>'rootcompanyid')::json->>'$in' = '[5]';"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS account_info (account_id INTEGER, condition JSONB, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, status VARCHAR(50) DEFAULT 'active', version_number INTEGER DEFAULT 1, is_verified BOOLEAN DEFAULT false, metadata JSONB DEFAULT '{}'::jsonb, access_level VARCHAR(20) DEFAULT 'standard', last_accessed_at TIMESTAMP WITH TIME ZONE, access_count INTEGER DEFAULT 0, notes TEXT DEFAULT '', risk_score NUMERIC(5,2) DEFAULT 0.00, account_uuid UUID DEFAULT gen_random_uuid(), tags TEXT[] DEFAULT '{}'::TEXT[], expiration_date DATE);", "INSERT INTO account_info (account_id, condition, created_at, updated_at, status, version_number, is_verified, metadata, access_level, last_accessed_at, access_count, notes, risk_score, account_uuid, tags, expiration_date) VALUES (1, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[35,20,5,6]}}}]'::jsonb, '2023-01-15T08:30:00Z', '2023-01-15T08:30:00Z', 'active', 1, true, '{\"source\": \"api\", \"origin\": \"web\"}'::jsonb, 'admin', '2023-02-10T14:22:15Z', 42, 'Corporate account with multiple company access', 3.75, 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', '{corporate,verified,premium}', '2024-12-31'), (2, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[1,4,2,3,6]}}}]'::jsonb, '2023-01-20T10:45:00Z', '2023-02-05T16:20:00Z', 'active', 3, true, '{\"source\": \"manual\", \"origin\": \"branch\"}'::jsonb, 'manager', '2023-03-01T09:15:30Z', 27, 'Business account with regional access', 2.50, 'b2c3d4e5-f6a7-8901-bcde-f23456789012', '{business,regional}', '2025-06-30'), (3, '[{\"action\":\"read\",\"subject\":\"rootcompany\",\"conditions\":{\"rootcompanyid\":{\"$in\":[5]}}}]'::jsonb, '2023-02-01T14:20:00Z', '2023-02-01T14:20:00Z', 'pending', 1, false, '{\"source\": \"import\", \"origin\": \"migration\"}'::jsonb, 'basic', '2023-02-01T14:20:00Z', 3, 'Limited access account for single company', 4.25, 'c3d4e5f6-a7b8-9012-cdef-3456789012ab', '{limited,new}', '2023-12-15');"], "clean_up_sql": ["DROP TABLE IF EXISTS account_info;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT version FROM cars ORDER BY CAST(SUBSTRING(version FROM '^[0-9]+') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.([0-9]+)') AS INTEGER) DESC, CAST(SUBSTRING(version FROM '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, CASE WHEN version LIKE '%-%' THEN SUBSTRING(version FROM '-(.*)') ELSE '' END DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_44", "db_id": "superhero", "query": "I am working on a superhero database and have a table called 'hero_power' that records the powers of each superhero. Currently, the combination of 'hero_id' and 'power_id' is supposed to be unique, meaning that a superhero cannot have the same power listed more than once. However, this is not quite what I want. Instead, I would want the combination 'hero_id' and 'power_id' to be unique only in cases where the power is currently active. In other words, a superhero should be able to have multiple instances of the same power listed if the power is inactive, but should not be allowed to have duplicates that are active. Is there a way to enforce this in this table?", "issue_sql": ["ALTER TABLE hero_power ADD CONSTRAINT unique_active_hero_power UNIQUE (hero_id, power_id);"], "preprocess_sql": ["ALTER TABLE hero_power ADD COLUMN active BOOLEAN DEFAULT TRUE;"], "clean_up_sql": ["ALTER TABLE hero_power DROP COLUMN IF EXISTS active;", "DROP INDEX IF EXISTS idx_hero_power_active;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT d.driverId, COALESCE(SUM(r.points), 0) AS total_points FROM drivers d LEFT JOIN results r ON d.driverId = r.driverId GROUP BY d.driverId"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_45", "db_id": "toxicology", "query": "In the toxicology database, we have a table named `orders` that records the purchases made by users. Each record includes the `user_id`, `email`, `segment` (type of purchase), `destination` (location of purchase), and `revenue` (amount spent). We need to identify users who meet specific criteria based on their purchase history:\\n1) Users who have made a purchase in the `luxury` segment with a `destination` of `New York`.\\n2) Users who have made a purchase in the `luxury` segment with a `destination` of `London`.\\n3) Users who have made purchases in the `basic` segment with a `destination` of `New York` and the total revenue from these purchases exceeds $2,000.\\n4) Users who have never made a purchase with a `destination` of `Miami`.\\nGiven the sample data, we expect to retrieve the following users:\\nuser_id     email \\\\(3           mike@me.com \\\\(4           sally@you.com \\\\(5           bob@gmail.com \\\\)The user attempted to use the following SQL query to get part of the required results, but it did not account for conditions 3 and 4:\\nsql \\\\(SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London') \\\\)", "issue_sql": ["SELECT DISTINCT(user_id), email FROM orders o WHERE (o.segment = 'luxury' AND o.destination = 'New York') OR (o.segment = 'luxury' AND o.destination = 'London')"], "preprocess_sql": ["CREATE TABLE orders (user_id INT, email TEXT, segment TEXT, destination TEXT, revenue NUMERIC); INSERT INTO orders (user_id, email, segment, destination, revenue) VALUES (1, 'joe@smith.com', 'basic', 'New York', 500), (1, 'joe@smith.com', 'luxury', 'London', 750), (1, 'joe@smith.com', 'luxury', 'London', 500), (1, 'joe@smith.com', 'basic', 'New York', 625), (1, 'joe@smith.com', 'basic', 'Miami', 925), (1, 'joe@smith.com', 'basic', 'Los Angeles', 218), (1, 'joe@smith.com', 'basic', 'Sydney', 200), (2, 'mary@jones.com', 'basic', 'Chicago', 375), (2, 'mary@jones.com', 'luxury', 'New York', 1500), (2, 'mary@jones.com', 'basic', 'Toronto', 2800), (2, 'mary@jones.com', 'basic', 'Miami', 750), (2, 'mary@jones.com', 'basic', 'New York', 500), (2, 'mary@jones.com', 'basic', 'New York', 625), (3, 'mike@me.com', 'luxury', 'New York', 650), (3, 'mike@me.com', 'basic', 'New York', 875), (4, 'sally@you.com', 'luxury', 'Chicago', 1300), (4, 'sally@you.com', 'basic', 'New York', 1200), (4, 'sally@you.com', 'basic', 'New York', 1000), (4, 'sally@you.com', 'luxury', 'Sydney', 725), (5, 'bob@gmail.com', 'basic', 'London', 500), (5, 'bob@gmail.com', 'luxury', 'London', 750);"], "clean_up_sql": ["DROP TABLE orders;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT\n    sqA.alignment_count     AS total_by_alignment,\n    A.alignment             AS alignment,\n    R.race                  AS race,\n    sqAR.alignment_race_count AS count_by_alignment_race\nFROM\n    (\n       SELECT\n           alignment_id,\n           COUNT(*) AS alignment_count\n       FROM superhero\n       GROUP BY alignment_id\n    ) sqA\n\n    INNER JOIN\n    (\n       SELECT\n           alignment_id,\n           race_id,\n           COUNT(*) AS alignment_race_count\n       FROM superhero\n       GROUP BY alignment_id, race_id\n    ) sqAR ON sqA.alignment_id = sqAR.alignment_id\n\n    INNER JOIN alignment A ON sqA.alignment_id = A.id\n\n    INNER JOIN race R ON sqAR.race_id = R.id\nORDER BY\n    A.alignment,\n    R.race;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_46", "db_id": "formula_1", "query": "In the Formula 1 database, there is a table named 'cars' which contains the information of cars. Each entry includes a 'version' column that records the version of the car used by the driver in the race. The version numbers are in a format similar to '3.0.5-1-test-dev' and need to be sorted correctly to determine the latest version used in a race. However, the current sorting method does not handle multi-digit numbers correctly and fails when the version includes additional string information after the numeric version. The task is to write a query that correctly sorts the versions. If the table is sorted, I can get the latest version by select the first one.", "issue_sql": ["SELECT version FROM cars ORDER BY SUBSTRING(version, '^[0-9]+') DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.([0-9]+)-') DESC, CAST(SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-([0-9]+)') AS INTEGER) DESC, SUBSTRING(version, '[0-9]+\\.[0-9]+\\.[0-9]+-[0-9]+\\.([0-9]+)') DESC"], "preprocess_sql": ["CREATE TABLE cars (version varchar(100))", "INSERT INTO cars (version) VALUES ('3.0.5-1-test-dev'), ('3.0.6-1'), ('3.0.7-1-test'), ('3.0.8-1-test-dev-test23'), ('3.0.9-1'), ('3.0.13-2'), ('3.0.4-1-1'), ('3.0.10-1'), ('3.0.11-2'), ('3.0.11-1')"], "clean_up_sql": ["DROP TABLE cars;"], "category": "Personalization", "efficiency": false, "sol_sql": ["select driverId, points, array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred = execute_queries(pred_sqls,db_name,conn)\n    sol = execute_queries(sol_sqls,db_name,conn)\n    assert pred == sol\n    return pred == sol"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_47", "db_id": "thrombosis_prediction", "query": "In the thrombosis_prediction database, we have a set of normalized tables representing patients, medications, and their prescriptions. Each patient can be prescribed multiple medications, and each medication can be prescribed to multiple patients. For reporting purposes, we need a highly denormalized view that shows each patient's name and a list of all medications they are prescribed. However, when we filter the list to show only patients who are prescribed a specific medication (e.g., Aspirin), we lose the information about other medications those patients are prescribed. We want to filter by a specific medication but still get a list of all medications that a patient is prescribed in one row.", "issue_sql": ["WITH aspirin_patients AS ( SELECT DISTINCT patient_id FROM prescriptions WHERE medication_id = 1 ) SELECT p.patient_id, array_agg(DISTINCT p.medication_id ORDER BY p.medication_id) AS medications FROM prescriptions p JOIN aspirin_patients ap ON p.patient_id = ap.patient_id GROUP BY p.patient_id;"], "preprocess_sql": ["CREATE TABLE patients ( patient_id SERIAL PRIMARY KEY, patient_name TEXT NOT NULL );", "CREATE TABLE medications ( medication_id SERIAL PRIMARY KEY, medication_name TEXT NOT NULL );", "CREATE TABLE prescriptions ( patient_id INT REFERENCES patients (patient_id), medication_id INT REFERENCES medications (medication_id), PRIMARY KEY (patient_id, medication_id) );", "INSERT INTO patients (patient_name) VALUES ('Alice'), ('Bob'), ('Charlie');", "INSERT INTO medications (medication_name) VALUES ('Aspirin'), ('Ibuprofen'), ('Paracetamol'), ('Warfarin');", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (1, 1), (1, 2), (1, 3);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (2, 2);", "INSERT INTO prescriptions (patient_id, medication_id) VALUES (3, 2), (3, 1), (3, 3), (3, 4);"], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH cte AS (\n    SELECT\n        p.*,\n        CEIL( (ROW_NUMBER() OVER (\n                 PARTITION BY raceId\n                 ORDER BY time::time\n               ) + 1 ) / 2.0\n        ) AS rn\n    FROM pitStops p\n    WHERE raceId = 842\n),\ncte2 AS (\n    SELECT\n        rn,\n        MIN(time::time) AS starttime,\n        MAX(time::time) AS endtime,\n        CAST(MAX(time::time) - MIN(time::time) AS time) AS total_pause\n    FROM cte\n    GROUP BY rn\n)\nSELECT\n    MAX(endtime) AS endtime,\n    MIN(starttime) AS starttime,\n    CAST(SUM(total_pause) AS time) AS total_pit_stop_duration\nFROM cte2;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_48", "db_id": "formula_1", "query": "In the context of Formula 1 racing data, I have two tables: `races` and `results`. The `races` table contains information about each race, including the `raceId` which uniquely identifies each race. The `results` table contains detailed information about the results of each race, including the `raceId` to link back to the `races` table, `driverId` to identify the driver, and `points` which represent the points scored by the driver in that race. I need to calculate the total points scored by each driver across all races, but only for races where the driver has participated. If a driver has not participated in any races, their total points should be `0`. I attempted to write a query to achieve this but encountered issues with grouping and ensuring that drivers who haven't participated in any races are included with a total of `0` points.", "issue_sql": ["SELECT r.driverId, ((SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId) - (SELECT COALESCE(SUM(r.points), 0) FROM results r WHERE r.raceId = races.raceId)) AS total_points FROM results r GROUP BY r.driverId"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT json_object_agg(label, groupedMolecules) AS molecules_by_label\nFROM (\n  SELECT label,\n         json_agg(\n           json_build_object(\n             'molecule_id', molecule.molecule_id,\n             'atoms', (\n               SELECT json_agg(\n                 json_build_object(\n                   'atom_id', atom.atom_id,\n                   'element', atom.element\n                 )\n               )\n               FROM atom\n               WHERE atom.molecule_id = molecule.molecule_id\n             ),\n             'bonds', (\n               SELECT json_agg(\n                 json_build_object(\n                   'bond_id', bond.bond_id,\n                   'bond_type', bond.bond_type\n                 )\n               )\n               FROM bond\n               WHERE bond.molecule_id = molecule.molecule_id\n             )\n           )\n         ) AS groupedMolecules\n  FROM molecule\n  GROUP BY label\n) AS sub;"], "test_cases": ["import json\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    def json_matches_gold(generated_json, gold_json):\n                                                        \n        if isinstance(generated_json, str):\n            generated_json = json.loads(generated_json)\n        if isinstance(gold_json, str):\n            gold_json = json.loads(gold_json)\n\n                                                            \n        return generated_json == gold_json\n    \n    sol = execute_queries(sol_sqls,db_name,conn)\n    pred = execute_queries(pred_sqls,db_name,conn)\n    assert json_matches_gold(sol[0], pred[0])\n    return json_matches_gold(sol[0], pred[0])"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_49", "db_id": "superhero", "query": "In the context of the superhero database, I need to calculate the total count of superheroes by their alignment and also display the count of superheroes for each specific alignment and race combination. I attempted to write a query to achieve this but it doesn't provide the total count by alignment as I expected. Here's what I tried:", "issue_sql": ["select count(S.id), A.alignment, count(R.race), R.race from superhero S, alignment A, race R where S.alignment_id=A.id and S.race_id=R.id group by A.alignment, R.race;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT\n    molecule_id,\n    COUNT(DISTINCT CASE WHEN element = 'na' THEN 1 END)         AS na_atoms,\n    COUNT(DISTINCT CASE WHEN element IN ('c', 'cl') THEN molecule_id END) AS c_atoms\nFROM atom\nGROUP BY molecule_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_50", "db_id": "formula_1", "query": "In the context of analyzing Formula 1 race results, I'm trying to understand the behavior of window functions in PostgreSQL. Specifically, I'm looking at the `array_agg` function with and without an `ORDER BY` clause within a window function. I expect both to return the same result since no filtering is applied, but they don't. Here's the scenario: I have a table of race results, and I want to aggregate the driver IDs in two ways: one with an order by the points they scored in the race, and another without any order. The results seem to suggest that ordering the partition affects the aggregation, which is confusing. Here's the SQL I used:", "issue_sql": ["select driverId, points, lead(driverId) over (order by points asc) as \"lead(driverId) with order\", array_agg(driverId) over (order by points asc) as \"array_agg(driverId) with order\", lead(driverId) over () as \"lead(driverId) without order\", array_agg(driverId) over () as \"array_agg(driverId) without order\" from results where raceId = 19 order by driverId asc"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT date_trunc('hour', \"date\"::timestamp), home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY date_trunc('hour', \"date\"::timestamp), home_team_api_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_51", "db_id": "formula_1", "query": "In the context of Formula 1 racing data analysis, a user is attempting to calculate the total duration of pit stops for each race day based on the difference between consecutive pit stop times recorded in the same column. The user has a table that records pit stop details including race ID, driver ID, stop number, lap number, pit stop time, and duration. The user's initial approach was to calculate the maximum and minimum pit stop times for each race day and then find the difference between these times to estimate the total pit stop duration. However, this approach misses the intermediate pit stops, leading to an inaccurate total duration calculation. The user is seeking a method to accurately calculate the total pit stop duration by considering all consecutive pit stop times for each race day.", "issue_sql": ["SELECT\n  raceId,\n  MAX(time::time) AS end_time,\n  MIN(time::time) AS start_time,\n  (MAX(time::time) - MIN(time::time)) AS total_duration\nFROM pitStops\nWHERE raceId = 842\nGROUP BY raceId;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT MIN(transaction_date) AS date, club_name, SUM(amount) AS amount FROM (SELECT *, SUM(flag) OVER (PARTITION BY club_name ORDER BY transaction_date) AS grp FROM (SELECT *, COALESCE(SIGN(amount) <> LAG(SIGN(amount)) OVER (PARTITION BY club_name ORDER BY transaction_date), true)::int AS flag FROM club_transactions) t) t GROUP BY club_name, grp ORDER BY club_name, date;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_52", "db_id": "toxicology", "query": "In the toxicology database, I'm attempting to retrieve a specific data structure from a query. My data is structured in a way that each molecule has atoms connected by bonds, and each molecule is labeled as either carcinogenic (+) or not carcinogenic (-). I want to return a  object that groups molecules by their label and lists the atoms and bonds for each molecule. The desired output format is a  object where each key is a label, and the value is an array of objects, each representing a molecule with its atoms and bonds. Here's the SQL query I have so far, but it doesn't produce the desired output structure:", "issue_sql": ["select label, JSON_AGG(JSON_BUILD_OBJECT(atom.molecule_id, atom.atom_id)) AS groupedMolecules FROM molecule JOIN atom ON molecule.molecule_id = atom.molecule_id GROUP BY label"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH RECURSIVE cte(id, p, js) AS (SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m1.id_module, 'id_parent_module', m1.id_parent_module, 'module_code', m1.module_code, 'name_module', m1.name_module, 'desc_module', m1.desc_module) jsn FROM modules m JOIN modules m1 ON m1.id_parent_module = m.id_module WHERE NOT EXISTS (SELECT 1 FROM modules m2 WHERE m2.id_parent_module = m1.id_module)) t GROUP BY t.id_module, t.id_parent_module UNION ALL SELECT t.id_module, t.id_parent_module, json_agg(t.jsn) FROM (SELECT m.id_module, m.id_parent_module, json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js) jsn FROM modules m JOIN cte c ON m.id_module = c.p JOIN modules m2 ON m2.id_module = c.id) t GROUP BY t.id_module, t.id_parent_module) SELECT jsonb_pretty(t.result::jsonb) FROM (SELECT json_agg(json_build_object('id_module', m2.id_module, 'id_parent_module', m2.id_parent_module, 'module_code', m2.module_code, 'name_module', m2.name_module, 'desc_module', m2.desc_module, 'children', c.js)) result FROM cte c JOIN modules m2 ON c.id = m2.id_module WHERE c.p IS NULL) t"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)\n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_53", "db_id": "toxicology", "query": "In the context of a toxicology database, I have a `molecule` table that tracks molecules and their carcinogenic status, and an `atom` table that records atoms within these molecules. Each atom is identified by a unique `atom_id` and belongs to a molecule identified by `molecule_id`. The `element` column in the `atom` table specifies the chemical element of the atom. I need to count the number of sodium (`na`) and carbon (`c`) or chlorine (`cl`) atoms for each molecule. However, if both carbon (`c`) and chlorine (`cl`) elements within the same molecule, they should be counted as one. Here's the SQL query I attempted, but it counts each atom individually, even if they are of the same element within the same molecule:", "issue_sql": ["SELECT molecule_id, COALESCE(SUM(CASE WHEN element = 'na' THEN 1 ELSE 0 END), 0) na_atoms, COALESCE(SUM(CASE WHEN element = 'c' OR element = 'cl' THEN 1 ELSE 0 END), 0) c_atoms FROM atom GROUP BY molecule_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["INSERT INTO customers (customerid, segment, currency)\nSELECT DISTINCT ON (customerid, segment, currency)\n       customerid,\n       segment,\n       currency\nFROM (\n    VALUES\n       (3, 'SME', 'EUR'),\n       (1, 'KAM', 'CZK'),\n       (3, 'SME', 'EUR')\n) AS v(customerid, segment, currency)\nON CONFLICT (customerid, segment, currency)\nDO UPDATE\n   SET currency = customers.currency\nRETURNING CustomerID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name,conn)[0] \n    assert test_pred_query_result_1 == [(1,), (3,)]"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_54", "db_id": "european_football_2", "query": "In the context of analyzing football match data, I'm attempting to calculate the average number of goals scored by each team, grouped by the hour of the match. The goal is to understand the performance trends of teams at different times of the day without resorting to external scripting. Here's the initial approach I took, which unfortunately resulted in an error due to incorrect handling of the timestamp data.", "issue_sql": ["SELECT home_team_api_id, AVG(home_team_goal) as avg_home_goals, AVG(away_team_goal) as avg_away_goals, SUM(home_team_goal) as total_home_goals, SUM(away_team_goal) as total_away_goals, MAX(home_team_goal) as max_home_goals, MIN(home_team_goal) as min_home_goals, COUNT(home_team_api_id) as count FROM Match GROUP BY home_team_api_id, date_part('hour', date);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["UPDATE disp\nSET addresses = '[{\"PostCode\": null}]'\nWHERE jsonb_typeof(addresses) <> 'array'\n   OR addresses = '[]';\n\nSELECT\n    c.client_id,\n    c.gender,\n    d.disp_id,\n    addr ->> 'PostCode' AS PostCode\nFROM client c\nFULL JOIN disp d ON c.client_id = d.client_id,\njsonb_array_elements(d.addresses) AS addr\nWHERE c.client_id = 100;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_55", "db_id": "debit_card_specializing", "query": "In the table clients_to_groups, we need to identify clients who have made transactions at gas stations that belong to specific groups. Specifically, we want to find clients who have made transactions at gas stations that are either in the group 1 or 3 AND also in group 5 or 6. For example, a client who has made transactions at a gas station in the group 5 and another transaction at a gas station in the group 1 should be included in the results, but a client who has only made transactions at gas stations in the group 5 should not be included.", "issue_sql": ["SELECT DISTINCT c.id FROM clients c INNER JOIN clients_to_groups at1 ON c.id = at1.client_id INNER JOIN clients_to_groups at2 ON c.id = at2.client_id WHERE at1.group_id IN (5, 6) AND at2.group_id IN (1, 3);"], "preprocess_sql": ["CREATE TABLE clients (id INT NOT NULL);", "CREATE TABLE groups (id INT NOT NULL);", "CREATE TABLE clients_to_groups (id serial, group_id INT, client_id INT);", "INSERT INTO clients(id) VALUES (0), (1), (2), (3);", "INSERT INTO groups(id) VALUES (1), (3), (5), (6);", "INSERT INTO clients_to_groups(client_id, group_id) VALUES (0, 1), (0, 5), (1, 1), (1, 90), (2, 1), (3, 3), (3, 5), (3, 90);", "INSERT INTO clients (id) SELECT random() from generate_series(1,2000);", "INSERT INTO clients_to_groups(client_id, group_id) SELECT random(), random() from generate_series(1,2000);"], "clean_up_sql": ["DROP TABLE clients;", "DROP TABLE groups;", "DROP TABLE clients_to_groups;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["INSERT INTO loan (\n  account_id,\n  date,\n  amount,\n  duration,\n  payments,\n  status\n)\nVALUES (\n  2,\n  '1996-04-29',\n  30276,\n  12,\n  2523.0,\n  'B'\n)\nON CONFLICT (account_id, date)\nDO UPDATE\n   SET amount = EXCLUDED.amount + 1000;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n       \n                                                                                \n                                                                          \n                                                                                   \n                                                       \n    \n                                                                                    \n                                                                                  \n                                                                                         \n                                                                                            \n                                                                                  \n       \n\n                                                    \n    drop_sql = [\"DROP TABLE IF EXISTS loan CASCADE;\"]\n    execute_queries(drop_sql, db_name, conn)\n\n                                                                                   \n    create_sql = [\"\"\"\n        CREATE TABLE loan (\n            loan_id   SERIAL PRIMARY KEY,\n            account_id INT NOT NULL,\n            date       DATE NOT NULL,\n            amount     INT NOT NULL,\n            duration   INT NOT NULL,\n            payments   DOUBLE PRECISION NOT NULL,\n            status     TEXT NOT NULL,\n            UNIQUE(account_id, date)\n        );\n    \"\"\"]\n    execute_queries(create_sql, db_name, conn)\n\n                                                                \n                                                                                        \n    init_insert_sql = [\"\"\"\n        INSERT INTO loan (account_id, date, amount, duration, payments, status)\n        VALUES (2, '1996-04-29', 30276, 12, 2500.0, 'X');\n    \"\"\"]\n    execute_queries(init_insert_sql, db_name, conn)\n\n                                                        \n    execute_queries(pred_sqls, db_name, conn)\n\n                                                                           \n    check_sql = [\"SELECT loan_id, account_id, date, amount FROM loan WHERE account_id=2 AND date='1996-04-29';\"]\n    rows = execute_queries(check_sql, db_name, conn)[0]\n\n                            \n    assert len(rows) == 1, (\n        f\"Expected only 1 row for (account_id=2, date='1996-04-29'), but found {len(rows)}. \"\n        \"This likely means the upsert inserted a new row instead of updating.\"\n    )\n\n    loan_id_val, acct_val, date_val, amount_val = rows[0]\n\n                                                                  \n    expected_amount = 30276 + 1000\n    assert amount_val == expected_amount, (\n        f\"Expected amount={expected_amount} after update, but got {amount_val}. \"\n        \"This likely means the existing row was not updated correctly (or the conflict logic is wrong).\"\n    )"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_56", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, consider a table that records daily financial transactions for football clubs. Each transaction includes the date, the club name, and the amount of money involved, which can be positive (income) or negative (expense). The goal is to group these transactions by club and sign (positive or negative) and sum the amounts for consecutive transactions of the same sign for each club. For example, if a club has consecutive positive transactions, they should be summed up into a single transaction. The user attempted to use window functions but encountered issues with their query, which did not produce the desired output.", "issue_sql": ["SELECT transaction_date AS date, club_name, sum(amount) over (partition by club_name, sign(amount) order by transaction_date) from club_transactions"], "preprocess_sql": ["CREATE TABLE club_transactions (transaction_date DATE, club_name VARCHAR(50), amount INTEGER, transaction_id UUID DEFAULT gen_random_uuid(), transaction_type VARCHAR(100) DEFAULT 'standard', description TEXT DEFAULT 'Regular club transaction', created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_verified BOOLEAN DEFAULT false, verification_date TIMESTAMP WITH TIME ZONE, metadata JSONB DEFAULT '{}'::jsonb, currency VARCHAR(3) DEFAULT 'GBP', exchange_rate NUMERIC(10, 4) DEFAULT 1.0000, fiscal_year INTEGER DEFAULT EXTRACT(YEAR FROM CURRENT_DATE), quarter INTEGER DEFAULT EXTRACT(QUARTER FROM CURRENT_DATE), department VARCHAR(100) DEFAULT 'Finance', approved_by VARCHAR(100), status VARCHAR(20) DEFAULT 'pending', tags TEXT[] DEFAULT ARRAY[]::TEXT[], priority INTEGER DEFAULT 3);", "INSERT INTO club_transactions (transaction_date, club_name, amount, transaction_type, description, is_verified, currency, exchange_rate, fiscal_year, department, approved_by, status, tags, priority) VALUES ('2023-01-01', 'Manchester United', 3, 'income', 'Merchandise sales', true, 'GBP', 1.0000, 2023, 'Commercial', 'John Smith', 'completed', ARRAY['merchandise', 'retail'], 1), ('2023-01-02', 'Manchester United', 2, 'income', 'Ticket sales', true, 'GBP', 1.0000, 2023, 'Ticketing', 'Sarah Johnson', 'completed', ARRAY['tickets', 'matchday'], 2), ('2023-01-03', 'Manchester United', 1, 'income', 'Concession revenue', true, 'GBP', 1.0000, 2023, 'Hospitality', 'David Brown', 'completed', ARRAY['food', 'beverage'], 2), ('2023-01-04', 'Manchester United', -5, 'expense', 'Player wages', true, 'GBP', 1.0000, 2023, 'HR', 'Emma Wilson', 'completed', ARRAY['salary', 'personnel'], 1), ('2023-01-05', 'Manchester United', 1, 'income', 'Sponsorship payment', true, 'GBP', 1.0000, 2023, 'Partnerships', 'Michael Davis', 'completed', ARRAY['sponsorship', 'commercial'], 1), ('2023-01-01', 'Liverpool', 2, 'income', 'TV rights payment', true, 'GBP', 1.0000, 2023, 'Media', 'Robert Taylor', 'completed', ARRAY['broadcast', 'media'], 1), ('2023-01-02', 'Liverpool', -1, 'expense', 'Training equipment', true, 'GBP', 1.0000, 2023, 'Operations', 'Jennifer White', 'completed', ARRAY['equipment', 'training'], 3), ('2023-01-03', 'Liverpool', -6, 'expense', 'Stadium maintenance', true, 'GBP', 1.0000, 2023, 'Facilities', 'Thomas Martin', 'completed', ARRAY['maintenance', 'facilities'], 2);"], "clean_up_sql": ["DROP TABLE club_transactions;"], "category": "Query", "efficiency": false, "sol_sql": ["DELETE FROM cards WHERE ctid IN ( SELECT ctid FROM cards c WHERE NOT EXISTS ( SELECT 1 FROM ( SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL ) n WHERE n.uuid = c.uuid AND n.setCode = c.setCode AND n.rarity = c.rarity AND n.manaCost = c.manaCost ) LIMIT 1000 );"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases('SELECT COUNT(*) FROM (SELECT ctid FROM cards c WHERE NOT EXISTS (SELECT 1 FROM (SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL UNION ALL SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL) n WHERE n.uuid = c.uuid AND n.setCode = c.setCode AND n.rarity = c.rarity AND n.manaCost = c.manaCost) LIMIT 1000) subq;', db_name)[0]\n    assert test_pred_query_result_2[0][0] == 1000, f'Expected count to be 0, but found {test_pred_query_result_2[0][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_57", "db_id": "california_schools", "query": "I have a table in Postgres that returns flat data. But I would like it to be returned to me in a Json ordered with its children as follows, and I have not been able to solve it.Is there a way in postgresql to order the parent modules with their child modules, I attach an example \"[{\"children\":[{\"id_module\":4,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":1},{\"id_module\":3,\"desc_module\":\"C\",\"module_code\":\"232\",\"name_module\":\"C\",\"id_parent_module\":1},{\"id_module\":2,\"desc_module\":\"B\",\"module_code\":\"011.002\",\"name_module\":\"B\",\"id_parent_module\":1}],\"id_module\":1,\"desc_module\":\"A\",\"module_code\":\"001\",\"name_module\":\"A\",\"id_parent_module\":null},{\"children\":[{\"id_module\":14,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":5}],\"id_module\":5,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":22,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":8,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6},{\"id_module\":7,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":6}],\"id_module\":6,\"desc_module\":\"qw\",\"module_code\":\"23\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":21,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9},{\"id_module\":20,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":9}],\"id_module\":9,\"desc_module\":\"asdfsad\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null},{\"children\":[{\"id_module\":13,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":12,\"desc_module\":\"asdfsf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":10},{\"id_module\":11,\"desc_module\":\"asdf\",\"module_code\":\"sadf\",\"name_module\":\"asdf\",\"id_parent_module\":10}],\"id_module\":10,\"desc_module\":\"asdf\",\"module_code\":\"asdf\",\"name_module\":\"asdf\",\"id_parent_module\":null}]\"", "issue_sql": ["SELECT array_to_json(array_agg(row_to_json(alias))) FROM (select * from modules ) alias"], "preprocess_sql": ["create table modules (id_module int, id_parent_module int, module_code text, name_module text, desc_module text);", "insert into modules values (1, null, '001', 'A', 'A'), (2, 1, '011.002', 'B', 'B'), (3, 1, '232', 'C', 'C'), (4, 1, 'asdf', 'asdf', 'asdf'), (5, null, 'asdf', 'asdf', 'asdf'), (14, 5, 'asdf', 'asdf', 'asdf'), (6, null, '23', 'asdf', 'qw'), (7, 6, 'asdf', 'asdf', 'asdf'), (8, 6, 'asdf', 'asdf', 'asdf'), (22, 6, 'asdf', 'asdf', 'asdf'), (9, null, 'asdf', 'asdf', 'asdfsad'), (20, 9, 'asdf', 'asdf', 'asdf'), (21, 9, 'asdf', 'asdf', 'asdf'), (10, null, 'asdf', 'asdf', 'asdf'), (11, 10, 'sadf', 'asdf', 'asdf'), (12, 10, 'asdf', 'asdf', 'asdfsf'), (13, 10, 'asdf', 'asdf', 'asdf');"], "clean_up_sql": ["DROP TABLE modules;"], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(\n    _tbl regclass,\n    _id text,\n    _row_num text,\n    OUT nullable_columns int,\n    OUT updated_rows int\n) LANGUAGE plpgsql AS $func$\nDECLARE\n    _pk text := quote_ident(_row_num);\n    _sql text;\nBEGIN\n    SELECT INTO _sql, nullable_columns concat_ws(E'\n',\n        'UPDATE ' || _tbl || ' t',\n        'SET (' || string_agg(quote_ident(a.attname), ', ') || ') = ',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')',\n        'FROM (',\n        '   SELECT ' || _pk,\n        '        , ' || string_agg(\n                     format(\n                         'COALESCE(%1$I, MAX(%1$I) OVER (PARTITION BY %2$s ORDER BY %3$s ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)) AS %1$I',\n                         a.attname, _id, _pk\n                     ),\n                     ', '\n                 ),\n        '   FROM ' || _tbl,\n        '   ) u',\n        format('WHERE t.%1$s = u.%1$s', _pk),\n        'AND (' || string_agg('t.' || quote_ident(a.attname), ', ') || ') IS DISTINCT FROM',\n        '    (' || string_agg('u.' || quote_ident(a.attname), ', ') || ')'\n    ),\n    count(*)\n    FROM (\n        SELECT a.attname\n        FROM pg_attribute a\n        WHERE a.attrelid = _tbl\n          AND a.attnum > 0\n          AND NOT a.attisdropped\n          AND NOT a.attnotnull\n        ORDER BY a.attnum\n    ) a;\n\n    RAISE NOTICE 'Generated SQL: %', _sql;\n\n    IF nullable_columns = 0 THEN\n        RAISE EXCEPTION 'No nullable columns found in table >>%<<', _tbl;\n    ELSIF _sql IS NULL THEN\n        RAISE EXCEPTION 'Generated SQL is NULL. Check table or column logic!';\n    END IF;\n\n    EXECUTE _sql;\n\n    GET DIAGNOSTICS updated_rows = ROW_COUNT;\nEND $func$;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    def execute_sqls(sql_list):\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                try:\n                    cur.execute(sql)\n                    conn.commit()\n                except Exception as e:\n                    conn.rollback()\n                    return str(e)\n        return \"success\"\n\n    def validate_forward_fill(limit=10):\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SELECT t1.trans_id, t1.account_id, t1.amount AS current_amount, t2.amount AS previous_amount\n                FROM trans t1\n                LEFT JOIN trans t2\n                  ON t1.account_id = t2.account_id\n                 AND t1.date > t2.date\n                WHERE t1.amount IS NULL AND t2.amount IS NOT NULL\n                ORDER BY t1.date\n                LIMIT %s;\n            \"\"\", (limit,))\n            rows = cur.fetchall()\n            if rows:\n                return False\n            return True\n\n    def debug_generated_sql():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                SET client_min_messages TO NOTICE;\n                DO $$\n                BEGIN\n                    PERFORM f_gap_fill_update('trans', 'account_id', 'trans_id');\n                END $$;\n            \"\"\")\n            cur.execute(\"RESET client_min_messages;\") \n\n    def reset_trans_table():\n        with conn.cursor() as cur:\n            cur.execute(\"\"\"\n                UPDATE trans\n                SET amount = CASE\n                    WHEN trans_id = 1 THEN 1000\n                    WHEN trans_id IN (5, 6, 7, 8, 9, 10, 11, 12) THEN NULL\n                    ELSE amount\n                END;\n            \"\"\")\n            conn.commit()\n\n    reset_trans_table()\n    pred_result = execute_sqls(pred_sqls)\n    assert pred_result == \"success\"\n\n    debug_generated_sql()\n    assert validate_forward_fill(), \"Validate forward fill function logic.\"\n\n    return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_58", "db_id": "toxicology", "query": "In the toxicology database, we have a table named 'atom_edits' that records updates to the 'atom' table. Users can update the 'element' or 'molecule_id' of an atom. If a field is not updated, it retains a NULL value. Here's an example of four edits touching two separate atoms. Atom with ID 'TR000_1' received two updates: the first one is updating the 'element' field, the second one touches the 'molecule_id'. Atom with ID 'TR000_2' received one update that changes the 'element'. We need to merge this table such that in the resulting table there's one row per atom, giving the cumulative edits.", "issue_sql": ["SELECT atom_id, (ARRAY_REMOVE(ARRAY_AGG(element ORDER BY edit_id DESC), NULL))[1] AS element, (ARRAY_REMOVE(ARRAY_AGG(molecule_id ORDER BY edit_id DESC), NULL))[1] AS molecule_id FROM atom_edits GROUP BY atom_id;"], "preprocess_sql": ["CREATE TABLE atom_edits (edit_id SERIAL PRIMARY KEY, atom_id TEXT, element TEXT, molecule_id TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, modified_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, edit_type VARCHAR(50) DEFAULT 'standard', edit_status VARCHAR(20) DEFAULT 'pending', edit_source VARCHAR(100) DEFAULT 'manual', edit_notes TEXT DEFAULT NULL, edit_version INTEGER DEFAULT 1, is_approved BOOLEAN DEFAULT FALSE, approval_date TIMESTAMP WITH TIME ZONE DEFAULT NULL, approved_by VARCHAR(100) DEFAULT NULL, metadata JSONB DEFAULT '{}'::jsonb, priority INTEGER DEFAULT 5, batch_id UUID DEFAULT gen_random_uuid(), processing_time NUMERIC(10,2) DEFAULT 0.0, is_deleted BOOLEAN DEFAULT FALSE, deletion_date TIMESTAMP WITH TIME ZONE DEFAULT NULL);", "INSERT INTO atom_edits (atom_id, element, molecule_id, created_at, modified_at, edit_type, edit_status, edit_source, edit_notes, edit_version, is_approved, approval_date, approved_by, metadata, priority, batch_id, processing_time, is_deleted, deletion_date) VALUES ('TR000_1', 'cl', NULL, '2023-01-01 10:00:00+00', '2023-01-01 10:00:00+00', 'element_update', 'completed', 'system', 'Initial element update', 1, TRUE, '2023-01-01 10:30:00+00', 'admin', '{\"reason\": \"element correction\", \"previous_value\": null}'::jsonb, 3, 'a1b2c3d4-e5f6-4a5b-8c7d-9e0f1a2b3c4d', 1.25, FALSE, NULL), ('TR000_1', NULL, 'TR001', '2023-01-02 11:15:00+00', '2023-01-02 11:15:00+00', 'molecule_reassignment', 'completed', 'lab_tech', 'Molecule reassignment for structural analysis', 2, TRUE, '2023-01-02 12:00:00+00', 'supervisor', '{\"reason\": \"structural analysis\", \"previous_value\": \"TR000\"}'::jsonb, 2, 'b2c3d4e5-f6a7-5b6c-9d0e-1f2a3b4c5d6e', 2.50, FALSE, NULL), ('TR000_2', 'c', NULL, '2023-01-03 09:30:00+00', '2023-01-03 09:30:00+00', 'element_update', 'completed', 'automated', 'Carbon element verification', 1, TRUE, '2023-01-03 10:15:00+00', 'system', '{\"reason\": \"verification\", \"confidence\": 0.95}'::jsonb, 4, 'c3d4e5f6-a7b8-6c7d-0e1f-2a3b4c5d6e7f', 0.75, FALSE, NULL);"], "clean_up_sql": ["DROP TABLE atom_edits;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["UPDATE card c\nSET disp_id =\n    CASE\n        WHEN c.disp_id = sub.disp_id THEN 1\n        WHEN c.disp_id < sub.disp_id THEN c.disp_id + 1\n        ELSE c.disp_id\n    END\nFROM (\n    SELECT disp_id, type\n    FROM card\n    WHERE disp_id = 41\n) sub\nWHERE c.type = sub.type\n  AND c.disp_id <= sub.disp_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n                                \n    _, pred_exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert pred_exec_err == False, \"Error in executing predicted SQLs\"\n\n                         \n    query = \"SELECT disp_id FROM card WHERE card_id = 1 AND type = 'gold';\"\n    res, _, _ = execute_queries([query], db_name, conn)\n    assert len(res) == 1, \"No matching record found for card_id = 1 and type = 'gold'\"\n    assert res[0][0] == 10, f\"Expected disp_id to be 10, but got {res[0][0]}\"\n\n    return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_59", "db_id": "debit_card_specializing", "query": "We are trying to bulk insert a large number of customer records into the `customers` table using an `INSERT` statement with an `ON CONFLICT` clause. The goal is to get the `CustomerID` back for all rows, whether they are already existing or not. The `customers` table has a composite unique constraint on `Segment` and `Currency`. We are encountering an error when trying to run the SQL through Django's cursor. The error message indicates that the `ON CONFLICT DO UPDATE` command cannot affect a row a second time due to duplicate constrained values in the `VALUES` list. We need to handle this situation to ensure that we can insert new records and retrieve the IDs of both new and existing records.", "issue_sql": ["INSERT INTO customers (customerid, segment, currency) VALUES (3, 'SME', 'EUR'), (1, 'KAM', 'CZK'), (3, 'SME', 'EUR') ON CONFLICT (customerid, segment, currency) DO UPDATE SET Currency = customers.Currency RETURNING CustomerID;"], "preprocess_sql": ["ALTER TABLE customers\nADD CONSTRAINT customers_customerid_segment_currency_uk\nUNIQUE (customerid, segment, currency);"], "clean_up_sql": ["DROP TABLE customers;"], "category": "Management", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\n    RETURNS SETOF date\n    LANGUAGE SQL\n    IMMUTABLE\n    PARALLEL SAFE\n    ROWS 10\n  AS\n  $function$\n    SELECT generate_series(\n      date_trunc('month', a),\n      date_trunc('month', b),\n      '1 month'\n    );\n  $function$;", "EXPLAIN VERBOSE\n  SELECT generate_series_monthly('2024-01-01', '2024-05-01');"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n       \n                                                                                  \n                                                                \n\n                                                             \n                                                                                         \n                                                                        \n                                                                              \n                                                                                        \n       \n    def run_sql_and_get_explain_rows(sql_list):\n           \n                                                                                 \n                                   \n           \n        rows_output = []\n        with conn.cursor() as cur:\n            for sql in sql_list:\n                cur.execute(sql)\n                                                                           \n                if sql.strip().upper().startswith(\"EXPLAIN\"):\n                    rows_output = cur.fetchall()\n        return rows_output\n\n                                                \n    pred_explain_rows = run_sql_and_get_explain_rows(pred_sqls)\n    pred_has_rows10 = any(\"rows=10\" in str(row) for row in pred_explain_rows)\n\n    assert pred_has_rows10, (\n        \"Expected to find 'rows=10' in the tested scenario's EXPLAIN output, but it was not found.\"\n    )\n\n    return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_60", "db_id": "financial", "query": "In the financial database, there are two tables: 'client' and 'disp'. The 'disp' table contains a B column named 'addresses' which stores address information for each client. I attempted to join the 'client' and 'disp' tables on the 'client_id' field and then use b_array_elements to extract address details. However, I encountered an error 'cannot extract elements from a scalar' because some entries in the 'addresses' column are not arrays. I need to handle these cases properly to extract the 'PostCode' from the addresses B column for a specific client with client_id = 100.", "issue_sql": ["SELECT client.client_id, client.gender, disp.disp_id, address ->> 'PostCode' AS PostCode FROM client JOIN disp ON client.client_id = disp.client_id CROSS JOIN jsonb_array_elements(disp.addresses) AS address WHERE disp.client_id IN (100, 414);"], "preprocess_sql": ["ALTER TABLE disp \nADD COLUMN addresses jsonb;", "INSERT INTO disp (disp_id, client_id, account_id, addresses) VALUES\n    (324124, 100, 518, '[{\"PostCode\":\"12345\"}]'),\n    (43244241, 94, 2090, '[null]'),\n    (42342436, 414, 11325, 'null');"], "clean_up_sql": ["\n    DELETE FROM disp \n    WHERE disp_id IN (324124, 43244241, 42342436);\n    ", "\n    ALTER TABLE disp \n    DROP COLUMN addresses;\n    "], "category": "Query", "efficiency": false, "sol_sql": ["WITH cte AS (\n    SELECT\n        m.*,\n        SUM(\n          CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END\n        ) OVER (ORDER BY m.date) AS grp\n    FROM match AS m\n),\naggregates AS (\n    SELECT\n        grp,\n        MAX(date) FILTER (WHERE home_team_goal = away_team_goal) AS draw_date,\n        1 AS invoiced,\n        SUM(home_team_goal + away_team_goal) AS total_goals\n    FROM cte\n    GROUP BY grp\n)\nSELECT\n    grp,\n    draw_date AS date,\n    invoiced,\n    total_goals AS amount\nFROM aggregates\nWHERE draw_date IS NOT NULL\nORDER BY grp;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_61", "db_id": "financial", "query": "In the financial database, I want to update the 'amount' in the 'loan' table for a specific 'account_id' and 'date' if it exists, or insert a new record if it does not. However, I do not want the 'loan_id' to increment if an update occurs because it is an auto-incrementing SERIAL column. The 'loan_id' should only increment when a new record is inserted to maintain a sequential order without gaps.", "issue_sql": ["INSERT INTO loan (\n    loan_id,\n    account_id,\n    date,\n    amount,\n    duration,\n    payments,\n    status\n)\nVALUES (\n    DEFAULT,\n    2,\n    '1996-04-29',\n    30276,\n    12,\n    2523.0,\n    'B'\n)\nON CONFLICT (loan_id, account_id, date)\nDO UPDATE\n    SET amount = loan.amount + 1000;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS loan (loan_id SERIAL PRIMARY KEY, account_id int NOT NULL, date date NOT NULL, amount int NOT NULL, duration int NOT NULL, payments double NOT NULL, status text NOT NULL, UNIQUE(account_id, date)); INSERT INTO loan (loan_id, account_id, date, amount, duration, payments, status) VALUES (134411, 2, '1994-01-05', 80952, 24, 3373.0, 'A');", "\n    DELETE FROM loan t1\n    USING loan t2\n    WHERE t1.account_id = t2.account_id\n      AND t1.date = t2.date\n      AND t1.loan_id > t2.loan_id;\n    ", "ALTER TABLE loan\n    ADD CONSTRAINT loan_accountid_date_uk\n    UNIQUE (account_id, date);"], "clean_up_sql": ["DROP TABLE IF EXISTS loan;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH last_per_station AS (\n  SELECT\n    t.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY customerid, gasstationid\n      ORDER BY transactionid DESC\n    ) AS rn\n  FROM transactions_1k t\n),\nDataSource AS (\n  SELECT\n    lps.*,\n    CASE WHEN amount < 10 THEN transactionid END AS fail_id,\n    CASE WHEN amount >= 10 THEN transactionid END AS pass_id\n  FROM last_per_station lps\n  WHERE rn = 1\n),\nCalculated AS (\n  SELECT\n    ds.*,\n    MIN(fail_id) OVER (PARTITION BY customerid) AS earliest_fail_id,\n    MAX(pass_id) OVER (PARTITION BY customerid) AS last_pass_id\n  FROM DataSource ds\n)\nSELECT\n  customerid,\n  transactionid,\n  date,\n  time,\n  gasstationid,\n  productid,\n  amount,\n  price\nFROM Calculated\nWHERE\n  (earliest_fail_id IS NOT NULL AND fail_id = earliest_fail_id)\n  OR\n  (earliest_fail_id IS NULL AND pass_id = last_pass_id);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_62", "db_id": "card_games", "query": "In our card_games database, we have a large table named cards which contains detailed information about each card. We also have two smaller tables, norm1 and norm2, which contain a subset of the cards based on certain criteria. The goal is to delete up to 1000 rows from the cards table where the combination of (uuid, setCode, rarity, manaCost) does not exist in either norm1 or norm2. This will be a sample deletion to test our approach before applying it to the entire dataset.", "issue_sql": ["DELETE FROM cards WHERE (uuid, setCode, rarity, manaCost) NOT IN ( SELECT uuid, setCode, rarity, manaCost FROM norm1 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL ) AND (uuid, setCode, rarity, manaCost) NOT IN ( SELECT uuid, setCode, rarity, manaCost FROM norm2 WHERE uuid IS NOT NULL AND setCode IS NOT NULL AND rarity IS NOT NULL AND manaCost IS NOT NULL ) LIMIT 1000;"], "preprocess_sql": ["\nCREATE TABLE norm1 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 2 = 0; CREATE TABLE norm2 AS SELECT uuid, setCode, rarity, manaCost FROM cards WHERE id % 3 = 0;\n"], "clean_up_sql": ["\nDROP TABLE norm1; DROP TABLE norm2;\n"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM user_actions AS a WHERE a.action = 'SEARCH' AND NOT EXISTS (SELECT 1 FROM user_actions WHERE user_id = a.user_id AND action = 'BUY' AND action_time > a.action_time AND (action_time < (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) OR (SELECT MIN(action_time) FROM user_actions WHERE user_id = a.user_id AND action = 'LOGIN' AND action_time > a.action_time) IS NULL));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_63", "db_id": "financial", "query": "In the financial database, I want to apply a forward fill function to all nullable columns of a table. The forward fill function should be applied to each column dynamically, given the table name, an ID column, and a row number column. For example, using the 'trans' table, I want to apply the forward fill to all nullable columns, partitioned by 'account_id' and ordered by 'date'. The function should handle any table with nullable columns and apply the forward fill accordingly. However, my initial attempt at writing the function resulted in a syntax error. I need a corrected version of the function that works for any table with nullable columns.", "issue_sql": ["CREATE OR REPLACE FUNCTION f_gap_fill_update(tbl text, id text, row_num text) RETURNS void LANGUAGE plpgsql AS $func$ DECLARE tmp text[]; col text; BEGIN select array ( select column_name from information_schema.columns c where table_name = tbl ) into tmp; foreach col in array tmp loop execute 'update '||tbl||' set '||col||' = gapfill('||col||') OVER w AS '||col||' where '||tbl||'.row_num = '||col||'.row_num window w as (PARTITION BY '||id||' ORDER BY '||row_num||') returning *;'; end loop; end $func$;"], "preprocess_sql": ["CREATE OR REPLACE FUNCTION gap_fill_internal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $func$ BEGIN RETURN COALESCE(v, s); END $func$; CREATE AGGREGATE gap_fill(anyelement) ( SFUNC = gap_fill_internal, STYPE = anyelement );"], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT cte.id, c.name FROM (SELECT card_order FROM decks WHERE id = 1) d  CROSS JOIN UNNEST(d.card_order) WITH ORDINALITY cte(id, idx)  INNER JOIN cards c ON c.id = cte.id ORDER BY cte.idx;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_64", "db_id": "financial", "query": "In the financial database, there is a table named 'card' that records details of issued cards. Each card is identified by a 'card_id' and is associated with a 'disp_id', along with other details like 'type' and 'issued'. Let's say we want to change the order of a specific 'disp_id' within the same 'type'. For instance, we want to set the 'disp_id' of a card with 'disp_id' = 41 to 1. This change should reorder the 'disp_id' values of all affected cards within the same 'type'. The expected result is that the card with 'disp_id' = 41 should now have 'disp_id' = 1, and the other cards' 'disp_id' values should be incremented accordingly.", "issue_sql": ["UPDATE card SET disp_id = 1 WHERE disp_id = 41;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT ord.*, prd.price FROM order_cards ord LEFT JOIN LATERAL (SELECT prd.* FROM card_prices prd WHERE prd.card_id = ord.card_id and prd.start_date <= ord.order_date ORDER BY start_date DESC LIMIT 1) prd ON TRUE"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_65", "db_id": "financial", "query": "I have created the following custom SQL function on a PostgreSQL 16.1 server to generate a series of monthly dates between two given dates for analyzing transaction trends over time:\\nCREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date)\\nRETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 12 AS $function$\\nselect generate_series(date_trunc('month', a), date_trunc('month', b), '1 month')\\n$function$;\\nSpecifically, I have added the row estimate parameter, and as expected, I am seeing this estimate in some simple queries:\\nexplain select generate_series_monthly('2023-01-01', '2023-12-01');\\nHowever, in some uses in queries, I see it falling back to the default of 1000:\\nexplain select * from generate_series_monthly('2023-01-01', '2023-12-01');\\nI would expect this second query to also use the 12 row estimate. Why is it resorting to 1000?", "issue_sql": ["CREATE OR REPLACE FUNCTION public.generate_series_monthly(a date, b date) RETURNS SETOF date LANGUAGE SQL IMMUTABLE PARALLEL SAFE ROWS 10 AS $function$ select generate_series(date_trunc('month', a), date_trunc('month', b), '1 month') $function$;EXPLAIN SELECT generate_series_monthly('2024-01-01', '2024-05-01');EXPLAIN SELECT * FROM generate_series_monthly('2024-01-01', '2024-05-01');"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT player_id, cols ->> 'goals' AS goals, cols ->> 'assists' AS assists, cols ->> 'yellow_cards' AS yellow_cards, cols ->> 'red_cards' AS red_cards FROM (SELECT player_id, (SELECT jsonb_object_agg(k, v) FROM unnest(string_to_array(stats_keys, ','), string_to_array(stats_values, ',')) AS x(k, v)) AS cols FROM player_stats) x ORDER BY player_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_66", "db_id": "european_football_2", "query": "In the context of european_football_2 database whose match table contains columns such as season, date, home_team_goal, away_team_goal, etc. Now, suppose you want to treat any match ending in a draw (home_team_goal = away_team_goal) as if an invoice were being issued (similar to setting Invoiced = 1). Between two such draws, you might have several other matches that do not end in a draw (equivalent to Invoiced = 0), and for each of those matches, you want to treat the total goals scored (i.e., home_team_goal + away_team_goal) like a running amount you accumulate. Finally, you only want to keep the draw rows, and each of those rows should carry the sum of total goals scored since the last draw.", "issue_sql": ["SELECT\n    m.id,\n    m.date,\n    CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END AS invoiced,\n    SUM(m.home_team_goal + m.away_team_goal)\n        OVER (PARTITION BY (CASE WHEN m.home_team_goal = m.away_team_goal THEN 1 ELSE 0 END)\n              ORDER BY m.id, m.date) AS amount\nFROM match AS m\nORDER BY m.id, m.date;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["UPDATE teams_config t SET configurations = (SELECT jsonb_agg(a.elem) FROM jsonb_array_elements(t.configurations) AS a(elem) WHERE (a.elem ->> 'id' = '101') IS NOT TRUE) WHERE t.configurations @> '[{\"id\":101}]';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_sqls_result = execute_queries([\"SELECT * FROM teams_config;\"], db_name, conn)[0]\n    assert test_pred_sqls_result[0][0] == [{'id': 100, 'name': 'testOne', 'settings': 'settingOne'}], f'Expected the object with id = 101 is deleted and only the object with id = 100 is left in the configurations column. But got: {test_pred_sqls_result[0][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_67", "db_id": "debit_card_specializing", "query": "We have a table called transactions_1k that contains transaction details for multiple customers across different gas stations. Each row in this table has:\n1. transaction date\n2. ransaction time\n3. customerid (the ID of the customer)\n4. gasstationid (the ID of the gas station)\n5. productid (the product involved)\n6. amount (the quantity, e.g., liters purchased)\n7. price (the cost)\n\nWe want to filter these transactions under the following rules, per customer:\n1.  Only the last transaction at each gas station should be considered.\n2.  If the customer has any transaction where amount < 10 (which indicates a potential issue), display the first gas station on which that issue occurred.\n3.  If the customer has no transactions with amount < 10, then display the last gas station on which the customer had a transaction with amount >= 10.\n\nGiven some sample data, we expect the final output to show only:\n1. The last transaction for each gas station where amount >= 10.\n2. The first transaction for each gas station where amount < 10.\n\nWe attempted the following SQL query in PostgreSQL to achieve this, but it does not return the desired results. Instead, it only picks the gas station with the maximum gasstationid for each customer and does not correctly determine the earliest occurrence of amount < 10 chronologically. In other words, this query fails to implement the last transaction per gas station and the first station where amount < 10 correctly.", "issue_sql": ["WITH DataSource AS (\n  SELECT\n    *,\n    MIN(CASE WHEN amount < 10 THEN gasstationid END)\n      OVER (PARTITION BY customerid) AS first_issue_gasstation,\n    ROW_NUMBER() OVER (PARTITION BY customerid ORDER BY gasstationid DESC) AS gasstation_id\n  FROM transactions_1k\n  WHERE gasstationid = (\n    SELECT MAX(gasstationid)\n    FROM transactions_1k\n    WHERE customerid = transactions_1k.customerid\n  )\n)\nSELECT\n  customerid,\n  transactionid,\n  gasstationid,\n  amount\nFROM DataSource\nWHERE\n  (first_issue_gasstation IS NULL AND gasstation_id = 1)\n  OR (first_issue_gasstation = gasstationid);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT begin_date, end_date, (DATE_PART('year', end_date) - DATE_PART('year', begin_date)) * 12 + DATE_PART('month', end_date) - DATE_PART('month', begin_date) - CASE WHEN begin_date > date_trunc('month', begin_date) THEN 1 ELSE 0 END AS full_calendar_months FROM race_dates;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_68", "db_id": "superhero", "query": "In the superhero database, we have a directed acyclic graph representing the lineage of superheroes. Each superhero has a unique identifier and a parent identifier, which points to their predecessor in the lineage. Given two superheroes, 'Superhero A' and 'Superhero B', we need to find their common ancestor in the lineage. The provided query is inefficient as it traverses the entire lineage until it finds the root, which is not optimal when the common segment of the lineage is large. We need to find an efficient way to determine the common ancestor with a complexity of O(A+B) where A and B are the number of nodes in the lineages of 'Superhero A' and 'Superhero B', respectively.", "issue_sql": ["WITH RECURSIVE linked_list(id, parent_id) AS (SELECT id, parent_id FROM lineage WHERE id = 1001 OR id = 1201 UNION ALL SELECT g.id, g.parent_id FROM lineage g INNER JOIN linked_list ll ON ll.parent_id = g.id) SELECT string_agg(id::TEXT, ',') AS ids, parent_id FROM linked_list GROUP BY parent_id HAVING COUNT(DISTINCT id) > 1;"], "preprocess_sql": ["CREATE TABLE lineage (id INT PRIMARY KEY, parent_id INT, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, lineage_depth INT DEFAULT 0, lineage_path TEXT DEFAULT '', version_number INT DEFAULT 1, last_verified_date DATE DEFAULT CURRENT_DATE, metadata JSONB DEFAULT '{}'::jsonb, notes TEXT DEFAULT '', status VARCHAR(50) DEFAULT 'active', visibility_level INT DEFAULT 0, external_reference_id UUID DEFAULT gen_random_uuid(), modification_count INT DEFAULT 0, importance_score NUMERIC(5,2) DEFAULT 0.0);", "INSERT INTO lineage (id, parent_id, created_at, updated_at, is_active, lineage_depth, lineage_path, version_number, last_verified_date, metadata, notes, status, visibility_level, external_reference_id, modification_count, importance_score) SELECT i, CASE WHEN i = 1 THEN NULL ELSE i - 1 END, CURRENT_TIMESTAMP - (random() * interval '365 days'), CURRENT_TIMESTAMP - (random() * interval '30 days'), TRUE, CASE WHEN i = 1 THEN 0 ELSE floor(ln(i)::numeric) END, CASE WHEN i = 1 THEN i::text ELSE '1/' || i::text END, ceil(random() * 5), CURRENT_DATE - (random() * 180)::integer, jsonb_build_object('origin', 'system', 'batch', floor(random() * 100)), 'Automatically generated lineage record ' || i, CASE WHEN random() > 0.9 THEN 'archived' ELSE 'active' END, floor(random() * 3), gen_random_uuid(), floor(random() * 10), 5.0 - (random() * 4.5) FROM generate_series(1, 1000) AS i;", "INSERT INTO lineage (id, parent_id, created_at, updated_at, is_active, lineage_depth, lineage_path, version_number, last_verified_date, metadata, notes, status, visibility_level, external_reference_id, modification_count, importance_score) SELECT 1000 + i, 1000 + i - 1, CURRENT_TIMESTAMP - (random() * interval '180 days'), CURRENT_TIMESTAMP - (random() * interval '15 days'), TRUE, 1000 + floor(ln(i)::numeric), '1/1000/' || (1000+i)::text, ceil(random() * 5), CURRENT_DATE - (random() * 90)::integer, jsonb_build_object('origin', 'branch_a', 'batch', floor(random() * 100)), 'Branch A lineage record ' || i, CASE WHEN random() > 0.85 THEN 'pending' WHEN random() > 0.95 THEN 'archived' ELSE 'active' END, floor(random() * 3), gen_random_uuid(), floor(random() * 8), 7.5 - (random() * 3.0) FROM generate_series(1, 200) AS i;", "INSERT INTO lineage (id, parent_id, created_at, updated_at, is_active, lineage_depth, lineage_path, version_number, last_verified_date, metadata, notes, status, visibility_level, external_reference_id, modification_count, importance_score) SELECT 1200 + i, 1000 + i - 1, CURRENT_TIMESTAMP - (random() * interval '90 days'), CURRENT_TIMESTAMP - (random() * interval '7 days'), CASE WHEN random() > 0.95 THEN FALSE ELSE TRUE END, 1000 + floor(ln(i)::numeric), '1/1000/' || (1200+i)::text, ceil(random() * 5), CURRENT_DATE - (random() * 45)::integer, jsonb_build_object('origin', 'branch_b', 'batch', floor(random() * 100)), 'Branch B lineage record ' || i, CASE WHEN random() > 0.9 THEN 'pending' WHEN random() > 0.95 THEN 'archived' ELSE 'active' END, floor(random() * 3), gen_random_uuid(), floor(random() * 5), 8.0 - (random() * 2.5) FROM generate_series(1, 200) AS i;"], "clean_up_sql": ["DROP TABLE lineage;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["INSERT INTO new_attendance (\n        link_to_event,\n        link_to_member, date\n    ) VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT (link_to_event, link_to_member) DO UPDATE SET\n        date = NOW();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls,db_name,conn)\n    queries = [\"SELECT * FROM new_attendance WHERE link_to_event = 'reciRZdAqNIKuMC96' AND link_to_member = 'recL94zpn6Xh6kQii';\"]\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    ori_date = res[0][-1]\n    execute_queries(pred_sqls,db_name,conn)\n    res,_,_ = execute_queries(queries,db_name,conn)\n    assert len(res) == 1\n    new_date = res[0][-1]\n    assert ori_date != new_date\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_69", "db_id": "card_games", "query": "In a digital card trading platform, users perform various actions such as `LOGIN`, `SEARCH`, and `BUY`. An abandoned `SEARCH` action is defined as when a user `LOGIN`s, performs one or more `SEARCH` actions, and does not perform a `BUY` action before the next `LOGIN`. Given a table `user_actions` that records `user_id`, `action`, and `action_time`, determine all abandoned `SEARCH` actions.", "issue_sql": ["SELECT c1.user_id, COUNT(*) FROM user_actions c1 LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'LOGIN') c2 ON c1.user_id = c2.user_id AND c2.action_time > c1.action_time LEFT JOIN (SELECT user_id, action, action_time FROM user_actions WHERE action = 'BUY') c3 ON c1.user_id = c3.user_id AND c3.action_time > c1.action_time AND c3.action_time < c2.action_time WHERE c1.action = 'SEARCH' AND c2.user_id IS NOT NULL AND c3.user_id IS NULL GROUP BY 1"], "preprocess_sql": ["CREATE TABLE user_actions(user_id VARCHAR(1) NOT NULL, action VARCHAR(6) NOT NULL, action_time DATE NOT NULL);", "INSERT INTO user_actions(user_id, action, action_time) VALUES ('A', 'LOGIN', '2023-05-01'), ('A', 'SEARCH', '2023-05-02'), ('A', 'SEARCH', '2023-05-03'), ('A', 'BUY', '2023-05-04'), ('B', 'LOGIN', '2023-05-01'), ('B', 'SEARCH', '2023-05-02'), ('B', 'SEARCH', '2023-05-03'), ('B', 'LOGIN', '2023-05-04'), ('B', 'SEARCH', '2023-05-05')"], "clean_up_sql": ["DROP TABLE user_actions"], "category": "Query", "efficiency": false, "sol_sql": ["CREATE FUNCTION pg_try_advisory_lock_with_timeout(key bigint) RETURNS boolean\n        SET lock_timeout TO '1s'\n        AS $$\n        BEGIN\n        PERFORM pg_advisory_lock(key);\n        RETURN true;\n        EXCEPTION\n        WHEN lock_not_available OR deadlock_detected THEN\n            RETURN false;\n        END;\n        $$\n        LANGUAGE plpgsql;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\"SELECT pg_try_advisory_lock_with_timeout(12345);\"]\n    res, _, _ = execute_queries(queries,db_name,conn)\n    print(res)\n    assert res[0][0] == True or res[0][0] == False\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_70", "db_id": "card_games", "query": "In the card_games database, there is a table named 'cards' which contains various details about each card, including a unique identifier 'id' and the card's name 'name'. Another table named 'decks' stores information about different decks, where each deck has a unique identifier 'id' and an array 'card_order' that lists the 'id's of the cards in the deck in the order they should be played. When a user selects a deck, they want to see the cards in the order they are listed in the 'card_order' array. However, the current SQL query does not preserve the order of the cards as specified in the 'card_order' array. The user's current SQL query is provided below and it does not maintain the order of the cards.", "issue_sql": ["SELECT c.id, c.name FROM cards c WHERE c.id IN (SELECT unnest(card_order) FROM decks WHERE id = 1);"], "preprocess_sql": ["CREATE TABLE decks (id bigint PRIMARY KEY, card_order bigint[], created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, deck_name VARCHAR(100) DEFAULT 'Unnamed Deck', deck_description TEXT DEFAULT '', owner_id BIGINT DEFAULT 0, is_public BOOLEAN DEFAULT true, view_count INTEGER DEFAULT 0, favorite_count INTEGER DEFAULT 0, last_played_at TIMESTAMP WITH TIME ZONE, deck_format VARCHAR(50) DEFAULT 'standard', deck_tags TEXT[] DEFAULT '{}'::TEXT[], deck_color_identity VARCHAR(10) DEFAULT 'WUBRG', metadata JSONB DEFAULT '{}'::JSONB, version INTEGER DEFAULT 1, is_archived BOOLEAN DEFAULT false, deck_hash UUID DEFAULT gen_random_uuid(), average_mana_cost NUMERIC(5,2) DEFAULT 0.0, total_cards_count INTEGER DEFAULT 0, featured_card_id BIGINT);", "INSERT INTO decks (id, card_order, deck_name, deck_description, owner_id, is_public, view_count, favorite_count, last_played_at, deck_format, deck_tags, deck_color_identity, metadata, version, is_archived, average_mana_cost, total_cards_count, featured_card_id) VALUES (1, ARRAY[3, 6, 1], 'Aggro Deck', 'Fast-paced aggressive deck', 1001, true, 245, 18, '2023-05-15 08:30:00', 'modern', ARRAY['aggro', 'competitive'], 'RW', '{\"creator\": \"PlayerOne\", \"winRate\": 0.65}'::jsonb, 3, false, 2.75, 60, 3), (2, ARRAY[5, 2, 4], 'Control Deck', 'Slow and methodical control deck', 1002, true, 187, 12, '2023-06-22 14:15:00', 'standard', ARRAY['control', 'blue'], 'UB', '{\"creator\": \"PlayerTwo\", \"winRate\": 0.58}'::jsonb, 2, false, 3.45, 60, 5);"], "clean_up_sql": ["DROP TABLE decks;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT\n            link_to_member,\n            ROUND(SUM(hours)::NUMERIC, -1) AS rounded_hours,\n            RANK() OVER (ORDER BY ROUND(SUM(hours)::NUMERIC, -1) DESC) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_71", "db_id": "card_games", "query": "In the context of the card_games database, we have two tables: 'card_prices' and 'order_cards'. The 'card_prices' table records the price of each card at different start dates, and the 'order_cards' table records the cards ordered by customers on specific dates. We need to join these two tables to get the price of each card at the time it was ordered. However, the initial attempt to join the tables resulted in duplicate records for some orders. Here are the tables and the problematic query:\\n\\Table 'card_prices':\\n| start_date | card_id | price |\\n|------------|---------|-------|\\n| 2023-04-01 | 1       | 10.0  |\\n| 2023-04-15 | 1       | 20.0  |\\n| 2023-04-01 | 2       | 20.0  |\\n\\Table 'order_cards':\\n| order_date | order_id | card_id |\\n|------------|----------|---------|\\n| 2023-04-01 | 10001    | 1       |\\n| 2023-04-01 | 10001    | 2       |\\n| 2023-04-02 | 10002    | 1       |\\n| 2023-04-02 | 10002    | 2       |\\n| 2023-04-16 | 10003    | 1       |\\n| 2023-04-16 | 10003    | 2       |\\n\\nThe desired result is:\\n| order_date | order_id | card_id | price |\\n|------------|----------|---------|-------|\\n| 2023-04-01 | 10001    | 1       | 10.0  |\\n| 2023-04-01 | 10001    | 2       | 20.0  |\\n| 2023-04-02 | 10002    | 1       | 10.0  |\\n| 2023-04-02 | 10002    | 2       | 20.0  |\\n| 2023-04-16 | 10003    | 1       | 20.0  |\\n| 2023-04-16 | 10003    | 2       | 20.0  |\\nHowever, the initial attempt resulted in duplicate records for some orders.\\n", "issue_sql": ["SELECT ord.order_date, ord.order_id, ord.card_id, prd.price FROM order_cards ord LEFT JOIN (SELECT * FROM card_prices ORDER BY start_date ASC) AS prd ON ord.card_id = prd.card_id AND ord.order_date >= prd.start_date"], "preprocess_sql": ["CREATE TABLE card_prices (start_date DATE, card_id BIGINT, price NUMERIC);", "INSERT INTO card_prices (start_date, card_id, price) VALUES ('2023-04-01', 1, 10.0), ('2023-04-15', 1, 20.0), ('2023-04-01', 2, 20.0);", "CREATE TABLE order_cards (order_date DATE, order_id BIGINT, card_id BIGINT);", "INSERT INTO order_cards (order_date, order_id, card_id) VALUES ('2023-04-01', 10001, 1), ('2023-04-01', 10001, 2), ('2023-04-02', 10002, 1), ('2023-04-02', 10002, 2), ('2023-04-16', 10003, 1), ('2023-04-16', 10003, 2);"], "clean_up_sql": ["DROP TABLE card_prices;", "DROP TABLE order_cards;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT\n            CASE\n                WHEN EXISTS (\n                    SELECT 1\n                    FROM pg_indexes\n                    WHERE tablename = 'account'\n                    AND indexname = 'ix_account'\n                ) THEN TRUE\n                ELSE FALSE\n            END AS index_exists;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == True\n    queries = [\"DROP INDEX ix_account;\"]\n    execute_queries(queries,db_name,conn)\n    res, _, _ = execute_queries(pred_sqls,db_name,conn)\n    assert res[0][0] == False\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_72", "db_id": "european_football_2", "query": "In the database 'european_football_2', there is a table named 'player_stats' that records the performance statistics of football players across different matches. Each row in the table represents a player's performance in a specific match. The table has two columns, 'stats_keys' and 'stats_values', which store the performance metrics and their corresponding values as comma-separated strings. For example, 'stats_keys' might contain 'goals,assists,yellow_cards' and 'stats_values' might contain '2,1,0'. The task is to transform this table into a format where each performance metric is a separate column, with the corresponding values filled in for each player's match performance.", "issue_sql": ["select player_id, stats_keys, stats_values from player_stats"], "preprocess_sql": ["CREATE TABLE player_stats (player_id INT, stats_keys TEXT, stats_values TEXT);", "INSERT INTO player_stats (player_id, stats_keys, stats_values) VALUES (1, 'goals,assists,yellow_cards', '2,1,0'), (2, 'assists,yellow_cards', '0,1'), (3, 'goals,yellow_cards', '1,0'), (4, 'assists,yellow_cards,red_cards', '2,1,0');"], "clean_up_sql": ["DROP TABLE player_stats;"], "category": "Query", "efficiency": false, "sol_sql": ["drop view findcount;\n        create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009'\n        ) seasons;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    queries = [\n        \"\"\"\n        SELECT \n            CASE \n                WHEN pg_type.typname = 'float8' THEN TRUE \n                ELSE FALSE \n            END AS is_float\n        FROM pg_attribute\n        JOIN pg_class ON pg_attribute.attrelid = pg_class.oid\n        JOIN pg_type ON pg_attribute.atttypid = pg_type.oid\n        WHERE pg_class.relname = 'findcount' \n        AND pg_attribute.attname = 'team_count'\n        AND pg_attribute.attnum > 0;\n        \"\"\"\n    ]\n    \n    res, _, _ = execute_queries(queries,db_name,conn)\n    assert res[0][0] == True\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_73", "db_id": "european_football_2", "query": "In the 'european_football_2' database, there is a table named 'teams_config' which holds information about various football teams. Each team has a 'configurations' column of type jsonb that stores an array of objects representing different team settings. Each object in the array has an 'id', 'name', and 'settings'. For example, one row in the 'teams_config' table might have the following 'configurations':\n[\n    {\n             \"id\": 100, \n            \"name\": \"testOne\", \n            \"settings\": \"settingOne\" \n       },\n         {\n            \"id\": 101,\n            \"name\": \"testTwo\",\n            \"settings\": \"settingTwo\"\n        },\n]", "issue_sql": ["UPDATE teams_config SET configurations = jsonb_set(configurations, '{settings}', (configurations->'id') - (SELECT DISTINCT position - 1 FROM teams_config, jsonb_array_elements(configurations) WITH ORDINALITY arr(elem, position) WHERE elem->>'id' = '101')::int);"], "preprocess_sql": ["CREATE TABLE teams_config (configurations jsonb, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, version INTEGER DEFAULT 1, is_active BOOLEAN DEFAULT TRUE, last_modified_by VARCHAR(100) DEFAULT 'system', config_hash UUID DEFAULT gen_random_uuid(), metadata JSONB DEFAULT '{}'::jsonb, access_level INTEGER DEFAULT 0, description TEXT DEFAULT '', tags TEXT[] DEFAULT '{}'::TEXT[], validation_status VARCHAR(50) DEFAULT 'pending', expiry_date DATE DEFAULT (CURRENT_DATE + INTERVAL '1 year'), priority INTEGER DEFAULT 5, sync_status VARCHAR(50) DEFAULT 'not_synced', external_reference_id VARCHAR(100) DEFAULT NULL);", "INSERT INTO teams_config (configurations, created_at, updated_at, version, is_active, last_modified_by, config_hash, metadata, access_level, description, tags, validation_status, expiry_date, priority, sync_status, external_reference_id) VALUES ('[{\"id\": 100, \"name\": \"testOne\", \"settings\": \"settingOne\"}, {\"id\": 101, \"name\": \"testTwo\", \"settings\": \"settingTwo\"}]', '2023-01-15T10:30:00Z', '2023-01-15T10:30:00Z', 1, TRUE, 'admin', 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', '{\"source\": \"manual\", \"notes\": \"Initial configuration\"}'::jsonb, 2, 'Default team configurations', '{football,european,config}'::TEXT[], 'validated', '2024-01-15', 3, 'synced', 'EXT-REF-001');"], "clean_up_sql": ["DROP TABLE teams_config"], "category": "Management", "efficiency": false, "sol_sql": ["select posttypeid,\n        sum(case when tags like '%bayesian%'\n                or tags like '%distributions%'\n            then 1 else 0 end) as keyword_count\n        from posts\n        group by posttypeid"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert pred_query_result[0][0] == 2\n    assert pred_query_result[0][1] == 1\n    assert pred_query_result[1][0] == 1\n    assert pred_query_result[1][1] == 2\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_74", "db_id": "formula_1", "query": "I have a table race_dates which stores the begin_date and end_date of races, e.g. '2022-01-03' and '2022-03-04', is there any neat way to calculate ONLY the completed full calendar months between these dates? Some examples with their requested outputs: '2022-01-03' and '2022-03-04' full calendar months = 1 since only February was a full calendar month between this timespan. '2022-01-01' and '2022-05-30' full calendar months = 4 since May has 31 days total. '2022-01-31' and '2022-05-31' full calendar months = 3 since the month of May is not completed. I tried subtracting the dates but it gives me the days difference between these dates. I also tried the function AGE() but it is based also in the days difference, since it is using days to calculate years months etc.", "issue_sql": ["SELECT begin_date, end_date, age(CASE WHEN end_date = date_trunc('month', end_date) + interval '1 month - 1 day' THEN end_date + interval '1 day' ELSE date_trunc('month', end_date) END::date, CASE WHEN begin_date = date_trunc('month', begin_date) THEN begin_date ELSE date_trunc('month', begin_date) + interval '1 month' END::date) AS calculated_months FROM race_dates;"], "preprocess_sql": ["CREATE TABLE race_dates (begin_date DATE NOT NULL, end_date DATE NOT NULL)", "INSERT INTO race_dates (begin_date, end_date) VALUES ('2022-01-03', '2022-03-04'), ('2022-01-01', '2022-05-30'), ('2022-01-31', '2022-05-31'), ('2021-11-15', '2022-02-10'), ('2021-12-01', '2022-05-31');"], "clean_up_sql": ["DROP TABLE race_dates"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id, MAX(last_update) DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_75", "db_id": "student_club", "query": "In the student_club database, I am trying to insert an attendance record that tracks when a member attends an event. The goal is to ensure there are no duplicate entries for the same member (link_to_member) attending the same event (link_to_event). If an attendance record for the member and event already exists, the date column should be updated to reflect the most recent attendance timestamp. If no such record exists, a new record should be created. I have tried using the ON CONFLICT clause with a WHERE condition to achieve this, but it doesn't seem to work.\nHere is one of the many permutations I've tried:\n\nsql\nINSERT INTO new_attendance (link_to_event, link_to_member, date) \nVALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW()) \nON CONFLICT \n   WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING\n\n\nThe link_to_member column does not have any constraints, so the simpler syntax:\n\nsql\nON CONFLICT (link_to_member) DO NOTHING\n\n\nthrows database errors. My hope is this is a simple syntax issue.", "issue_sql": ["INSERT INTO new_attendance (link_to_event, link_to_member, date)\n    VALUES ('reciRZdAqNIKuMC96', 'recL94zpn6Xh6kQii', NOW())\n    ON CONFLICT\n    WHERE link_to_member='recL94zpn6Xh6kQii' DO NOTHING;"], "preprocess_sql": ["\n    DROP TABLE IF EXISTS new_attendance;\n    ", "\n    CREATE TABLE new_attendance AS\n    SELECT DISTINCT link_to_event, link_to_member, NOW() AS date\n    FROM attendance;\n    ", "\n    ALTER TABLE new_attendance\n    ADD CONSTRAINT unique_event_member UNIQUE (link_to_event, link_to_member);\n    "], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT entity_id, coalesce(height, lag(height, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS height, coalesce(weight, lag(weight, 1, null) OVER (PARTITION BY entity_id ORDER BY updated_at)) AS weight, updated_at FROM (SELECT entity_id, MAX(CASE WHEN column_id = 'height' THEN value::int END) AS height, MAX(CASE WHEN column_id = 'weight' THEN value::int END) AS weight, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) AS changes;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n    result = 0 if any('json_object_agg' in sql.lower() for sql in pred_sqls) else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_76", "db_id": "financial", "query": "I'm migrating from Oracle to PostgreSQL. In Oracle, I used the following call to acquire a lock with a timeout: `lkstat := DBMS_LOCK.REQUEST(lkhndl, DBMS_LOCK.X_MODE, lktimeout, true);`. This function tries to acquire the lock `lkhndl` and returns 1 if it fails to get it after `lktimeout` seconds. In PostgreSQL, I tried using `pg_advisory_xact_lock(lkhndl);`, but it seems to wait indefinitely for the lock.     I need a way to implement a timeout version of lock acquiring in PostgreSQL named pg_try_advisory_lock_with_timeout. The function pg_try_advisory_lock_with_timeout(key bigint) is designed to attempt to acquire a PostgreSQL advisory lock with a timeout of 1 second. If the lock is unavailable due to contention or deadlock detection, it will return false instead of waiting indefinitely.", "issue_sql": ["pg_advisory_xact_lock(lkhndl);"], "preprocess_sql": ["\n    DROP FUNCTION IF EXISTS pg_try_advisory_lock_with_timeout(bigint);\n    "], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["WITH RECURSIVE qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL), qr(item, subgroup) AS (SELECT * FROM qr1 UNION ALL SELECT * FROM qr2), cte(item, other, items) AS (SELECT item, item, ARRAY[item] FROM qr UNION ALL SELECT cte.item, g.item, cte.items || g.item FROM cte JOIN qr ON qr.item = cte.other JOIN qr g ON g.subgroup = qr.subgroup WHERE g.item <> ALL (cte.items)) SELECT item, MIN(qr1.subgroup) AS sg1, MIN(qr2.subgroup) AS sg2, DENSE_RANK() OVER (ORDER BY MIN(other)) AS grp FROM cte LEFT JOIN qr1 USING (item) LEFT JOIN qr2 USING (item) GROUP BY item ORDER BY item;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_77", "db_id": "student_club", "query": "I'm trying to rank club members based on the hours they have attented for events, rounded to the nearest 10. I need to produce a descending ranking of members by total hours attened, including a column with the rank using the `RANK()` window function, and sort the result by the rank. However, my rounding logic seems to be incorrect, as it produces different results compared to the expected output.", "issue_sql": ["SELECT\n            link_to_member,\n            CASE\n                WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0'))\n                THEN CEIL(SUM(hours) / 10) * 10\n                ELSE FLOOR(SUM(hours) / 10) * 10\n            END AS rounded_hours,\n            RANK() OVER (ORDER BY\n                CASE\n                    WHEN (SUBSTRING(ROUND(SUM(hours)::NUMERIC, 0)::TEXT FROM '.{1}$') IN ('5', '6', '7', '8', '9', '0'))\n                    THEN CEIL(SUM(hours) / 10) * 10\n                    ELSE FLOOR(SUM(hours) / 10) * 10\n                END DESC\n            ) AS rank\n        FROM attendance\n        GROUP BY link_to_member\n        ORDER BY rank, link_to_member;"], "preprocess_sql": ["\n    ALTER TABLE attendance\n    ADD COLUMN hours NUMERIC;\n    ", "\n    TRUNCATE TABLE attendance;\n    ", "\n    INSERT INTO attendance (link_to_event, link_to_member, hours)\n    VALUES \n    ('rec0Si5cQ4rJRVzd6', 'rec1x5zBFIqoOuPW8', 64.5),\n    ('rec0akZnLLpGUloLH', 'recEFd8s6pkrTt4Pz', 60.0),\n    ('rec0dZPcWXF0QjNnE', 'recJMazpPVexyFYTc', 210.5),\n    ('rec180D2MI4EpckHy', 'recUdRhbhcEO1Hk5r', 237.6);\n    "], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH r AS (SELECT id, date_of_visit, sum(sessions) as sessions, sum(pageviews) as pageviews, sum(bounces) as bounce, coalesce(utm_campaign, '') as utm_campaign, coalesce(utm_source, '') as utm_source, coalesce(utm_medium, '') as utm_medium, coalesce(utm_content, '') as utm_content, coalesce(utm_term, '') as utm_term FROM report as r GROUP BY id, date_of_visit, cube(6, 7, 8, 9, 10)) SELECT r.* FROM r JOIN utm as u ON r.id = u.row_id AND (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT DISTINCT FROM (u.utm_campaign, u.utm_source, u.utm_medium, u.utm_content, u.utm_term) WHERE 'NA' IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term) IS NOT TRUE;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count = sum('union' in sql.lower() for sql in pred_sqls)\n    result = 0 if count > 3 else 1\n    assert result == 1, f\"Expected 1 because json_object_agg includes redundant aggregations which is not allowed, but got {result}.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_78", "db_id": "financial", "query": "I need to create an index named ix_account on the 'account' table for the columns 'district_id', 'frequency', and 'date'. I want to ensure that the index does not already exist before attempting to create it. How can I check for the existence of this index? Return True if the index exists. Otherwise return False.", "issue_sql": ["CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);"], "preprocess_sql": ["\n        CREATE INDEX ix_account ON account USING btree (district_id, frequency, date);   \n        "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT\n    c.id,\n    c.text,\n    (\n        SELECT array_agg(matches[1])\n        FROM regexp_matches(\n            c.text,\n            '(\\{[^{}]*\\})',\n            'g'\n        ) AS matches\n    ) AS bracketed_tokens\nFROM cards AS c;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_79", "db_id": "european_football_2", "query": "I am trying to create a view that counts the records where home team goal is 2 in a specific season.     I have a function `findteam(text)` that returns a float representing the count for a given season.    However, when I try to use this function in my view, I encounter an error stating 'cannot change data type of view column `team_count` from integer to double precision'.     I am new to SQL and do not understand why this is happening or how to fix it.", "issue_sql": ["create or replace view findcount(season, team_count) as\n        select\n            season,\n            findteam(season) as team_count\n        from (\n            select distinct season\n            from match\n            where season >= '2008/2009'\n        ) seasons;"], "preprocess_sql": ["\n    DROP VIEW IF EXISTS findcount;\n    DROP FUNCTION IF EXISTS findteam;\n    ", "\n    create or replace function findteam(text) returns float as $$\n    select cast(count(*) as float)\n    from match m\n    where m.home_team_goal = 2 and m.season = $1;\n    $$ language sql;\n    ", "\n    CREATE VIEW findcount AS\n    SELECT season, CAST(10 AS INTEGER) AS team_count\n    from (\n            select distinct season\n            from match\n            where season >= '2008/2009' \n        ) seasons;\n    "], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["WITH ranked_races AS (SELECT gender_id, race_id, COUNT(*) AS count, DENSE_RANK() OVER (PARTITION BY gender_id ORDER BY COUNT(*) DESC) AS rank FROM superhero GROUP BY gender_id, race_id) SELECT gender_id, race_id, count FROM ranked_races WHERE rank <= 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_80", "db_id": "codebase_community", "query": "In the context of the 'codebase_community' database, a user has a table named 'posts' containing various posts made by users. Each post has a 'tags' column    that lists the tags associated with the post. Specifically, the user is interested in identifying the number of posts that include the keywords 'bayesian' or 'distributions' for each post type.    The user attempted to implement this in PostgreSQL but encountered errors in his SQL query.", "issue_sql": ["select posttypeid\n        case when tags like ('%bayesian%','%distributions%')\n        then 1 else 0 end as keyword_count\n        from posts"], "preprocess_sql": ["\n    ALTER TABLE posts RENAME TO posts_backup;\n    ", "\n    CREATE TABLE posts (\n    id INT PRIMARY KEY,\n    posttypeid INT,\n    tags TEXT\n    );\n    ", "\n    INSERT INTO posts (id, posttypeid, tags)\n    VALUES \n    (1, 1, '<bayesian><prior><elicitation>'),\n    (2, 1, '<distributions><normality>'),\n    (3, 1, '<software><open-source>'),\n    (4, 2, '<distributions>'),\n    (5, 2, '<book><code>');\n    ", "\n    DROP TABLE IF EXISTS posts_backup;\n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT r.* FROM unnest(ARRAY['6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628']::uuid[]) AS p(uuid) CROSS JOIN LATERAL (SELECT id, date, text, uuid FROM rulings r WHERE r.uuid = p.uuid::varchar ORDER BY date DESC LIMIT 3) r ORDER BY uuid, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_81", "db_id": "debit_card_specializing", "query": "I have a table of transactions for multiple customers, where each transaction has a unique transaction id, along with amount, type, and transaction record. Some transactions for a single customerid share the same combination of these attributes. I want to update a first_transaction column with the transaction of the earliest transaction for each unique combination of attributes within each customer. My current method uses a LATERAL JOIN but is extremely slow on my small server. I process one customer at a time and commit after each iteration, but the query remains inefficient. How can I optimize this process?", "issue_sql": ["SELECT a.customerid, a.transaction, (SELECT b.transaction FROM transaction_info b WHERE b.customerid = a.customerid AND b.amount = a.amount AND b.type = a.type ORDER BY b.transaction LIMIT 1) AS first_transaction, a.amount, a.type, a.transactionid FROM transaction_info a ORDER BY a.customerid, a.transaction"], "preprocess_sql": ["CREATE TABLE transaction_info (\n  customerid int,\n  transaction int,\n  first_transaction varchar(10),\n  amount numeric,\n  type numeric,\n  transactionid text,\n  -- New columns\n  transaction_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  transaction_status VARCHAR(20) DEFAULT 'completed',\n  payment_method VARCHAR(50) DEFAULT 'card',\n  currency_code CHAR(3) DEFAULT 'USD',\n  exchange_rate NUMERIC(10, 6) DEFAULT 1.000000,\n  is_flagged BOOLEAN DEFAULT false,\n  metadata JSONB DEFAULT '{}'::jsonb,\n  processing_time_ms INTEGER DEFAULT 250,\n  retry_count SMALLINT DEFAULT 0,\n  last_modified_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  created_by VARCHAR(100) DEFAULT 'system',\n  transaction_source VARCHAR(50) DEFAULT 'web',\n  batch_id UUID DEFAULT gen_random_uuid(),\n  notes TEXT DEFAULT NULL,\n  tax_amount NUMERIC(12, 4) DEFAULT 0.0000\n);", "INSERT INTO transaction_info (customerid, transaction, first_transaction, amount, type, transactionid, transaction_date, transaction_status, payment_method, currency_code, exchange_rate, is_flagged, metadata, processing_time_ms, retry_count, last_modified_at, created_by, transaction_source, batch_id, notes, tax_amount) VALUES\n(1, 1, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F', '2022-01-01 08:30:45+00', 'completed', 'credit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-12345\", \"ip\": \"192.168.1.1\"}'::jsonb, 125, 0, '2022-01-01 08:30:45+00', 'system', 'pos', 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'Regular transaction', 5220.06),\n(1, 2, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F', '2022-01-02 09:15:22+00', 'completed', 'credit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-12345\", \"ip\": \"192.168.1.1\"}'::jsonb, 130, 0, '2022-01-02 09:15:22+00', 'system', 'pos', 'b1eebc99-9c0b-4ef8-bb6d-6bb9bd380a12', 'Regular transaction', 5220.06),\n(1, 3, 'na', 65250.78, 700000.52, '01010000206A0000000000F0C02E458A4400000000F03F', '2022-01-03 10:45:33+00', 'completed', 'credit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-12345\", \"ip\": \"192.168.1.1\"}'::jsonb, 118, 0, '2022-01-03 10:45:33+00', 'system', 'pos', 'c2eebc99-9c0b-4ef8-bb6d-6bb9bd380a13', 'Regular transaction', 5220.06),\n(1, 4, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F', '2022-01-04 11:20:15+00', 'completed', 'debit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-67890\", \"ip\": \"192.168.1.2\"}'::jsonb, 142, 0, '2022-01-04 11:20:15+00', 'system', 'web', 'd3eebc99-9c0b-4ef8-bb6d-6bb9bd380a14', 'Premium transaction', 5279.92),\n(1, 5, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F', '2022-01-05 14:05:38+00', 'completed', 'debit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-67890\", \"ip\": \"192.168.1.2\"}'::jsonb, 135, 0, '2022-01-05 14:05:38+00', 'system', 'web', 'e4eebc99-9c0b-4ef8-bb6d-6bb9bd380a15', 'Premium transaction', 5279.92),\n(1, 6, 'na', 65999.00, 700555.00, '01010000455A000000000010C03F478A4400000010F03F', '2022-01-06 16:30:42+00', 'completed', 'debit_card', 'USD', 1.000000, false, '{\"device_id\": \"d-67890\", \"ip\": \"192.168.1.2\"}'::jsonb, 128, 0, '2022-01-06 16:30:42+00', 'system', 'web', 'f5eebc99-9c0b-4ef8-bb6d-6bb9bd380a16', 'Premium transaction', 5279.92);"], "clean_up_sql": ["\nDROP TABLE test;\n"], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH riders AS ( SELECT DISTINCT id, name, total_points FROM racers), places AS (SELECT id, name, RANK() OVER (ORDER BY total_points DESC) AS place FROM riders) SELECT p.place, r.*  FROM places p JOIN racers r ON (r.id, r.name) = (p.id, p.name);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_82", "db_id": "toxicology", "query": "In the toxicology database, I have two tables, 'bond' and 'molecule'. The 'bond' table contains information about bonds within molecules, including a foreign key 'molecule_id' that references the 'molecule' table. I need to construct a query that select count(*), molecule_id, most recent update timestamp grouping the bonds by 'molecule_id' and sorts the results based on molecule_id and the most recent bond entry (assuming we have a timestamp column added to the 'bond' table for this purpose). However, I've tried the following query and it doesn't work as expected:", "issue_sql": ["SELECT count(bond_id), molecule_id FROM bond GROUP BY molecule_id ORDER BY molecule_id last_update DESC;"], "preprocess_sql": ["ALTER TABLE bond ADD COLUMN last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP;"], "clean_up_sql": ["ALTER TABLE bond DROP COLUMN last_update;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH first_purchase AS (SELECT customer_id, MIN(month_year) AS first_month FROM orders GROUP BY customer_id) SELECT o.month_year, COUNT(DISTINCT o.customer_id) AS repeat_customers FROM orders o JOIN first_purchase fp ON o.customer_id = fp.customer_id WHERE o.month_year > fp.first_month GROUP BY o.month_year ORDER BY o.month_year;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_83", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, we have a table that logs changes to player statistics over time. Each row in the 'player_stats_changes' table represents a change to a specific player's attribute (such as height or weight) at a particular timestamp. We want to generate a cumulative view of these changes, where each row shows the player's current height and weight at each timestamp, filling in any missing values with the most recent known value.", "issue_sql": ["SELECT entity_id, coalesce(change->'height', lag(change->'height', 1, null) over (partition by entity_id order by updated_at)) as height, coalesce(change->'weight', lag(change->'weight', 1, null) over (partition by entity_id order by updated_at)) as weight, updated_at FROM ( SELECT entity_id, json_object_agg(column_id, value) as change, updated_at FROM player_stats_changes GROUP BY entity_id, updated_at) as changes;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS player_stats_changes ( entity_id TEXT NOT NULL, column_id TEXT NOT NULL, value JSONB NOT NULL, updated_at TIMESTAMP NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, modified_by VARCHAR(100) DEFAULT 'system', modification_reason TEXT DEFAULT 'initial entry', is_verified BOOLEAN DEFAULT false, verification_date TIMESTAMP, data_quality_score INTEGER DEFAULT 0, source_system VARCHAR(50) DEFAULT 'manual', version_number INTEGER DEFAULT 1, metadata JSONB DEFAULT '{}'::jsonb, is_active BOOLEAN DEFAULT true, change_uuid UUID DEFAULT gen_random_uuid(), previous_value JSONB, change_magnitude NUMERIC(10,2), notes TEXT, tags TEXT[], expiration_date DATE );", "INSERT INTO player_stats_changes (entity_id, column_id, value, updated_at, created_at, modified_by, modification_reason, is_verified, verification_date, data_quality_score, source_system, version_number, metadata, is_active, change_uuid, previous_value, change_magnitude, notes, tags, expiration_date) VALUES ('1', 'height', to_jsonb(140), '01-01-2021 00:00:00'::TIMESTAMP, '01-01-2021 00:00:00'::TIMESTAMP WITH TIME ZONE, 'data_migration', 'initial player measurement', true, '01-01-2021 12:00:00'::TIMESTAMP, 85, 'player_management_system', 1, '{\"measurement_unit\": \"cm\", \"measured_by\": \"team_physician\"}'::jsonb, true, 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'::UUID, NULL, NULL, 'Initial height measurement for player', '{\"rookie\", \"measurement\", \"physical\"}', '12-31-2025'::DATE), ('1', 'weight', to_jsonb(30), '01-01-2021 00:00:00'::TIMESTAMP, '01-01-2021 00:00:00'::TIMESTAMP WITH TIME ZONE, 'data_migration', 'initial player measurement', true, '01-01-2021 12:00:00'::TIMESTAMP, 85, 'player_management_system', 1, '{\"measurement_unit\": \"kg\", \"measured_by\": \"team_physician\"}'::jsonb, true, 'b2c3d4e5-f6a7-8901-bcde-f23456789012'::UUID, NULL, NULL, 'Initial weight measurement for player', '{\"rookie\", \"measurement\", \"physical\"}', '12-31-2025'::DATE), ('1', 'height', to_jsonb(145), '01-02-2021 00:00:00'::TIMESTAMP, '01-02-2021 10:15:00'::TIMESTAMP WITH TIME ZONE, 'coach_smith', 'growth spurt detected', true, '01-02-2021 14:30:00'::TIMESTAMP, 90, 'training_camp_system', 2, '{\"measurement_unit\": \"cm\", \"measured_by\": \"team_physician\", \"measurement_condition\": \"morning\"}'::jsonb, true, 'c3d4e5f6-a7b8-9012-cdef-3456789abcde'::UUID, to_jsonb(140), 5.0, 'Player grew 5cm since last measurement', '{\"growth\", \"measurement\", \"physical\", \"development\"}', '12-31-2025'::DATE), ('1', 'weight', to_jsonb(34), '01-03-2021 00:00:00'::TIMESTAMP, '01-03-2021 09:45:00'::TIMESTAMP WITH TIME ZONE, 'nutritionist_jones', 'weight gain program', true, '01-03-2021 11:20:00'::TIMESTAMP, 95, 'nutrition_tracking_system', 2, '{\"measurement_unit\": \"kg\", \"measured_by\": \"nutritionist\", \"measurement_condition\": \"fasting\"}'::jsonb, true, 'e32d6c02-900e-4150-a58f-a27f4325af15'::UUID, to_jsonb(30), 4.0, 'Weight gain of 4kg as part of structured nutrition program', '{\"weight_gain\", \"nutrition\", \"physical\", \"development\"}', '12-31-2025'::DATE);"], "clean_up_sql": ["DROP TABLE IF EXISTS player_stats_changes;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT player_name, event_date AS joined_date, (SELECT MIN(event_date) FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) AS left_date FROM player_movements pm WHERE event = 'Join'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_84", "db_id": "superhero", "query": "In the superhero database, I have two separate queries (q1, q2) joining across multiple tables assigning the same superheroes to different groups (I call these subgroups) based on different criteria. I get query result 1 and 2 (qr1, qr2). An item might appear in one or both, but within a result it is unique. I want to assign a new group id based on both subgroups and assigning the same group id if the subgroups share one or more items.", "issue_sql": ["with qr1(item, subgroup) AS (SELECT id, subgroup1 FROM superhero_group WHERE subgroup1 IS NOT NULL), qr2(item, subgroup) AS (SELECT id, subgroup2 FROM superhero_group WHERE subgroup2 IS NOT NULL) select item, subgroup1, subgroup2, dense_rank() over (order by item) as group from (select qr1.item, qr1.subgroup as subgroup1, qr2.subgroup as subgroup2 from qr1 full outer join qr2 on qr1.item = qr2.item) as combined"], "preprocess_sql": ["CREATE TABLE superhero_group (id INTEGER PRIMARY KEY, subgroup1 INTEGER, subgroup2 INTEGER)", "INSERT INTO superhero_group VALUES (1,1,5), (2,1,null), (3,2,null), (4,3,null), (5,3,6), (6,4,6), (7,null,7), (8,null,5), (10,null,5)"], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["select account_id, date,\n        sum(amount) OVER w as total_amount,\n        sum(balance) OVER w as total_balance,\n        count(trans_id) OVER w as total_transactions\n        from trans WINDOW w AS (PARTITION BY account_id, date);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    \n    lower_sqls = ' '.join(pred_sqls)\n    lower_sqls = lower_sqls.lower()\n    keyword_count = lower_sqls.count('partition by')\n    assert keyword_count == 1, f\"You need to just use one PARTITION definition.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_85", "db_id": "superhero", "query": "In the superhero database, a user is allowed to view details of a superhero if their user_id matches the superhero's publisher_id or if there is an entry in the 'hero_access' table where their user_id is in the 'read_acl' column (array using gin index). Both tables have about 2 million rows. The query is slow, especially when using an OR clause. Is there a way that improves the performance significantly?", "issue_sql": ["select * from superhero where publisher_id = 1 or exists (select * from hero_access f where superhero.id = f.superhero_id and '{1}' && read_acl) order by superhero.id limit 10;"], "preprocess_sql": ["CREATE TABLE hero_access (superhero_id bigint, read_acl text[], created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, access_level VARCHAR(50) DEFAULT 'standard', is_active BOOLEAN DEFAULT TRUE, access_count INTEGER DEFAULT 0, last_accessed_at TIMESTAMP WITH TIME ZONE, access_notes TEXT, metadata JSONB DEFAULT '{}'::jsonb, expiration_date DATE, access_uuid UUID DEFAULT gen_random_uuid(), access_score NUMERIC(5,2) DEFAULT 0.0, created_by VARCHAR(100) DEFAULT 'system', version INTEGER DEFAULT 1, access_tags TEXT[] DEFAULT '{}'::text[]);", "CREATE INDEX idx_hero_access_read_acl ON hero_access USING gin (read_acl);", "CREATE INDEX idx_hero_access_access_tags ON hero_access USING gin (access_tags);", "CREATE INDEX idx_hero_access_created_at ON hero_access (created_at);", "CREATE INDEX idx_hero_access_is_active ON hero_access (is_active);", "INSERT INTO hero_access (superhero_id, read_acl, created_at, updated_at, access_level, is_active, access_count, last_accessed_at, access_notes, metadata, expiration_date, access_uuid, access_score, created_by, version, access_tags) SELECT id, ARRAY['1'], CURRENT_TIMESTAMP - (random() * interval '365 days'), CURRENT_TIMESTAMP - (random() * interval '30 days'), CASE WHEN random() > 0.7 THEN 'premium' ELSE 'standard' END, TRUE, floor(random() * 100)::INTEGER, CURRENT_TIMESTAMP - (random() * interval '7 days'), CASE WHEN random() > 0.5 THEN 'Automatically granted access' ELSE 'Manual access approval' END, jsonb_build_object('source', 'system_migration', 'reason', 'initial_setup'), CURRENT_DATE + (random() * 365)::INTEGER, gen_random_uuid(), (random() * 100)::NUMERIC(5,2), CASE WHEN random() > 0.8 THEN 'admin' ELSE 'system' END, 1, ARRAY[CASE WHEN random() > 0.5 THEN 'important' ELSE 'regular' END, 'initial'] FROM superhero ORDER BY random() LIMIT 10;"], "clean_up_sql": ["DROP TABLE hero_access;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT * FROM transactions_1k WHERE Date < '2012-08-24' OR (Date = '2012-08-24' AND Time > '10:00:00') OR (Date = '2012-08-24' AND Time = '10:00:00' AND Amount < 20);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_86", "db_id": "superhero", "query": "I have two tables and I want to merge them. Table utm is a source-main table and table report contains data for utm rows. What I need: Take id and utm_ from utm table and add stats from table report with proper granulation. In table utm I've a row: (24611609, 'myTarget', 'Media', 'Social', NULL, NULL) and in table report I've 2 rows: \n(24611609, '2022-08-01', 200, 150, 15, 'myTarget', 'Media', 'Social', 'premium', 'subcribe'),\n(24611609, '2022-08-01', 25, 10, 1, 'myTarget', 'Media', 'Social', 'free', 'subcribe')\n Common is: 'myTarget', 'Media', 'Social'.\nProper granularity level is id, utm_campaign, utm_source, utm_medium, so I need to SUM and GROUP two rows by these keys. I don't know how to deal with all possible granularity combinations. My idea was just use diffrent JOINS variations and merge results with UNION. But it's really stupid, I should create > 1000 unions and joins. Any tips?", "issue_sql": ["WITH r AS (SELECT id, date_of_visit, SUM(sessions) AS sessions, SUM(pageviews) AS pageviews, SUM(bounces) AS bounce, COALESCE(utm_campaign, '') AS utm_campaign, COALESCE(utm_source, '') AS utm_source, COALESCE(utm_medium, '') AS utm_medium, COALESCE(utm_content, '') AS utm_content, COALESCE(utm_term, '') AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_source, utm_medium, utm_content, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), COALESCE(utm_source, ''), '' AS utm_medium, '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_source UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, COALESCE(utm_medium, ''), '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_medium UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, '' AS utm_medium, COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_campaign, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), COALESCE(utm_campaign, ''), '' AS utm_source, '' AS utm_medium, '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_campaign, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), COALESCE(utm_medium, ''), '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_source, utm_medium UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), '' AS utm_medium, COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_source, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, COALESCE(utm_source, ''), '' AS utm_medium, '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_source, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, COALESCE(utm_medium, ''), COALESCE(utm_content, ''), '' AS utm_term FROM report GROUP BY id, date_of_visit, utm_medium, utm_content UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, COALESCE(utm_medium, ''), '' AS utm_content, COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_medium, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, '' AS utm_medium, COALESCE(utm_content, ''), COALESCE(utm_term, '') FROM report GROUP BY id, date_of_visit, utm_content, utm_term UNION SELECT id, date_of_visit, SUM(sessions), SUM(pageviews), SUM(bounces), '' AS utm_campaign, '' AS utm_source, '' AS utm_medium, '' AS utm_content, '' AS utm_term FROM report GROUP BY id, date_of_visit) SELECT r.* FROM r JOIN utm AS u ON r.id = u.row_id AND (r.utm_campaign = u.utm_campaign OR (r.utm_campaign = '' AND u.utm_campaign IS NULL)) AND (r.utm_source = u.utm_source OR (r.utm_source = '' AND u.utm_source IS NULL)) AND (r.utm_medium = u.utm_medium OR (r.utm_medium = '' AND u.utm_medium IS NULL)) AND (r.utm_content = u.utm_content OR (r.utm_content = '' AND u.utm_content IS NULL)) AND (r.utm_term = u.utm_term OR (r.utm_term = '' AND u.utm_term IS NULL)) WHERE 'NA' NOT IN (r.utm_campaign, r.utm_source, r.utm_medium, r.utm_content, r.utm_term);"], "preprocess_sql": ["CREATE TABLE utm (row_id int8 NOT NULL, utm_campaign text NULL, utm_source text NULL, utm_medium text NULL, utm_content text NULL, utm_term text NULL);", "INSERT INTO utm (row_id, utm_campaign, utm_source, utm_medium, utm_content, utm_term) VALUES (24611609, 'myTarget', 'Media', 'Social', NULL, NULL), (28573041, 'shop_ smartfony', 'my_beeline', 'banner', NULL, NULL), (28573041, 'Beeline_uppers_2022', NULL, NULL, NULL, NULL), (24611609, 'campaign', 'source', 'medium', 'content', 'term');", "CREATE TABLE report (id int8 NOT NULL, date_of_visit date NOT NULL, sessions numeric NULL, pageviews numeric NULL, bounces numeric NULL, utm_campaign text NULL, utm_source text NULL, utm_medium text NULL, utm_content text NULL, utm_term text NULL);", "INSERT INTO report (id, date_of_visit, sessions, pageviews, bounces, utm_campaign, utm_source, utm_medium, utm_content, utm_term) VALUES (24611609, '2022-08-01', 200, 150, 15, 'myTarget', 'Media', 'Social', 'premium', 'subcribe'), (24611609, '2022-08-01', 25, 10, 1, 'myTarget', 'Media', 'Social', 'free', 'subcribe'), (28573041, '2022-08-01', 900, 885, 34, 'shop_ smartfony', 'my_beeline', 'banner', NULL, NULL), (28573041, '2022-08-01', 1000, 900, 10, 'Beeline_uppers_2022', NULL, NULL, NULL, NULL), (21781121, '2022-08-01', 500, 50, 5, 'vodafone', 'google', NULL, NULL, NULL), (21781121, '2022-08-01', 55, 50, 3, 'vodafone', 'google', 'youtube', NULL, NULL), (24611609, '2022-08-01', 1, 1, 0, 'campaign', 'source', 'medium', 'content', 'term');"], "clean_up_sql": ["DROP TABLE utm;", "DROP TABLE report"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_87", "db_id": "card_games", "query": "I have a local PostgreSQL database named card_games, with a table called cards that contains many columns. One of these columns is named text, which stores details about each card's abilities or effects. Sometimes, the text field contains one or more curly-brace expressions indicating costs or actions. For example:\n\"{{T}}: Target creature gains haste until end of turn.\"\n\"{{1}}{{W}}: Prevent the next 2 damage that would be dealt to any target.\"\n\"{{2}}{{U}}{{U}}: Draw two cards, then discard a card.\"\n\"Flying  (This creature can't be blocked except by creatures with flying or reach) {{G}}{{1}}\"\n\nI want to extract all the bracketed tokens (i.e., everything in {{...}}) from the text field, potentially returning them in a separate column or combining them into a list. Additionally, some rows may contain multiple occurrences of these curly-brace expressions, separated by normal text.\n\nHow can I write a SQL query (using PostgreSQL features like regexp_matches, substring, or similar) to:\n\t1.\tFind all bracketed tokens within each row's text column,\n\t2.\tReturn them in a format where I can see each token (e.g., {{T}}, {{1}}{{W}}, etc.) separately or as an array,\n\t3.\tHandle rows that have multiple bracketed tokens or none at all,\n\t4.\tOptionally count how many curly-brace expressions appear per row?\n\nI'm specifically looking for a solution that runs purely in SQL (e.g. using regexp_replace, regexp_matches, or other built-in PostgreSQL string functions). How should I structure my query to achieve this? Are there any caveats with capturing multiple matches from the same row in PostgreSQL?", "issue_sql": ["SELECT\n    id,\n    text,\n    REGEXP_MATCHES(\n        text,\n        '\\{.*?\\}',\n        'g'\n    ) AS bracketed_tokens\nFROM cards;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["select session_id, post_id, max(case when event_name='view_start' then ts end) start_time, max(case when event_name='view_end' then ts end) end_time, case when max(case when event_name='view_end' then ts end) - max(case when event_name='view_start' then ts end) > 3 and max(view_perc) > 0.8 then 'yes' else 'no' end as has_impact from (select *, row_number() over (partition by session_id, post_id order by ts) rn from view_logs) t group by session_id, post_id, (rn-1)/ 2 order by session_id, post_id, min(ts);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_88", "db_id": "superhero", "query": "I am porting the queries from InfluxDB to TimescaleDB (PostgreSQL). I am currently stuck with the equivalent of InfluxDB's TOP and BOTTOM functions. Specifically, I need to find the top 5 and bottom 5 races within each gender_id group, ranked by the number of superheroes. If multiple races have the same count, they should share the same rank. In InfluxDB, I would use TOP(count(race_id), 5) in each group with the same gender_id. How can I achieve this in PostgreSQL?", "issue_sql": ["SELECT race_id, top(count(*), 5) as cnt FROM superhero group by gender_id"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH deleted_rows AS (DELETE FROM superhero WHERE id = 999 RETURNING 1) SELECT COALESCE((SELECT * FROM deleted_rows), 0)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 1, f'Expected 1 row, but found {len(pred_sqls_result)} rows'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_89", "db_id": "card_games", "query": "I have this SQL query to get the top 3 rulings for each uuid in the given list: 6d268c95-c176-5766-9a46-c14f739aba1c, 56f4935b-f6c5-59b9-88bf-9bcce20247ce, 8dfc67e9-8323-5d1f-9e25-9f9394abd5a0, 5ac794d2-4c66-5332-afb1-54b24bc11823, 60f49caf-3583-5f85-b4b3-08dca73a8628, ranked by the number of rulings. However, my current query is not working correctly and is not returning the expected results.", "issue_sql": ["SELECT rulings.id, rulings.date, rulings.text, rulings.uuid FROM rulings WHERE rulings.uuid IN ('6d268c95-c176-5766-9a46-c14f739aba1c', '56f4935b-f6c5-59b9-88bf-9bcce20247ce', '8dfc67e9-8323-5d1f-9e25-9f9394abd5a0', '5ac794d2-4c66-5332-afb1-54b24bc11823', '60f49caf-3583-5f85-b4b3-08dca73a8628') GROUP BY rulings.id ORDER BY rulings.id LIMIT 3"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement LANGUAGE plpgsql AS $$ BEGIN IF s IS NULL AND v IS NULL THEN RETURN NULL; ELSIF v IS NULL THEN RETURN s; ELSE RETURN v; END IF; END; $$;", "CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);", "SELECT id, str, val, GapFill(val) OVER (ORDER BY id ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS valx FROM example;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_90", "db_id": "formula_1", "query": "I am analyzing Formula 1 race data to rank drivers based on their total points across multiple races. Each driver earns points for their position in each race. I want to retain the discrete race scoring while also ranking the drivers in the series. For example, considering a sub-query that returns this:\\n| Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | Lewis       | 50           | 20          | 103     |\\n| 2         | Nico        | 40           | 20          | 101     |\\n| 2         | Nico        | 40           | 20          | 102     |\\nYou can see Lewis has 50 points, as he won 10, 20, and 20 points in three races. Nico has 40 points, as he won 20 and 20 points in two races.\\nNow for the ranking, what I'd like is:\\n| Place     | Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | 1         | Lewis       | 50           | 20          | 103     |\\n| 2         | 2         | Nico        | 40           | 20          | 101     |\\n| 2         | 2         | Nico        | 40           | 20          | 102     |\\nBut if I use `rank()` and `order by Total Points`, I get:\\n| Place     | Driver ID | Driver Name | Total Points | Race Points | Race ID |\\n| --------- | --------- | ----------- | ------------ | ----------- | ------- |\\n| 1         | 1         | Lewis       | 50           | 10          | 101     |\\n| 1         | 1         | Lewis       | 50           | 20          | 102     |\\n| 1         | 1         | Lewis       | 50           | 20          | 103     |\\n| 4         | 2         | Nico        | 40           | 20          | 101     |\\n| 4         | 2         | Nico        | 40           | 20          | 102     |\\nWhich makes sense, since there are three 'ties' at 50 points.\\n`dense_rank()` solves this problem, but if there are legitimate ties across different drivers, I want there to be gaps in the rank (e.g if Lewis and Nico both had 50 points, they are both the first place and the next driver would be in third place, no second).\\nThe easiest way to solve this I think would be to issue two queries, one with the 'duplicate' drivers eliminated, and then a second one where I can retain the individual race data, which I need for the points break down display.\\nI can also probably, given enough effort, think of a way to do this in a single query, but I'm wondering if I'm not just missing something really obvious that could accomplish this in a single, relatively simple query.\\nAny suggestions?", "issue_sql": ["select rank() over (order by total_points desc) as place, id, name, total_points, race_points, raceId from racers"], "preprocess_sql": ["CREATE TABLE racers (id integer, name text, total_points integer, race_points integer, raceId integer);", "INSERT INTO racers (id, name, total_points, race_points, raceId) VALUES (1, 'Lewis', 50, 10, 123), (1, 'Lewis', 50, 20, 234), (1, 'Lewis', 50, 20, 345), (2, 'Nico', 40, 20, 123), (2, 'Nico', 40, 20, 234), (3, 'Dave', 50, 30, 123), (3, 'Dave', 50, 20, 234);"], "clean_up_sql": ["DROP TABLE racers;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 0), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / NULLIF(SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 0), 2) AS pct_change_month_prior FROM transactions;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n                                                                                  \n                                \n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_91", "db_id": "california_schools", "query": "In the context of the 'california_schools' database, we have three tables: 'schools', 'satscores', and 'frpm'. The 'schools' table contains detailed information about each school, the 'satscores' table contains SAT scores for each school, and the 'frpm' table contains information about the free and reduced-price meal eligibility for each school. We want to determine for each school in the 'satscores' table, whether there is any corresponding entry in the 'frpm' table for the same school. The user has written a query that checks for the existence of such entries but believes it is inefficient as it traverses the 'frpm' table twice. Is there a better way?", "issue_sql": ["SELECT s.cds, true FROM satscores s WHERE EXISTS (SELECT 1 FROM frpm f WHERE s.cds = f.cdscode) UNION SELECT s.cds, false FROM satscores s WHERE NOT EXISTS (SELECT 1 FROM frpm f WHERE s.cds = f.cdscode) ORDER BY cds"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT name, convertedManaCost, ROUND(avg(convertedManaCost::numeric) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW), 2) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_92", "db_id": "card_games", "query": "In the card_games database, we have a table named 'orders' that records the purchase history of customers. Each entry in the 'orders' table includes the month and year of the purchase, the order ID, and the customer ID. We want to analyze the purchase behavior of our customers to identify repeat customers. A repeat customer is defined as a customer who has made at least one purchase in the past and makes another purchase in a subsequent month. We aim to count the number of repeat customers per month. For example, if a customer made their first purchase in January 2022, then any purchase they make in February 2022 or later should be counted as a repeat purchase in that respective month. The user attempted to write a query to count repeat customers but encountered issues with the query logic, which only counted customers who made more than one purchase in the same month rather than those who made a purchase in a subsequent month after their first purchase.", "issue_sql": ["SELECT month_year, COUNT(DISTINCT customer_id) FROM orders GROUP BY month_year HAVING COUNT(order_id) > 1"], "preprocess_sql": ["CREATE TABLE orders (month_year text, order_id text, customer_id bigint);", "INSERT INTO orders (month_year, order_id, customer_id) VALUES ('2016-04', '0001', 24662), ('2016-05', '0002', 24662), ('2016-05', '0002', 24662), ('2016-07', '0003', 24662), ('2016-07', '0003', 24662), ('2016-07', '0004', 24662), ('2016-07', '0004', 24662), ('2016-08', '0005', 24662), ('2016-08', '0006', 24662), ('2016-08', '0007', 24662), ('2016-08', '0008', 24662), ('2016-08', '0009', 24662), ('2016-08', '0010', 11372), ('2016-08', '0011', 11372), ('2016-09', '0012', 24662), ('2016-10', '0013', 24662), ('2016-10', '0014', 11372), ('2016-11', '0015', 24662), ('2016-11', '0016', 11372), ('2016-12', '0017', 11372), ('2017-01', '0018', 11372), ('2017-01', '0019', 11372);"], "clean_up_sql": ["DROP TABLE orders;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH approved_counts AS (SELECT hero_id, attribute_id, COUNT(CASE WHEN (value->>'approved')::boolean THEN 1 END) AS approved_cnt FROM hero_attribute a CROSS JOIN LATERAL jsonb_array_elements(a.ss) AS value GROUP BY hero_id, attribute_id) SELECT a.hero_id, a.attribute_id, jsonb_array_length(a.ss) AS ss_cnt, ac.approved_cnt FROM hero_attribute a JOIN approved_counts ac ON a.hero_id = ac.hero_id AND a.attribute_id = ac.attribute_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_93", "db_id": "european_football_2", "query": "In the database european_football_2, there is a table named player_movements that records the movements of football players joining and leaving teams. Each row in the table includes the player's name, the event (either 'Join' or 'Leave'), and the timestamp of the event. The goal is to transform this data into a format that shows the periods during which each player was part of a team. Specifically, we want to create a table that lists each player, the date they joined a team, and the date they left the team. This will allow us to easily query the data to determine if a player was part of a team on a specific date. For example, we should be able to find out if Player A was on Team X on a given date by using a query like: SELECT * FROM transformed_table WHERE player_name = 'Player A' AND '2022-01-01' BETWEEN joined_date AND left_date. However, the user attempted to write a query that did not produce the desired results.", "issue_sql": ["SELECT player_name, event_date as join_date, (SELECT event_date FROM player_movements pm1 WHERE pm1.player_name = pm.player_name AND pm1.event = 'Leave' AND pm1.event_date > pm.event_date) as leave_date FROM player_movements pm WHERE event = 'Join'"], "preprocess_sql": ["CREATE TABLE player_movements (player_name VARCHAR(100), event VARCHAR(10), event_date DATE);", "INSERT INTO player_movements (player_name, event, event_date) VALUES ('Player A', 'Join', '2022-01-01'), ('Player A', 'Leave', '2022-01-02'), ('Player A', 'Join', '2022-01-31'), ('Player A', 'Leave', '2022-02-01'), ('Player B', 'Join', '2022-01-31'), ('Player B', 'Leave', '2022-02-01');"], "clean_up_sql": ["DROP TABLE player_movements;"], "category": "Query", "efficiency": false, "sol_sql": ["select set_translations.language,\n    CASE\n        WHEN EXISTS (select *\n                    from foreign_data\n                    where foreign_data.language = set_translations.language)\n        THEN 'common'\n        ELSE 'not common'\n    END\n    from\n    set_translations"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_94", "db_id": "european_football_2", "query": "We have a table named 'player_attributes' that records various performance metrics for players. Each record includes the following metrics: gk_diving, gk_handling, gk_kicking, gk_positioning, gk_reflexes. For example, if a player has gk_diving = 6, gk_handling = 10, gk_kicking = 11, gk_positioning = 8, gk_reflexes = 8, the average after removing the highest (11) and lowest (6) amounts would be (8 + 8 + 10) / 3 = 8.6667. The following is the method I use. It is very bloated and the execution time is too long. Is there a neat way to achieve my needs?", "issue_sql": ["SELECT id, (SUM(gk) - MAX(gk) - MIN(gk)) / (COUNT(gk) - 2) AS adjusted_average FROM (SELECT id, gk_diving AS gk FROM player_attributes UNION ALL SELECT id, gk_handling AS gk FROM player_attributes UNION ALL SELECT id, gk_kicking AS gk FROM player_attributes UNION ALL SELECT id, gk_positioning AS gk FROM player_attributes UNION ALL SELECT id, gk_reflexes AS gk FROM player_attributes) subquery GROUP BY id ORDER BY id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["DO $$\n    DECLARE\n        i integer;\n        j integer;\n        k text;\n    BEGIN\n        FOR i, j, k IN\n            SELECT unnest(ARRAY[11, 20]::integer[]),\n                   unnest(ARRAY[505942, 155782]::integer[]),\n                   unnest(ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[])\n        LOOP\n            UPDATE Player_Attributes\n            SET overall_rating = i\n            WHERE player_api_id = j\n            AND date = k;\n        END LOOP;\n    END $$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 505942 AND date = '2016-02-18 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    test_pred_query_result_2 = execute_queries(\n        [\"SELECT * FROM Player_Attributes WHERE player_api_id = 155782 AND date = '2015-10-16 00:00:00';\"], \n        'european_football_2', conn\n    )[0]\n    \n    assert len(test_pred_query_result_1) == 1, 'There should be exactly one record for player_api_id = 505942 and date = 2016-02-18.'\n    assert test_pred_query_result_1[0][4] == 11, 'Player 505942 overall_rating should be updated to 11.'\n    \n    assert len(test_pred_query_result_2) == 1, 'There should be exactly one record for player_api_id = 155782 and date = 2015-10-16.'\n    assert test_pred_query_result_2[0][4] == 20, 'Player 155782 overall_rating should be updated to 20.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_95", "db_id": "financial", "query": "In the financial database, there is a table named 'trans' which records all transactions made by clients. Each transaction has a unique transaction ID, the account ID associated with the transaction, the date of the transaction, the type of transaction (credit or debit), the operation performed, the amount involved, the balance after the transaction, and additional details such as the bank and account of the partner. The table has more than 1000000 rows and is growing rapidly. I need to extract the most recent transaction (based on the transaction date) for each account ID. I also tried to avoid using a subquery but did not notice a significant difference. Any idea how I could optimize this query?", "issue_sql": ["DROP INDEX IF EXISTS idx_a;", "SELECT DISTINCT ON (t.account_id) t.trans_id, t.account_id, t.date, t.type, t.amount, t.balance FROM trans t ORDER BY t.account_id, t.date DESC, trans_id;"], "preprocess_sql": [], "clean_up_sql": ["DROP INDEX IF EXISTS idx_a;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected at least one result with fastestLapTime = 1:35.405, but found none.'\n    assert all(row[0] is not None for row in test_pred_query_result_1), 'Expected all resultIds to be valid, but found NULL values.'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = execute_queries([\"SELECT resultId FROM results WHERE fastestLapTime = '1:35.405';\"], 'formula_1', conn)[0]\n    assert len(test_pred_query_result_2) == 1, f'Expected exactly 1 result with fastestLapTime = 1:35.405, but found {len(test_pred_query_result_2)} results.'\n    assert test_pred_query_result_2[0][0] == 23, f'Expected resultId to be 23, but found {test_pred_query_result_2[0][0]}.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_96", "db_id": "financial", "query": "A financial analyst is tasked with analyzing transaction data to summarize daily financial activities for each client.     They need to calculate the total amount of transactions, total balance changes, and the number of transactions for each client,     partitioned by date. The analyst writes a query using the same window function with the same partition definition for multiple result columns     but encounters redundancy. The use wants to use one PARTITION definition for multiple window function calls.", "issue_sql": ["select account_id, date,\n        sum(amount) OVER (PARTITION BY account_id, date) as total_amount,\n        sum(balance) OVER (PARTITION BY account_id, date) as total_balance,\n        count(trans_id) OVER (PARTITION BY account_id, date) as total_transactions\n        from trans"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT raceId,\n       jsonb_object_agg(COALESCE(position::text, 'Unknown') , COALESCE(cnt::text, '0')) AS json_count\nFROM (\n    SELECT raceId,\n           position,\n           COUNT(*) AS cnt\n    FROM results\n    GROUP BY raceId, position\n) AS aggregated_counts\nGROUP BY raceId"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 1;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_1[0][0] == 1, f'Expected count of position 1 in race 19 to be 1, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 2;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_2[0][0] == 1, f'Expected count of position 2 in race 19 to be 1, but found {test_pred_query_result_2[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT COUNT(*) AS total FROM results WHERE raceId = 19 AND position = 3;\"], 'formula_1', conn)[0]\n    assert test_pred_query_result_3[0][0] == 1, f'Expected count of position 3 in race 19 to be 1, but found {test_pred_query_result_3[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    global pred_query_result\n    assert len(pred_query_result) > 0, 'Expected at least one row in the result, but found none.'\n    assert isinstance(pred_query_result[0][1], dict), 'Expected json_count to be a dictionary, but found something else.'\n    assert '1' in pred_query_result[0][1], 'Expected position 1 to be included in the json_count for raceId 1.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_97", "db_id": "debit_card_specializing", "query": "I need to retrieve transactions from the `transactions_1k` table based on     a lexicographic ordering on multiple columns, where the direction of the sort on some     columns is reversed. Specifically, I want to find transactions that occurred before     a certain date, or on the same date but after a certain time, or on the same date and time     but with a transaction amount less than a specified value. For example, I want to find     transactions that occurred before '2012-08-24', or on '2012-08-24' but after '10:00:00',     or on '2012-08-24' at '10:00:00' but with an amount less than 20.     Is there a straightforward way to do this using tuples or a similar approach in PostgreSQL?     Note that I cannot rely on tricks that apply only to integers, as some columns are of type date and text.", "issue_sql": ["SELECT * FROM transactions_1k WHERE (Date, Time, Amount) < ('2012-08-24', '10:00:00', 20);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT * FROM Match WHERE (match_api_id, date, id) < (492473, '2008-08-17 00:00:00', 1) ORDER BY match_api_id DESC, date DESC, id DESC LIMIT 3;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n                                  \n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) == 3, f'Expected 3 rows, but found {len(test_pred_query_result_1)} rows'\n    assert test_pred_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_pred_query_result_1[0][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n                                \n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) == 3, f'Expected 3 rows, but found {len(test_sol_query_result_1)} rows'\n    assert test_sol_query_result_1[0][0] == 19855, f'Expected match_api_id to be 19855, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 19854, f'Expected match_api_id to be 19854, but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[2][0] == 19853, f'Expected match_api_id to be 19853, but found {test_sol_query_result_1[0][0]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_98", "db_id": "financial", "query": "A financial analyst is trying to generate a report that includes the client's name, the loan details, and the account details for loans that were issued in the year 1996. The analyst has written a query to join the `client`, `disp`, `account`, and `loan` tables. However, the query is failing with an error related to a missing FROM-clause entry.     The analyst needs to retrieve the client's name, loan amount, loan duration, and account creation date for loans issued in 1996.", "issue_sql": ["SELECT client.gender, loan.amount, loan.duration, account.date FROM loan JOIN account ON loan.account_id = account.account_id JOIN client ON disp.client_id = client.client_id JOIN disp ON account.account_id = disp.account_id WHERE loan.date BETWEEN '1996-01-01' AND '1996-12-31';"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT s.School FROM schools s WHERE s.County IN ('Alameda', 'Contra Costa')\nGROUP BY s.School HAVING COUNT(DISTINCT s.County) = 2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n                                  \n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_pred_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_pred_query_result_1[1][0]}'\n    assert test_pred_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_pred_query_result_1[2][0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n                                \n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, f'Expected to have rows, but found none'\n    assert test_sol_query_result_1[0][0] == 'Alvarado Elementary', f'Expected first school to be \"Alvarado Elementary\", but found {test_sol_query_result_1[0][0]}'\n    assert test_sol_query_result_1[1][0] == 'Bella Vista Elementary', f'Expected second school to be \"Bella Vista Elementary\", but found {test_sol_query_result_1[1][0]}'\n    assert test_sol_query_result_1[2][0] == 'Bidwell Elementary', f'Expected third school to be \"Bidwell Elementary\", but found {test_sol_query_result_1[2][0]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_99", "db_id": "codebase_community", "query": "We are analyzing user engagement with posts on a community forum. Specifically, we want to determine if a user's view of a post had a significant impact based on the duration of the view and the percentage of the post viewed. The 'has_impact' field should be set to true if the difference between the view end time and the view start time is greater than 3 seconds and the view percentage is greater than 0.8, otherwise it should be false. We have a table 'view_logs' that logs each view event with the session_id, post_id, timestamp (ts), event_name (either 'view_start' or 'view_end'), and view percentage (view_perc). We need to populate the 'has_impact' field based on these criteria.", "issue_sql": ["with cte as (select pv1.session_id, pv1.post_id, pv2.view_perc, pv1.ts as start_time, min(pv2.ts) as end_time from view_logs pv1 join view_logs pv2 on pv1.session_id = pv2.session_id and pv1.post_id = pv2.post_id and pv1.event_name <> pv2.event_name and pv1.ts < pv2.ts group by pv1.session_id, pv1.post_id, pv2.view_perc, pv1.ts) select session_id, post_id, start_time, end_time, case when (end_time - start_time > 3  and view_perc > 0.8 )then 'yes' else 'no' end as has_meaningful_view from cte;"], "preprocess_sql": ["create table view_logs (session_id varchar(10), post_id int, ts int, event_name varchar(50), view_perc float);", "insert into view_logs(session_id, post_id, ts, event_name, view_perc) values ('m1', 1000, 1524600, 'view_start', null), ('m1', 1000, 1524602, 'view_end', 0.85), ('m1', 1000, 1524650, 'view_start', null), ('m1', 1000, 1524654, 'view_end', 0.9), ('m1', 2000, 1524700, 'view_start', null), ('m1', 2000, 1524707, 'view_end', 0.3), ('m1', 2000, 1524710, 'view_start', null), ('m1', 2000, 1524713, 'view_end', 0.9);"], "clean_up_sql": ["DROP TABLE IF EXISTS view_logs;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT DISTINCT ON (name) raceid, name, date FROM races ORDER BY name, date DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_100", "db_id": "superhero", "query": "In the superhero database, is it possible to return a value from a DELETE statement in PostgreSQL when no rows were deleted? For example, if we attempt to delete a superhero with an ID that does not exist, we want to return a default value indicating that no rows were deleted. We tried using the RETURNING clause with a constant value, but it returned NULL instead of the desired default value.", "issue_sql": ["delete from superhero where id = 999 returning 1"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) CROSS JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'european_football_2', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'european_football_2', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_101", "db_id": "superhero", "query": "A data analyst is working with the superhero database and needs to perform a forward fill operation on the 'height_cm' and 'weight_kg' columns of the 'superhero' table. The analyst wants to create a PL/pgSQL function that mimics the behavior of the pandas 'ffill' function, which fills missing values with the last known non-null value. Here we use a table example(row_num int, id int, str text, val int) to test the functionality. We need to get the result of ffill(column val). The analyst has attempted to create a function but encountered syntax errors and incorrect results. The analyst needs a function that can handle forward filling for any specified column in the 'superhero' table, ordered by the 'id' column and partitioned by the 'publisher_id'.", "issue_sql": ["CREATE OR REPLACE FUNCTION GapFillInternal(s anyelement, v anyelement) RETURNS anyelement AS $$ DECLARE temp alias for $0; BEGIN F v IS NULL AND s NOTNULL THEN temp := s; ELSIF s IS NULL AND v NOTNULL THEN temp := v; ELSIF s NOTNULL AND v NOTNULL THEN temp := v; ELSE temp := NULL; END;END; $$ LANGUAGE PLPGSQL;CREATE AGGREGATE GapFill(anyelement) (SFUNC=GapFillInternal, STYPE=anyelement);SELECT id, publisher_id, height_cm, weight_kg, GapFill(height_cm) OVER (PARTITION BY publisher_id ORDER BY id) AS height_cm_filled, GapFill(weight_kg) OVER (PARTITION BY publisher_id ORDER BY id) AS weight_kg_filled FROM superhero;"], "preprocess_sql": ["CREATE TABLE example(id int, str text, val integer, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, version_number INTEGER DEFAULT 1, metadata JSONB DEFAULT '{}'::jsonb, description TEXT DEFAULT '', priority INTEGER DEFAULT 5, tags TEXT[] DEFAULT ARRAY[]::TEXT[], status VARCHAR(50) DEFAULT 'pending', last_accessed_by VARCHAR(100) DEFAULT 'system', external_reference_id UUID DEFAULT gen_random_uuid(), processing_attempts INTEGER DEFAULT 0);", "INSERT INTO example VALUES (1, 'a', NULL, '2023-01-01T10:00:00Z', '2023-01-01T10:00:00Z', true, 1, '{\"source\": \"manual\"}'::jsonb, 'First example record', 3, ARRAY['test', 'sample'], 'active', 'admin', 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', 0), (1, NULL, 1, '2023-01-01T10:05:00Z', '2023-01-01T10:05:00Z', true, 1, '{\"source\": \"import\"}'::jsonb, 'Second example record', 2, ARRAY['imported'], 'processed', 'system', 'b2c3d4e5-f6a7-8901-bcde-f12345678901', 1), (2, 'b', 2, '2023-01-01T10:10:00Z', '2023-01-01T10:10:00Z', true, 1, '{\"source\": \"api\"}'::jsonb, 'Third example record', 1, ARRAY['api', 'test'], 'completed', 'api_user', 'c3d4e5f6-a7b8-9012-cdef-123456789012', 0), (2, NULL, NULL, '2023-01-01T10:15:00Z', '2023-01-01T10:15:00Z', false, 2, '{\"source\": \"manual\", \"error\": true}'::jsonb, 'Fourth example record with null values', 4, ARRAY['test', 'null_values'], 'error', 'admin', '20f62c58-a200-4a5f-9e0f-3fb6f2985da2', 2)"], "clean_up_sql": ["DROP TABLE IF EXISTS example;", "DROP FUNCTION IF EXISTS GapFillInternal(anyelement, anyelement);", "DROP AGGREGATE IF EXISTS GapFill(anyelement);"], "category": "Management", "efficiency": false, "sol_sql": ["WITH RankedFRPM AS (\n    SELECT *,\n           ROW_NUMBER() OVER (\n               PARTITION BY \"County Code\"\n               ORDER BY \"Enrollment (K-12)\" DESC NULLS LAST\n           ) AS rn\n    FROM frpm\n    WHERE \"County Code\" IS NOT NULL AND \"Enrollment (K-12)\" IS NOT NULL\n)\nSELECT *\nFROM RankedFRPM\nWHERE rn = 2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'formula_1', conn)    \n    sol_sqls_result = execute_queries(sol_sqls, 'formula_1', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_102", "db_id": "california_schools", "query": "In the context of the 'california_schools' database, we need to update the 'table_A' table to deactivate certain items based on their associated records in table 'table_B'. Specifically, we want to find all items in table_A whose associated record in table_B has the 'deleted' set to 'true'. From this set of results, we need to get the 'parent_id' of these items. Then, for any item in the 'table_A' table whose 'id' is part of the 'parent_id' column from the previous result set, we need to check if their 'is_active' is 'true' and if so, make it 'false'. This operation is intended to deactivate items that are part of deleted status but the query gets stuck loading endlessly.", "issue_sql": ["UPDATE table_A A SET is_active = false FROM table_A WHERE A.parent_id IS NULL AND A.is_active = true AND A.id = ANY (SELECT (B.parent_id) FROM table_A B INNER JOIN table_B ON table_A.foreign_id = table_B.id WHERE table_B.deleted = true) RETURNING *;"], "preprocess_sql": ["create table table_B (id int primary key, deleted boolean);", "create table table_A (id serial primary key, parent_id int, is_active boolean default true, foreign_id int, foreign key (foreign_id) references table_B(id));", "insert into table_B (id, deleted) values (1, false), (2, true), (5, true), (3, false), (4, false)", "insert into table_A (parent_id, foreign_id) values (null, 1), (1, 2), (1, 5), (null, 3), (3, 4)"], "clean_up_sql": ["DROP TABLE table_A;", "DROP TABLE table_B;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH RECURSIVE expanded AS (\n    SELECT\n        name,\n        price_per_unit,\n        ROW_NUMBER() OVER (ORDER BY price_per_unit, name) AS row_number\n    FROM race_materials\n    CROSS JOIN generate_series(1, quantity)\n),\npurchased (name, remaining, next_row_number) AS (\n    SELECT\n        NULL::TEXT AS name,\n        100 AS remaining,\n        1::BIGINT AS next_row_number\n    UNION ALL\n    SELECT\n        expanded.name,\n        purchased.remaining - expanded.price_per_unit,\n        expanded.row_number + 1\n    FROM purchased\n    JOIN expanded\n        ON expanded.row_number = purchased.next_row_number\n    WHERE expanded.price_per_unit <= purchased.remaining\n)\nSELECT COUNT(name) AS qty\nFROM purchased;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert int(pred_query_result[0][0]) == 32, f\"Value returned {int(pred_query_result[0][0])} but expected 32\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_103", "db_id": "toxicology", "query": "We are analyzing the sales data of a chemical supply company stored in the 'transactions' table. The columns are id (customer id), amount (amount spent by customer), and timestamp (time of purchase). Assume that today is '2022-01-27'. We need to query:\\n- Yesterday's revenue: sum of amount.\\n- Percent difference from 8 days ago's revenue to yesterday's revenue.\\n- Month-to-date (MTD) revenue.\\n- Percent difference from last month's MTD to this month's MTD.\\nWhen calculating the percentage, round the result to two decimal places.\nGiven the sample data:\\n| id | amount | timestamp |\\n| -- | ------ | --------  |\\n| 1  | 50     | 2021-12-01|\\n| 2  | 60     | 2021-12-02|\\n| 3  | 70     | 2021-11-05|\\n| 4  | 80     | 2022-01-26|\\n| 5  | 90     | 2022-01-25|\\n| 6  | 20     | 2022-01-26|\\n| 7  | 80     | 2022-01-19|\\nThe expected output is:\\n| yesterday_revenue | pct_change_week_ago | mtd | pct_change_month_prior|\\n| -------- | -------------- | --- | --- |\\n| 100   | 0.25          | 270 | 0.50|\\nHowever, the user's query resulted in incorrect percent change columns. Here is the problematic SQL statement:", "issue_sql": ["SELECT SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 1 THEN amount ELSE NULL END) AS yesterday_revenue, ROUND((SUM(CASE WHEN timestamp::date > '2022-01-27'::date - 1 THEN amount ELSE NULL END) - SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END)) / SUM(CASE WHEN timestamp::date = '2022-01-27'::date - 8 THEN amount ELSE NULL END), 2) AS pct_change_week_ago, SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) AS mtd, ROUND((SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) THEN amount ELSE NULL END) - SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END)) / SUM(CASE WHEN date_trunc('month', timestamp) = date_trunc('month', '2022-01-27'::date - 1) - interval '1 month' AND date_part('day', timestamp) <= date_part('day', '2022-01-27'::date - 1) THEN amount ELSE NULL END), 2) AS pct_change_month_prior FROM transactions;"], "preprocess_sql": ["CREATE TABLE transactions (id int, amount numeric, timestamp date);", "INSERT INTO transactions (id, amount, timestamp) VALUES (1, 50, '2021-12-01'), (2, 60, '2021-12-02'), (3, 70, '2021-11-05'), (4, 80, '2022-01-26'), (5, 90, '2022-01-25'), (6, 20, '2022-01-26'), (7, 80, '2022-01-19');"], "clean_up_sql": ["DROP TABLE transactions;"], "category": "Personalization", "efficiency": false, "sol_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id, STRING_AGG(overall_rating::TEXT, ',') AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT player_api_id FROM historical_rating WHERE player_fifa_api_id = 227760;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 582500, f'Expected player_api_id to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT grouped_rating FROM historical_rating WHERE player_api_id = 306507;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == '64,64,64,64,64,63,63,63,63,64,64,64,62,62', f'Expected grouped_rating to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_104", "db_id": "card_games", "query": "I am analyzing the average converted mana cost of cards over a rolling window of 8 previous cards for each card in the 'cards' table. I need to round the nine_day_avg to two decimal places. However, I am having trouble placing the ROUND function correctly in the query. The query below does not produce the desired result. Can you help me correct it?", "issue_sql": ["SELECT name, convertedManaCost, avg(convertedManaCost) OVER(ORDER BY id ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS nine_card_avg FROM cards WHERE name LIKE 'A%' ORDER BY id DESC"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score\nFROM (\n  SELECT p.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE p.score >= 20\n  UNION ALL\n  SELECT c.*\n  FROM posts p\n  JOIN posts c ON p.acceptedanswerid = c.id\n  WHERE NOT p.score >= 20 AND c.score >= 20\n) x;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_105", "db_id": "superhero", "query": "In the superhero database, each superhero has a set of attributes stored in a B column named 'attributes' within the 'hero_attribute' table. Each attribute object contains an 'ss_id' and an 'approved' status indicating whether the attribute is officially recognized by the superhero community. For example, a single record might look like this:\\n{\\", "issue_sql": ["SELECT hero_id, attribute_id, jsonb_array_length(a.ss) AS ss_cnt, jsonb_array_length(CASE WHEN a.ss -> 'approved' = 'true' THEN a.ss END) AS approved_cnt FROM hero_attribute a WHERE a.hero_id IN (1, 2);"], "preprocess_sql": ["ALTER TABLE hero_attribute ADD COLUMN ss JSONB;", "UPDATE hero_attribute SET ss = '[{\"ss_id\": 1, \"approved\": true}, {\"ss_id\": 2, \"approved\": false}]' WHERE hero_id = 1;", "UPDATE hero_attribute SET ss = '[{\"ss_id\": 1, \"approved\": true}, {\"ss_id\": 2, \"approved\": true}]' WHERE hero_id = 2;"], "clean_up_sql": ["ALTER TABLE hero_attribute DROP COLUMN ss;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH card_activity AS (\n  SELECT\n    to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date,\n    to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date,\n    dp.set_name,\n    dp.set_code,\n    fe.set_key\n  FROM fact_collection fe\n  INNER JOIN dim_set dp ON fe.set_key = dp.set_key\n)\nSELECT\n  date_trunc('month', month_series) AS month,\n  COUNT(DISTINCT fe.card_key) AS existing_cards,\n  sa.set_name\nFROM (\n  SELECT\n    generate_series(\n      (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection),\n      '2100-12-31',\n      INTERVAL '1 month'\n    ) AS month_series\n) AS months\nLEFT JOIN card_activity sa ON\n  sa.start_date <= month_series AND\n  (sa.end_date IS NULL OR sa.end_date >= month_series)\nLEFT JOIN fact_collection fe ON\n  fe.set_key = sa.set_key\n  AND fe.start_date_key <= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 31\n  AND (fe.end_date_key IS NULL OR fe.end_date_key >= EXTRACT(YEAR FROM month_series) * 10000 + EXTRACT(MONTH FROM month_series) * 100 + 1)\nGROUP BY month, sa.set_name\nLIMIT 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_106", "db_id": "financial", "query": "I am trying to speed up a PostgreSQL query to find previous transactions on the same day of the year from the 'trans' table. My current query is as follows:\\nsql \\nselect * from trans \\nwhere date_part('month', date) = date_part('month', now()) \\nand date_part('day', date) = date_part('day', now()) \\norder by date desc; \\n\\nThis query works but is running much slower than desired. Is there a better approach for comparing the current month and day?\\nThe data is time-series in nature, and I am using PostgreSQL as the database.", "issue_sql": ["select * from trans where date_part('month', \"date\") = date_part('month', now()) and date_part('day', \"date\") = date_part('day', now()) order by \"date\" desc;"], "preprocess_sql": ["CREATE INDEX ix1 ON trans (EXTRACT(MONTH FROM date), EXTRACT(DAY FROM date));"], "clean_up_sql": ["drop index if exists ix1;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH data AS (  SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start ), mark_gaps AS ( SELECT hero_id, mission_start, mission_end,  COALESCE(LAG(mission_end) OVER w < mission_start, true) AS is_end_grp FROM data WINDOW w AS (PARTITION BY hero_id ORDER BY mission_start) ), numbered_groups AS ( SELECT hero_id, SUM(is_end_grp::int) OVER (PARTITION BY hero_id  ORDER BY mission_start) AS grp_num, mission_start, mission_end FROM mark_gaps ) SELECT hero_id, MIN(mission_start) AS v_start, MAX(mission_end) AS v_stop FROM numbered_groups GROUP BY hero_id, grp_num  ORDER BY hero_id, v_start;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_107", "db_id": "card_games", "query": "I want to query language from the 'set_translations' table and also find if the language exists in the 'foreign_data' table. I have the following query but it doesn't seem to work. Any suggestions what I did wrong? ", "issue_sql": ["SELECT set_translations.language\n              CASE WHEN set_translations.language IN (SELECT foreign_data.language in foreign_data)\n              THEN 'common'\n              ELSE 'not common'\n              END\n        FROM set_translations"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT to_timestamp(percentile_cont(0.5) within group (ORDER by cast (extract(epoch from releasedate) as integer)))::date FROM sets"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_108", "db_id": "european_football_2", "query": "\nIn the context of managing a football database, I am trying to update the 'overall_rating' of players based on their 'player_api_id' and the 'date' of their attributes. I have arrays of 'player_api_id's, 'date's, and 'overall_rating's that I want to use to update the 'Player_Attributes' table. My initial approach was to use a loop to iterate through the arrays and update each player's 'overall_rating' individually, but this method incorrectly updates the 'overall_rating' to the last value in the array for all selected players. To fix this issue, I need to ensure that each 'overall_rating' is correctly matched with the corresponding 'player_api_id' and 'date'. One solution is to use the 'unnest' function in SQL to pair the arrays together and update each player's 'overall_rating' individually. Here's the corrected SQL query I plan to use:\n", "issue_sql": ["DO $$ DECLARE i integer; BEGIN\n        FOREACH i IN ARRAY[11, 20]::integer[] LOOP\n            RAISE NOTICE 'Value: %', i;\n            UPDATE Player_Attributes SET overall_rating = i\n            WHERE player_api_id = ANY (ARRAY[505942, 155782]::integer[])\n            AND date = ANY (ARRAY['2016-02-18 00:00:00', '2015-10-16 00:00:00']::text[]);\n        END LOOP;\n    END $$;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL, incident_description VARCHAR(30) NOT NULL CHECK(CASE incident_type WHEN 'Engine failure' THEN incident_description IN ('Piston failure', 'Cylinder head gasket') WHEN 'Collision' THEN incident_description IN ('High-speed impact', 'Low-speed impact') END));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Piston failure');\"], db_name, conn)[0];\n    assert test_pred_query_result_1 == None, f'Expected 0 rows, but found {test_pred_query_result_1}'\n    test_pred_query_result_2 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'High-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_2 == None, f'Expected 0 rows, but found {test_pred_query_result_2}'\n    test_pred_query_result_3 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Engine failure', 'Cylinder head gasket');\"], db_name, conn)[0];\n    assert test_pred_query_result_3 == None, f'Expected 0 rows, but found {test_pred_query_result_3} rows'\n    test_pred_query_result_4 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Low-speed impact');\"], db_name, conn)[0];\n    assert test_pred_query_result_4 == None, f'Expected 0 rows, but found {test_pred_query_result_4}'\n    test_pred_query_result_5 = execute_queries([\"INSERT INTO race_incidents (incident_type, incident_description) VALUES ('Collision', 'Piston failure');\"], db_name, conn)[1];\n    assert test_pred_query_result_5 == True, f'There should be constraint viloation error.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_109", "db_id": "formula_1", "query": "In the context of the Formula 1 database, I am trying to perform a full-text search on a specific B field within the 'results' table. The B field contains race result details, and I am particularly interested in searching within the 'fastestLapTime' attribute. My initial attempt to perform this search using the `to_tsvector` and `to_tsquery` functions did not yield the expected results. Here is the problematic SQL statement I used:", "issue_sql": ["SELECT resultId FROM results WHERE to_tsvector(results.fastestLapTime) @@ to_tsquery('1:35.405');"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["UPDATE latest_trans a SET (amount, trans_id) = (SELECT amount, trans_id FROM trans t WHERE t.account_id = a.account_id ORDER BY t.trans_id DESC LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"select max(trans_id) from trans where account_id = 1;\"], db_name, conn)[0]\n    test_pred_query_result_2 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 1;\"], db_name, conn)[0]\n    assert test_pred_query_result_2 == test_pred_query_result_1, f\"Expected equal but got {test_pred_query_result_1} {test_pred_query_result_2}\"\n\n    test_pred_query_result_3 = execute_queries([\"select max(trans_id) from trans where account_id = 107;\"], db_name, conn)[0]\n    test_pred_query_result_4 = execute_queries([\"select max(trans_id) from latest_trans where account_id = 107;\"], db_name, conn)[0]\n    assert test_pred_query_result_3 == test_pred_query_result_4, f\"Expected equal but got {test_pred_query_result_3} {test_pred_query_result_4}\"\n\n    test_pred_query_result_5 = execute_queries(['SELECT COUNT(*) FROM latest_trans;'], db_name,conn)[0]\n    assert test_pred_query_result_5[0][0] == 4500, 'The total number of records in the attendance table should remain unchanged after the update.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_110", "db_id": "formula_1", "query": "In the context of Formula 1 racing data, I have a table that records the results of races, including the race ID, driver ID, constructor ID, and the position each driver finished in. I want to count the occurrences of each finishing position by race and insert the number of occurrences into another table as a B object. The positions are not limited to a predefined set and can vary widely. Here's an example of what I'm trying to achieve: For each race, I want to count how many drivers finished in each position and store this information in a B column, where the key is the position and the value is the count of drivers who finished in that position.", "issue_sql": ["SELECT raceId, position, COUNT(*) as cnt FROM results GROUP BY raceId, position"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH RECURSIVE recuree AS (SELECT id AS league_id, name FROM League UNION ALL SELECT L.id AS league_id, L.name FROM League L JOIN recuree R ON L.id = R.league_id) SELECT * FROM recuree LIMIT 50;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_111", "db_id": "european_football_2", "query": "In the context of the european_football_2 database, I am trying to understand 'keyset pagination' using the `Match` table which includes `id`, `date`, and `match_api_id` columns. My base query for the first page works perfectly, but I have a few use-cases which I don't understand how does it work if I want to order by `match_api_id DESC`.", "issue_sql": ["SELECT * FROM Match WHERE (match_api_id, date, id) > (492473, '2008-08-17 00:00:00', 1) ORDER BY date, id ASC LIMIT 3"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION get_superhero_ids()\n  RETURNS SETOF jsonb\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    cols   text;    -- Will hold the comma-separated list of matching columns\n    sqlstr text;    -- Will hold the final SQL statement\nBEGIN\n    SELECT string_agg(quote_ident(column_name), ', ')\n      INTO cols\n      FROM information_schema.columns\n     WHERE table_name = 'superhero'\n       AND column_name LIKE '%_id';\n\n    IF cols IS NULL THEN\n        -- No columns matched; return nothing\n        RETURN;\n    END IF;\n\n    sqlstr := format(\n        'SELECT to_jsonb(row) \n         FROM (SELECT %s \n               FROM %I) AS row',\n        cols,\n        'superhero'\n    );\n    RETURN QUERY EXECUTE sqlstr;\nEND;\n$$;", "SELECT get_superhero_ids();"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_112", "db_id": "california_schools", "query": "In the context of analyzing school data within the 'california_schools' database, I need to identify all schools that are located in both Alameda and Contra Costa counties. This is similar to finding products whose companies include both A and B in the original problem. I attempted to write a query that would return schools located in more than one county, but I'm struggling to refine this query to specifically include only those schools that are present in both Alameda and Contra Costa counties.", "issue_sql": ["SELECT School FROM schools GROUP BY School HAVING COUNT(*) > 1 ORDER BY COUNT(*) DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION f_next_free_date(\n    _input_date date\n)\nRETURNS date\nLANGUAGE plpgsql STABLE STRICT\nAS $func$\nDECLARE\n    _candidate date := _input_date;\nBEGIN\n    LOOP\n        IF NOT EXISTS (\n            SELECT 1\n              FROM races\n             WHERE date = _candidate\n        )\n        THEN\n            RETURN _candidate;\n        END IF;\n\n        _candidate := _candidate + INTERVAL '1 day';\n    END LOOP;\nEND;\n$func$;", "INSERT INTO seasons (year, url)\nVALUES (2023, 'http://example.com');", "SELECT f_next_free_date('2023-04-01');\n\nINSERT INTO races (raceid, year, round, circuitid, name, date, time, url)\nVALUES (\n    999,\n    2023,\n    1,\n    2,\n    'Test Grand Prix',\n    f_next_free_date('2023-04-01'),\n    '12:00:00',\n    'http://example.com'\n)RETURNING raceid, year, round, circuitid, name, date, time, url;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    \n    test_result = execute_queries([\n        \"SELECT COUNT(*) FROM races WHERE date = '2023-04-01'\"\n    ], db_name, conn)\n    assert test_result and test_result[0][0][0] == 1, f\"Expect 1 row, but get {test_result[0][0][0]} rows\"\n    \n    return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_113", "db_id": "formula_1", "query": "\nI'm new to SQL & I'm trying to get the raceid and name for each name with the latest date.\n", "issue_sql": ["SELECT MAX(date), raceid, name FROM races GROUP BY name, raceid HAVING MAX(date) = date;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT r.name, r.date, ARRAY_AGG(lt.milliseconds ORDER BY lt.lap) AS lap_times FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId WHERE lt.driverId = 1 GROUP BY r.name, r.date ORDER BY r.date"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_114", "db_id": "european_football_2", "query": "\nI need to generate a report that lists all possible combinations of match outcomes (win, lose, draw) for each team in the 'european_football_2' database. I tried the following query but it does not work as expected; it only returns a limited set of combinations instead of all possible combinations for each team.\n", "issue_sql": ["SELECT t.team_name, o.outcome FROM (VALUES('Team A'),('Team B')) AS t(team_name) JOIN (VALUES('win'),('lose'),('draw')) AS o(outcome);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH LatestLabs AS (SELECT ID, \"Examination Date\", Thrombosis, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY \"Examination Date\" DESC) AS rn FROM Examination) SELECT ID, MAX(CASE WHEN rn = 1 THEN Thrombosis END) AS Thrombosis_1, MAX(CASE WHEN rn = 2 THEN Thrombosis END) AS Thrombosis_2 FROM LatestLabs WHERE rn <= 2 GROUP BY ID"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_115", "db_id": "california_schools", "query": "\nI am working with the california_schools database and need to analyze the frpm table to find the second highest enrollment (K-12) for each County Code, ignoring rows with NULL values in the County Code and Enrollment (K-12) fields. The goal is: Partition the data by County Code. Within each partition, sort the records by Enrollment (K-12) in descending order, with NULL values appearing last. Select the  second highest enrollment record (rn = 2) from each partition. Exclude any counties where there's only one valid record.\n", "issue_sql": ["SELECT DISTINCT ON (\"County Code\") * FROM frpm ORDER BY \"County Code\", \"Enrollment (K-12)\" DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["with connections as ( select atom_id as atom from connected union all select atom_id2 as atom from connected ) select atom as id, count(*) as num from connections group by atom having count(*) = (select max(cnt) from (select count(*) as cnt from connections group by atom) as max_connections);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_116", "db_id": "formula_1", "query": "\nIn the context of Formula 1 racing data, I have a table that contains information about the results of races, including the points scored by drivers and their finishing positions. I want to find out the maximum number of points that can be accumulated by a driver in races where the total points scored by all drivers in those races is less than or equal to 100. The expected output is the maximum points a single driver can score under this condition, considering the distribution of points across races.", "issue_sql": ["SELECT SUM(quantity) FROM race_materials WHERE price_per_unit * quantity <= 100;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS race_materials (name text, price_per_unit int, quantity int); INSERT INTO race_materials (name, price_per_unit, quantity) VALUES ('A', 3, 30), ('B', 5, 3), ('C', 5, 3), ('D', 6, 20);"], "clean_up_sql": ["DROP TABLE race_materials;"], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION trigger_function()\nRETURNS TRIGGER\nAS $BODY$\nBEGIN\n    INSERT INTO public.destination_table (\n        created_at,\n        match_id,\n        player_id,\n        event_type,\n        url,\n        user_id\n    )\n    VALUES (\n        NEW.created_at,\n        NEW.match_id,\n        NEW.player_id,\n        NEW.event_type,\n        split_part(NEW.url::text, '?', 1),\n        ((NEW.data -> 'local_storage') -> 'data') ->> 'user_id'\n    );\n\n    RETURN NEW;\nEND;\n$BODY$\nLANGUAGE plpgsql;", "CREATE TRIGGER after_insert_source\nAFTER INSERT ON public.source_table\nFOR EACH ROW\nEXECUTE PROCEDURE trigger_function();", "INSERT INTO public.source_table (\n    created_at,\n    match_id,\n    player_id,\n    event_type,\n    url,\n    data\n)\nVALUES (\n    NOW(),\n101,\n202,\n'goal',\n'http://example.com?foo=bar',\n'{\n        \"local_storage\": {\n            \"data\": {\n                \"user_id\": \"u12345\"\n            }\n        }\n    }'::jsonb\n);"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)\n    test_result = execute_queries([\"SELECT * FROM public.destination_table;\"], db_name, conn)\n    assert test_result and test_result[0][0][-1] == 'u12345'\n    assert test_result and test_result[0][0][-2] == 'http://example.com'\n    assert test_result and test_result[0][0][-3] == 'goal'\n    return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_117", "db_id": "formula_1", "query": "\nIn the context of Formula 1 racing data, I have two tables: `drivers` and `results`. The `drivers` table contains information about each driver, including their unique `driverId` and `driverRef`. The `results` table records the outcomes of races, including the `driverId` of the participant, their `position` in the race, and the `points` they scored. I want to filter `drivers` by their `position` and `points` in the `results` table. Typically, I filter between 2-5 `position` and `points` values. There are approximately 6-10 `results` entries per driver. Given the large size of the database, I aim to optimize this query for performance, possibly by eliminating the `HAVING` clause. Here's the query I'm currently using:```sql\nSELECT \n    drivers.forename, \n    drivers.surname, \n    jsonb_agg(jsonb_strip_nulls(jsonb_build_object('laps', results.laps, 'position', results.position))) AS race_results\nFROM \n    drivers\nJOIN \n    results\nON \n    drivers.driverid = results.driverid\nGROUP BY \n    drivers.forename, \n    drivers.surname\nHAVING \n    jsonb_agg(jsonb_build_object('laps', results.laps, 'position', results.position)) @? '$[*] ? (@.laps == 56) ? (@.position == 1)';\n```", "issue_sql": ["SELECT\n    drivers.forename,\n    drivers.surname,\n    jsonb_agg(jsonb_strip_nulls(jsonb_build_object('laps', results.laps, 'position', results.position))) AS race_results\nFROM\n    drivers\nJOIN\n    results\nON\n    drivers.driverid = results.driverid\nGROUP BY\n    drivers.forename,\n    drivers.surname\nHAVING\n    jsonb_agg(jsonb_build_object('laps', results.laps, 'position', results.position)) @? '$[*] ? (@.laps == 56) ? (@.position == 1)';"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT raceId, name, year, COUNT(*) OVER (PARTITION BY year) as same_year_races FROM races;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_118", "db_id": "european_football_2", "query": "\nHow can I generate a table that groups data from a player_attributes table by player_fifa_api_id and player_api_id and, for each group, concatenates the overall_rating values into a field?\n", "issue_sql": ["INSERT INTO historical_rating (player_fifa_api_id, player_api_id, grouped_rating) SELECT player_fifa_api_id, player_api_id AS grouped_rating FROM player_attributes GROUP BY player_fifa_api_id, player_api_id;"], "preprocess_sql": ["CREATE TABLE historical_rating (\n    player_fifa_api_id INT,\n    player_api_id INT,\n    grouped_rating TEXT,\n    first_recorded_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    last_updated_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    rating_count INTEGER DEFAULT 0,\n    average_rating NUMERIC(5,2) DEFAULT 0.0,\n    rating_trend TEXT DEFAULT 'stable',\n    highest_rating INTEGER DEFAULT 0,\n    lowest_rating INTEGER DEFAULT 100,\n    rating_variance NUMERIC(8,4) DEFAULT 0.0,\n    data_quality_score INTEGER DEFAULT 5 CHECK (data_quality_score BETWEEN 1 AND 10),\n    is_active BOOLEAN DEFAULT TRUE,\n    metadata JSONB DEFAULT '{}'::jsonb,\n    rating_history_hash UUID DEFAULT gen_random_uuid(),\n    notes TEXT DEFAULT '',\n    season_count INTEGER DEFAULT 1,\n    last_rating_change NUMERIC(5,2) DEFAULT 0.0\n);"], "clean_up_sql": ["DROP TABLE historical_rating"], "category": "Management", "efficiency": false, "sol_sql": ["with hero_attribute_data (hero_id, attribute_id, max_score, year_1, year_2, year_3, year_4, year_5) as (values (1, 1, 80, 80, 80, 80, null, 80), (2, 2, 90, 90, 85, 90, 88, 90), (3, 3, 75, 75, 70, null, 75, 75), (4, 4, 60, null, 60, 60, 60, null)), score_check as (select *, case when (coalesce(year_1::character, 'x') || coalesce(year_2::character, 'x') || coalesce(year_3::character, 'x') || coalesce(year_4::character, 'x') || coalesce(year_5::character, 'x') ~ '\\d+x\\d+' or year_1 <> max_score or year_2 <> max_score or year_3 <> max_score or year_4 <> max_score or year_5 <> max_score) then false else true end is_a_match from hero_attribute_data) select * from score_check where is_a_match is false;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_119", "db_id": "codebase_community", "query": "\nIn a database that contains a table named 'posts', each post can reference a parent post through the 'acceptedanswerid' column. The goal is to retrieve posts based on the following conditions: (1) Include the parent post if the parent's 'score' is greater than or equal to 20, and (2) Include the child post if the parent's 'score' is less than 20 but the child's 'score' is greater than or equal to 20. Both parent and child posts should not be included simultaneously if the parent satisfies the condition. How can I write a query to achieve this?\n", "issue_sql": ["SELECT DISTINCT id, acceptedanswerid, posttypeid, score FROM posts WHERE score >= 20 OR acceptedanswerid IS NOT NULL AND score >= 20 GROUP BY id, acceptedanswerid;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE cte AS (SELECT item_id, item_price, quantity, resource_id, resource_price FROM store UNION ALL SELECT s.item_id, s.item_price, c.quantity, c.resource_id, c.resource_price FROM store s INNER JOIN cte c ON c.item_id = s.uses_item_id), full_craft_prices AS (SELECT item_id, sum(coalesce(resource_price * quantity, 0)) AS full_craft_price FROM cte GROUP BY item_id) SELECT s.item_id, s.item_price AS retail_price, sum(coalesce(uses_item_price, 0) * quantity) + sum(coalesce(resource_price * quantity, 0)) AS partial_craft_price, f.full_craft_price FROM store s LEFT JOIN full_craft_prices f ON s.item_id = f.item_id GROUP BY s.item_id, s.item_price, f.full_craft_price;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_120", "db_id": "superhero", "query": "\nIn the superhero database, we want to identify a list of superheroes who have only the superpowers of 'Flight' and 'Telepathy' and do not possess any other superpowers. The following query seems to work, but I suspect there might be a more efficient way to achieve this result.", "issue_sql": ["SELECT DISTINCT s.id\nFROM superhero s\nWHERE EXISTS (\n    SELECT 1\n    FROM hero_power hp\n    JOIN superpower sp ON hp.power_id = sp.id\n    WHERE s.id = hp.hero_id AND sp.power_name = 'Flight'\n)\nAND EXISTS (\n    SELECT 1\n    FROM hero_power hp\n    JOIN superpower sp ON hp.power_id = sp.id\n    WHERE s.id = hp.hero_id AND sp.power_name = 'Telepathy'\n)\nAND NOT EXISTS (\n    SELECT 1\n    FROM hero_power hp\n    JOIN superpower sp ON hp.power_id = sp.id\n    WHERE s.id = hp.hero_id AND sp.power_name NOT IN ('Flight', 'Telepathy')\n);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["UPDATE superhero s SET full_name = 'Superman' FROM team_member_superhero tms JOIN team_member tm ON tms.team_member_id = tm.id WHERE s.id = tms.superhero_id AND tm.team_id = 91;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT full_name FROM superhero WHERE id = 1;\"], db_name, conn)[0]\n    assert test_sql_result[0][0] == \"Superman\", f'Expected the full name is updated to Superman, but found {test_sql_result[0][0]}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_121", "db_id": "card_games", "query": "We have a table with card collection data which includes the start and end dates of when cards were added to and removed from a collection. Not all cards have an end date as they are still in the collection. We need to calculate the number of new cards added per month, cards removed per month, and existing cards per month. We have already completed counts of new and removed cards per month, but we are facing trouble in calculating the existing cards. The data starts from January 2023.", "issue_sql": ["WITH card_activity AS ( SELECT to_date(fe.start_date_key::text, 'YYYYMMDD') AS start_date, to_date(fe.end_date_key::text, 'YYYYMMDD') AS end_date, dp.set_name, dp.set_code FROM fact_collection fe INNER JOIN dim_set dp ON fe.set_key = dp.set_key ) SELECT date_trunc('month', month_series) AS month, COUNT(*) AS existing_cards, sa.set_name FROM ( SELECT generate_series( (SELECT MIN(to_date(start_date_key::text, 'YYYYMMDD')) FROM fact_collection), '2100-12-31', INTERVAL '1 month') AS month_series ) AS months LEFT JOIN card_activity sa ON sa.start_date < month_series AND (sa.end_date IS NULL OR sa.end_date >= month_series) GROUP BY month, sa.set_name;"], "preprocess_sql": ["CREATE TABLE dim_set ( set_key int4 GENERATED ALWAYS AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL, set_name varchar NULL, set_code varchar NULL ); CREATE TABLE fact_collection ( card_key int4 NULL, start_date_key int4 NULL, end_date_key int4 NULL, set_key int4 NULL ); INSERT INTO dim_set (set_name, set_code) VALUES ('Core Set', '10E'); INSERT INTO fact_collection (card_key, start_date_key, end_date_key, set_key) VALUES (1, 20230105, 20230130, 1), (2, 20230106, 20230120, 1), (3, 20230405, 20230420, 1); INSERT INTO fact_collection (card_key, start_date_key, set_key) VALUES (4, 20230110, 1), (5, 20230120, 1), (6, 20230220, 1), (7, 20230202, 1), (8, 20230228, 1), (9, 20230206, 1), (10, 20230406, 1);"], "clean_up_sql": ["DROP TABLE IF EXISTS fact_collection; DROP TABLE IF EXISTS dim_set;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT id, COALESCE(MAX(CASE WHEN diagnosis = 'SLE' THEN 'TRUE' END), 'FALSE') AS SLE, COALESCE(MAX(CASE WHEN diagnosis = 'PSS' THEN 'TRUE' END), 'FALSE') AS PSS, COALESCE(MAX(CASE WHEN diagnosis = 'RA susp.' THEN 'TRUE' END), 'FALSE') AS RA_susp FROM examination GROUP BY id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    global pred_query_result\n    assert len(pred_query_result) == 70, f'Expected 70 rows, but found {len(pred_query_result)} rows.'\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_122", "db_id": "superhero", "query": "We have a dataset representing time spans during which superheroes have been active in various missions. Each record includes a superhero's ID, the start time, and the end time of their mission. We need to combine multiple rows into a single row where the missions are continuous (i.e., the end time of one mission is the start time of the next mission for the same superhero). The goal is to find the earliest start time and the latest end time for each continuous span of missions for each superhero.", "issue_sql": ["WITH mission_spans AS ( SELECT hero_id, mission_start, mission_end FROM superhero_missions ORDER BY hero_id, mission_start, mission_end ) SELECT hero_id, MIN(mission_start) OVER (PARTITION BY hero_id), MAX(mission_end) OVER (PARTITION BY hero_id) FROM mission_spans ORDER BY 1, 2, 3"], "preprocess_sql": ["CREATE TABLE superhero_missions ( hero_id bigint, mission_start timestamp, mission_end timestamp );", "INSERT INTO superhero_missions (hero_id, mission_start, mission_end) VALUES (1, '2023-01-01 09:00:00', '2023-01-01 10:00:00'), (1, '2023-01-01 10:00:00', '2023-01-01 11:00:00'), (1, '2023-01-01 11:00:00', '2023-01-01 12:00:00'), (1, '2023-01-01 13:00:00', '2023-01-01 14:00:00'), (1, '2023-01-01 14:00:00', '2023-01-01 15:00:00'), (1, '2023-01-01 15:00:00', '2023-01-01 16:00:00'), (2, '2023-01-01 10:00:00', '2023-01-01 11:00:00'), (2, '2023-01-01 11:00:00', '2023-01-01 12:00:00'), (2, '2023-01-01 13:00:00', '2023-01-01 14:00:00'), (3, '2023-01-01 10:00:00', '2023-01-01 11:00:00');"], "clean_up_sql": ["DROP TABLE IF EXISTS superhero_missions;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT COALESCE(hbi.id, hbialt.id) as id, COALESCE(hbi.hero_name, hbialt.hero_name) as name, COALESCE(hbialt.date_of_birth, hbi.birthdate) AS birthdate FROM hero_birth_info hbi FULL OUTER JOIN hero_birth_info_alt hbialt ON hbi.id = hbialt.id order by COALESCE(hbi.id, hbialt.id)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_123", "db_id": "card_games", "query": "I am trying to find the median release date of all card sets in the 'sets' table of the card_games database. The goal is to obtain the date that is in the middle of all the release dates. I attempted to use the percentile_cont function directly on the date column, but encountered an error. Here is the SQL statement I used:", "issue_sql": ["SELECT percentile_cont(0.5) within group (ORDER by releasedate) FROM sets"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION reindex_superhero_ids(IN BIGINT) RETURNS VOID LANGUAGE plpgsql AS $proc$ BEGIN IF EXISTS ( SELECT FROM pg_catalog.pg_class WHERE  relname = 'id_seq_temp' AND relnamespace = pg_my_temp_schema() AND relkind = 'S') THEN ALTER SEQUENCE id_seq_temp RESTART; ELSE CREATE TEMP SEQUENCE id_seq_temp; END IF; UPDATE superhero SET hair_colour_id = hair_colour_id + 2000 WHERE publisher_id = $1; UPDATE superhero SET hair_colour_id = nextval('id_seq_temp') WHERE publisher_id = $1; END $proc$;;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"SELECT reindex_superhero_ids(9)\"], db_name, conn)\n    test_sql_result = execute_queries([\"SELECT hair_colour_id FROM superhero WHERE publisher_id = 9;\"], db_name, conn)[0]\n    assert test_sql_result == [(1,), (1,), (1,), (1,)], f'Expected hair_color_id to be 1, 1, 1, 1, but found {test_sql_result}.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_124", "db_id": "formula_1", "query": "I am creating a table to track race incidents and I need a check constraint to validate the possible values given a string value. I am creating this table: \\\\", "issue_sql": ["CREATE TABLE race_incidents ( incident_type VARCHAR(30) NOT NULL CHECK(incident_type = 'Engine failure' OR incident_type = 'Collision'), incident_description VARCHAR(30) NOT NULL);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["ALTER TABLE card_versions  DROP CONSTRAINT pk_card_versions, ADD  CONSTRAINT pk_card_versions PRIMARY KEY (defn_id, attr_id, seqnr) DEFERRABLE", "UPDATE card_versions SET seqnr = seqnr + 1 WHERE defn_id = 100 AND attr_id = 100 AND seqnr >= 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sql_result = execute_queries([\"SELECT seqnr FROM card_versions;\"], db_name, conn)[0]\n    assert test_sql_result == [(2,), (3,), (4,), (5,), (6,)], f'Expected the seqrs are updated to 2, 3, 4, 5, 6, but found {test_sql_result}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_125", "db_id": "financial", "query": "In the financial database, we have two tables: `trans` and `account`. The `trans` table tracks all transactions made on each account, with multiple rows per account. The `account` table contains only one row per account, representing the most recent transaction details. We need to update the `account` table with the details of the most recent transaction (highest `trans_id`) for each account. The tables have many columns, so we would like to use a method that includes all fields in the update without explicitly listing them.", "issue_sql": ["select * from trans t1 where (account_id, trans_id) in (select account_id, max(trans_id) from trans t1 group by account_id);"], "preprocess_sql": ["CREATE TABLE latest_trans AS SELECT DISTINCT account_id, 0 AS amount, 0 AS trans_id FROM trans;"], "clean_up_sql": ["drop table if exists latest_trans;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH table_jsonb AS (SELECT id, jsonb_insert('{}','{buildupplayspeed}',to_jsonb(buildupplayspeed)) as attributes FROM team_attributes WHERE team_api_id = 1773) UPDATE team_attributes SET attributes_jsonb = table_jsonb.attributes FROM table_jsonb WHERE team_attributes.id = table_jsonb.id AND team_attributes.team_api_id = 1773 RETURNING team_attributes.id, team_attributes.attributes_jsonb;", "SELECT id, attributes_jsonb FROM team_attributes WHERE team_api_id = 1773 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_126", "db_id": "european_football_2", "query": "I am trying to run a recursive query in PostgreSQL to find all teams that belong under a specific league. The query is the following: I need to find all teams that are part of a league and any sub-leagues they might belong to. However, I am encountering issues with the recursive CTE. The error seems to be related to the structure of the CTE and the use of UNION instead of UNION ALL. Additionally, I am unsure how to properly reference the initial CTE within the recursive part of the query.", "issue_sql": ["WITH TAB AS (SELECT id as league_id, name FROM League UNION SELECT id, name FROM League) , RECURSIVE recuree AS ( SELECT league_id, name FROM TAB UNION SELECT E.league_id, E.name FROM TAB E JOIN recuree S ON E.id = S.league_id)  SELECT * FROM recuree"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE atom_ancestors AS ( SELECT atom_id, parent_id, enabled FROM connection WHERE atom_id = 4 UNION ALL SELECT c.atom_id, c.parent_id, c.enabled FROM connection c INNER JOIN atom_ancestors aa ON c.atom_id = aa.parent_id) SELECT * FROM atom_ancestors WHERE NOT EXISTS (SELECT 1 FROM atom_ancestors WHERE enabled = false)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_127", "db_id": "superhero", "query": "In our superhero database, we have multiple tables that store various attributes and details about superheroes. I need to retrieve all records from the `superhero` table across all column names that end with '_id' in josn. The column names are dynamic, with new ones being added and old ones being removed frequently, so I cannot hardcode the column names in my query. How can I achieve this?", "issue_sql": ["SELECT *\nFROM superhero.\"%_id\";"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["select\n  preference_data.customerid,\n  jsonb_object_agg(preference_data.key, case when preference_data.key = 'dis' then preference_data.value else preference_data.value->0 end) as final_json\nfrom (\n    select\n      mt.customerid,\n      props.key,\n      jsonb_agg(distinct coalesce(j.dis, props.value)) as value\n    from card_preference as mt\n    cross join jsonb_each(mt.preference) as props\n    left join jsonb_array_elements(case when props.key = 'dis' then props.value end) as j(dis) on 1=1\n    group by\n      mt.customerid,\n      props.key\n) preference_data\ngroup by\n  preference_data.customerid;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    assert isinstance(concatenated_json, dict), f'Expected result to be a dictionary, but found {type(concatenated_json)}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    concatenated_json = pred_query_result[0][1]\n    expected_values = {\n        \"dir\": 1,\n        \"dis\": [\"bye\", \"close\", \"hello\"],\n        \"purpose\": {\"text\": \"hi\", \"score\": 0.1}\n    }\n\n    assert concatenated_json == expected_values, f'Expected {expected_values} but found {concatenated_json}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_128", "db_id": "card_games", "query": "In the context of managing a database for a card game, I need to ensure that when inserting data into a table, if a null value is provided for certain enum fields, the default value specified during the table creation is used instead. Currently, when I insert data with null values for these enum fields, the null values are being inserted rather than the default values. Here's an example of the issue I'm encountering:\n\nsql\nINSERT INTO cards(availability, borderColor) VALUES (NULL, 'black');\n\n\nThis results in the following data being inserted:\n\n|availability|borderColor|\n|---|---|\n|NULL|black|\n\nHowever, I need the data to be inserted with the default value for 'availability' when NULL is provided, like so:\n\n|availability|borderColor|\n|---|---|\n|mtgo,paper|black|", "issue_sql": ["INSERT INTO cards(availability, borderColor) VALUES (NULL, 'black');"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT hero_id, attribute_value AS Difference FROM hero_attribute\nJOIN attribute ON hero_attribute.attribute_id = attribute.id GROUP BY hero_id, attribute_value\nHAVING COUNT(DISTINCT attribute_value) > 1 UNION ALL SELECT hero_id, attribute_value AS Difference\nFROM hero_attribute JOIN attribute ON hero_attribute.attribute_id = attribute.id\nGROUP BY hero_id, attribute_value HAVING COUNT(DISTINCT attribute_id) > 1\nOR (COUNT(attribute_id) != COUNT(*) AND COUNT(DISTINCT attribute_id) > 0)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'error_sql query did not return any records with attribute differences.'\n    assert test_pred_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_pred_query_result_1[0][1]}'\n    assert test_pred_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_pred_query_result_1[0][1]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result_1) > 0, 'sol_sql query did not return any records with attribute differences.'\n    assert test_sol_query_result_1[0][1] == 45, f'Expect the difference of first row to be 45, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[1][1] == 20, f'Expect the difference of second row to be 20, but found {test_sol_query_result_1[0][1]}'\n    assert test_sol_query_result_1[2][1] == 35, f'Expect the difference of third row to be 35, but found {test_sol_query_result_1[0][1]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_129", "db_id": "formula_1", "query": "In the context of Formula 1 racing data, I have a table named `races` with a column `date` of type `date`. I need each of the values in `date` to be unique. Given a `date` input, `input_date`, I need to find the **minimum** `date` value that satisfies the following criteria: the result must be >= `input_date` and the result must not already be in `date`. I cannot merely add one day to the greatest value in `date`, because I need the minimum value that satisfies the above criteria. Is there a concise way to compute this as part of an insert or update to the `races` table?", "issue_sql": ["INSERT INTO races (raceid, year, round, circuitid, name, date, time, url)\nVALUES (\n    999,\n    2023,\n    1,\n    2,\n    'Test Grand Prix',\n    '2023-04-01',\n    '12:00:00',\n    'http://example.com'\n)"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["INSERT INTO member(member_id, first_name, last_name, link_to_major) VALUES ('new_member_id', 'John', 'Doe', 'rec06DF6vZ1CyPKpc') ON CONFLICT (member_id) DO UPDATE SET first_name=excluded.first_name, last_name=excluded.last_name, link_to_major=member.link_to_major;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_0 = execute_queries([\"SELECT member_id, first_name, last_name, link_to_major FROM member WHERE member_id = 'new_member_id';\"], db_name, conn)[0]; \n\n    assert test_pred_query_result_0[0][0] == 'new_member_id', f'Expected member_id to be new_number_id, but found {test_pred_query_result_0[0][0]}'\n    assert test_pred_query_result_0[0][1] == 'John', f'Expected first_name to be John, but found {test_pred_query_result_0[0][1]}'\n    assert test_pred_query_result_0[0][2] == 'Doe', f'Expected last_name to be Doe, but found {test_pred_query_result_0[0][2]}'\n    assert test_pred_query_result_0[0][3] == 'rec06DF6vZ1CyPKpc', f'Expected link_to_major to be rec06DF6vZ1CyPKpc, but found {test_pred_query_result_0[0][3]}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_130", "db_id": "formula_1", "query": "In the context of Formula 1 racing data, we have a table that records the lap times of drivers across different races. Each driver has multiple lap times recorded for each race they participate in. The goal is to select a specific driver's lap times across all races they've participated in, aggregating these times by race. Given `driverId=1` and `name=Lewis Hamilton`, we want to retrieve his lap times for each race, aggregated by race, to analyze his performance across different circuits. The desired output should list each race with the corresponding aggregated lap times for the specified driver.", "issue_sql": ["SELECT\n    sub.raceId,\n    sub.t[1] AS \"Lap_Time_Race1\",\n    sub.t[2] AS \"Lap_Time_Race2\",\n    sub.t[3] AS \"Lap_Time_Race3\"\nFROM (\n    SELECT\n        driverId,\n        raceId,\n        ARRAY_AGG(milliseconds ORDER BY lap) AS t\n    FROM lapTimes\n    WHERE driverId = 1\n    GROUP BY driverId\n) AS sub\nORDER BY sub.raceId;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT COUNT(*) AS streak_count, 'April Meeting' AS event_name, 'MST' AS timezone, MIN(min_ts) AS start_date, MAX(max_ts) AS end_date FROM ( SELECT *, the_day - row_number() OVER (ORDER BY the_day)::INT AS streak FROM ( SELECT (event_date::TIMESTAMP AT TIME ZONE 'UTC' AT TIME ZONE 'MST')::date AS the_day , count(*) AS ct, min(event_date) AS min_ts, max(event_date) AS max_ts FROM event WHERE event_name = 'April Meeting' GROUP  BY 1) sub1) sub2 GROUP  BY streak ORDER  BY end_date DESC LIMIT  1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_query_result_1[0][1] == 'April Meeting', 'The event name should be April Meeting.'\n    assert pred_query_result_1[0][2] == 'MST', 'The timezone should be MST.'\n    assert pred_query_result_1[0][0] > 0, 'The streak count should be greater than 0.'\n    test_pred_query_result_1 = execute_queries([\"SELECT MIN(event_date) AS start_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][3] == str(test_pred_query_result_1[0][0]), f'Expected start_date to be {test_pred_query_result_1[0][0]}, but found {pred_query_result_1[0][3]}'\n    test_pred_query_result_2 = execute_queries([\"SELECT MAX(event_date) AS end_date FROM event WHERE event_name = 'April Meeting'\"], 'student_club', conn)[0]\n    assert pred_query_result_1[0][4] == str(test_pred_query_result_2[0][0]), f'Expected end_date to be {test_pred_query_result_2[0][0]}, but found {pred_query_result_1[0][4]}'\n    \n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_131", "db_id": "thrombosis_prediction", "query": "In the context of a medical database tracking patient examinations and laboratory tests, I have a table called `Examination` that records various test results for patients, including a `Thrombosis` score indicating the severity of thrombosis. Another table, `Laboratory`, logs detailed laboratory test results over time for each patient. I need to retrieve the last two laboratory test results for each patient's `Thrombosis` score, but instead of getting two rows for each patient, I want to have two new columns with the previous `Thrombosis` scores, labeled as `Thrombosis_1` and `Thrombosis_2`. The desired result should look like this: ID | Thrombosis_1 | Thrombosis_2, where each row represents a patient with their last two `Thrombosis` scores.", "issue_sql": ["SELECT * FROM Examination AS e LEFT JOIN LATERAL (SELECT * FROM Laboratory WHERE ID = e.ID ORDER BY Date DESC LIMIT 2) AS lab ON true"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT DATE_TRUNC('day', to_timestamp(transaction_timestamp / 1000000000.0)), COUNT(*) FROM pitstops GROUP BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_132", "db_id": "toxicology", "query": "In the context of a toxicology database, we have a scenario where we need to identify the atoms that are most frequently connected to other atoms within molecules, essentially finding the atoms with the most 'friends' (connections) and the number of these connections. Given the schema and data provided, we aim to find the atom(s) with the highest number of connections and the count of these connections.", "issue_sql": ["select a.f as \"id\", count(a.f) as \"num\" from ( select atom_id as f from connected union all select atom_id2 as f from connected ) a group by a.f order by count(a.f) desc limit 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["select id, date, got, gpt from (select lab1.*, row_number() over (partition by lab1.id order by lab1.date) as rn from laboratory lab1 join (select id, date, got, gpt from (select lab.*, row_number() over (partition by lab.id order by lab.date desc) rn from laboratory lab) lab where rn = 1 ) lab2 on lab2.id = lab1.id and lab1.got = lab2.got and lab1.gpt = lab2.gpt) lab where rn = 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_133", "db_id": "european_football_2", "query": "I'm trying to create a trigger that will add a new row processed entry to a destination table each time a new row is created in the source table. The source table contains detailed information about match events in a football league, including timestamps, match IDs, player IDs, event types, and additional  data about the event context. The destination table should store processed information about these events, including the timestamp, match ID, player ID, event type, a simplified URL from the event context, and the user ID who recorded the event. The trigger function is not working as expected, and no new entries are being recorded in the destination table despite new rows being inserted into the source table.", "issue_sql": ["CREATE OR REPLACE FUNCTION triger_function() RETURNS TRIGGER AS $BODY$ BEGIN INSERT INTO public.destination_table ( created_at, match_id, player_id, event_type, url, user_id) SELECT created_at, match_id, player_id, event_type, split_part(url::text, '?', 1) AS url, ((((data >> '{}')::jsonb >> '{}')::jsonb -> 'local_storage'::text) -> 'data'::text) >> '{}' -> 'user_id'::varchar FROM source_table; RETURN new; END; $BODY$ language plpgsql;", "CREATE TRIGGER after_insert_source_error\nAFTER INSERT ON public.source_table\nFOR EACH ROW\nEXECUTE PROCEDURE trigger_function_error();", "INSERT INTO public.source_table (\n    created_at,\n    match_id,\n    player_id,\n    event_type,\n    url,\n    data\n)\nVALUES (\n    NOW(),\n101,\n202,\n'goal',\n'http://example.com?foo=bar',\n'{\n        \"local_storage\": {\n            \"data\": {\n                \"user_id\": \"u12345\"\n            }\n        }\n    }'::jsonb\n);"], "preprocess_sql": ["CREATE TABLE public.source_table (\n    id serial PRIMARY KEY,\n    created_at TIMESTAMP NOT NULL,\n    match_id INTEGER NOT NULL,\n    player_id INTEGER NOT NULL,\n    event_type VARCHAR NOT NULL,\n    url VARCHAR NOT NULL,\n    data JSONB NOT NULL\n);\n\nCREATE TABLE public.destination_table (\n    id serial PRIMARY KEY,\n    created_at TIMESTAMP NOT NULL,\n    match_id INTEGER NOT NULL,\n    player_id INTEGER NOT NULL,\n    event_type VARCHAR NOT NULL,\n    url VARCHAR NOT NULL,\n    user_id VARCHAR\n);"], "clean_up_sql": ["DROP TABLE public.source_table; DROP TABLE public.destination_table;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH constructor_roles AS ( SELECT 18 race_id, 1 constructor_id, false customer_billing, true commander, true agent UNION ALL SELECT 18, 2, true, false, false ), tmp AS ( SELECT n.race_id id, array_agg( ARRAY[ CASE WHEN n.customer_billing = TRUE THEN 'AR (Customer Billing)' END, CASE WHEN n.commander = TRUE THEN 'AP (Commander)' END, CASE WHEN n.agent = TRUE THEN 'AP (Agent)' END ] ) AS finance_array FROM constructor_roles n WHERE n.race_id = 18 AND (n.customer_billing = TRUE or n.commander = TRUE or n.agent = TRUE) GROUP BY race_id ) SELECT id, array_to_string(array(select distinct e from unnest(finance_array) as a(e)), ', ') FROM tmp"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_134", "db_id": "superhero", "query": "I am given a task to optimize the following query (not originally written by me). The query calculates the success rate of superheroes requesting new powers, where each request can have up to 5 retries if it fails.\n\nThe query needs to return:\n1. The total number of requests,\n2. The success rate (ratio of successful to total requests),\n3. Grouped by the power requested and the superhero's ID.\n\nHowever, the current query is very slow on a large dataset (millions of rows). Below is the table-creation script, data-insertion script, and the problematic query. How can I optimize this further?\n", "issue_sql": ["SELECT\n    s.superhero_id AS \"superheroId\",\n    p.power_name   AS \"power\",\n    COUNT(*)       AS \"totalRequests\",\n    SUM(\n       CASE WHEN r.status = 'success' THEN 1 ELSE 0 END\n    ) * 100.0 / COUNT(*) AS \"successRate\"\nFROM public.superhero_requests s\nJOIN public.superpower p\n  ON s.superpower_id = p.id\nJOIN (\n    SELECT\n        id,\n        superhero_id,\n        superpower_id,\n        status,\n        retry_number,\n        main_request_uuid,\n        ROW_NUMBER() OVER (\n            PARTITION BY main_request_uuid\n            ORDER BY retry_number DESC, id DESC\n        ) AS row_number\n    FROM public.superhero_requests\n) r\n  ON s.id = r.id\nWHERE s.created_at >= CURRENT_DATE - INTERVAL '30 days'\n  AND s.created_at <= CURRENT_DATE\n  AND r.row_number = 1\nGROUP BY\n    s.superhero_id,\n    p.power_name\nLIMIT 10;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS public.superhero_requests (\n    id BIGINT NOT NULL,\n    superhero_id BIGINT NOT NULL,\n    superpower_id BIGINT NOT NULL,\n    status TEXT NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL,\n    retry_number SMALLINT NOT NULL,\n    main_request_uuid VARCHAR NOT NULL,\n    -- New columns\n    request_priority INTEGER DEFAULT 5,\n    processing_time_ms INTEGER DEFAULT 0,\n    approval_status TEXT DEFAULT 'pending',\n    approved_by VARCHAR(100) DEFAULT NULL,\n    approval_date TIMESTAMPTZ DEFAULT NULL,\n    request_source TEXT DEFAULT 'web',\n    request_notes TEXT DEFAULT '',\n    is_emergency BOOLEAN DEFAULT FALSE,\n    last_updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    metadata JSONB DEFAULT '{}'::jsonb,\n    expiration_date DATE DEFAULT (CURRENT_DATE + INTERVAL '90 days'),\n    request_version INTEGER DEFAULT 1,\n    is_archived BOOLEAN DEFAULT FALSE,\n    archive_reason TEXT DEFAULT NULL,\n    client_ip VARCHAR(45) DEFAULT '127.0.0.1',\n    session_id UUID DEFAULT gen_random_uuid(),\n    request_hash VARCHAR(64) DEFAULT NULL,\n    retry_scheduled_at TIMESTAMPTZ DEFAULT NULL,\n    failure_reason TEXT DEFAULT NULL,\n    notification_sent BOOLEAN DEFAULT FALSE,\n    PRIMARY KEY (id)\n);", "INSERT INTO public.superhero_requests (\n    id,\n    superhero_id,\n    superpower_id,\n    status,\n    created_at,\n    retry_number,\n    main_request_uuid,\n    -- New columns\n    request_priority,\n    processing_time_ms,\n    approval_status,\n    approved_by,\n    approval_date,\n    request_source,\n    request_notes,\n    is_emergency,\n    last_updated_at,\n    metadata,\n    expiration_date,\n    request_version,\n    is_archived,\n    archive_reason,\n    client_ip,\n    session_id,\n    request_hash,\n    retry_scheduled_at,\n    failure_reason,\n    notification_sent\n)\nSELECT\n    generate_series(1, 1000000)               AS id,\n    (random() * 750)::int + 1                AS superhero_id,     -- IDs between 1..750\n    (random() * 5)::int + 1                  AS superpower_id,     -- referencing our 5 sample powers (1..5)\n    CASE WHEN random() < 0.8 THEN 'success'\n         ELSE 'failure'\n    END                                       AS status,          \n    NOW() - (random() * 30)::int * '1 day'::interval AS created_at,\n    (random() * 5)::int                      AS retry_number,      -- 0..5\n    md5(random()::text)                      AS main_request_uuid,  -- random UUID-like string\n    -- New column values\n    (random() * 10)::int                     AS request_priority,\n    (random() * 5000)::int                   AS processing_time_ms,\n    CASE \n        WHEN random() < 0.7 THEN 'approved'\n        WHEN random() < 0.9 THEN 'rejected'\n        ELSE 'pending'\n    END                                       AS approval_status,\n    CASE \n        WHEN random() < 0.8 THEN 'admin' || (random() * 10)::int\n        ELSE NULL\n    END                                       AS approved_by,\n    CASE \n        WHEN random() < 0.8 THEN NOW() - (random() * 25)::int * '1 day'::interval\n        ELSE NULL\n    END                                       AS approval_date,\n    CASE \n        WHEN random() < 0.6 THEN 'web'\n        WHEN random() < 0.8 THEN 'mobile'\n        WHEN random() < 0.9 THEN 'api'\n        ELSE 'internal'\n    END                                       AS request_source,\n    'Request notes for ' || md5(random()::text) AS request_notes,\n    random() < 0.1                           AS is_emergency,\n    NOW() - (random() * 20)::int * '1 hour'::interval AS last_updated_at,\n    jsonb_build_object(\n        'browser', CASE WHEN random() < 0.5 THEN 'Chrome' ELSE 'Firefox' END,\n        'device', CASE WHEN random() < 0.7 THEN 'Desktop' ELSE 'Mobile' END,\n        'tracking_id', md5(random()::text)\n    )                                         AS metadata,\n    CURRENT_DATE + ((random() * 180)::int - 30) * '1 day'::interval AS expiration_date,\n    (random() * 3)::int + 1                  AS request_version,\n    random() < 0.05                          AS is_archived,\n    CASE \n        WHEN random() < 0.05 THEN 'Outdated request'\n        ELSE NULL\n    END                                       AS archive_reason,\n    '192.168.' || (random() * 255)::int || '.' || (random() * 255)::int AS client_ip,\n    gen_random_uuid()                        AS session_id,\n    md5(random()::text)                      AS request_hash,\n    CASE \n        WHEN random() < 0.3 THEN NOW() + (random() * 5)::int * '1 day'::interval\n        ELSE NULL\n    END                                       AS retry_scheduled_at,\n    CASE \n        WHEN random() < 0.2 THEN 'Connection timeout'\n        WHEN random() < 0.4 THEN 'Invalid parameters'\n        WHEN random() < 0.6 THEN 'Server error'\n        ELSE NULL\n    END                                       AS failure_reason,\n    random() < 0.75                          AS notification_sent\n;"], "clean_up_sql": ["DROP TABLE public.superhero_requests;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT sub.firstName, jsonb_agg(jsonb_build_object('yearId', sub.yearId, 'classes', sub.classes)) AS years FROM (SELECT s.id, s.firstName, cy.yearId, jsonb_agg(jsonb_build_object('classId', cy.classId)) AS classes FROM users3 s LEFT JOIN classYearStudents cys ON cys.studentId = s.id LEFT JOIN classYears cy ON cy.id = cys.classYearId GROUP BY s.id, cy.yearId) sub GROUP BY sub.firstName, sub.id order by sub.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_135", "db_id": "formula_1", "query": "In the Formula 1 database, I have a table named 'races' that contains information about each race, including the date of the race. I want to create a SELECT statement that not only returns the contents of the 'races' table but also includes an additional column that tells me how many races were held in the same year. For example, if there were 3 races in '2009', then for each race on that date, the 'same_year_races' column should be 3. I can create a separate statement using GROUP BY, but I'm looking for a way to make a single statement that includes the 'same_year_races' column in the results table.", "issue_sql": ["SELECT raceId, name, year, COUNT(*) AS same_year_races FROM races GROUP BY raceid, name, year"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE EmpMgrCTE AS (SELECT id, bossid, salary, 0 as EmployeeLevel, id as baseId, salary as baseSalary FROM staff WHERE bossid IS NOT NULL UNION ALL SELECT emp.id, emp.bossid, emp.salary, mgr.EmployeeLevel + 1 as EmployeeLevel, mgr.baseId, mgr.baseSalary FROM staff emp INNER JOIN EmpMgrCTE mgr ON emp.id = mgr.bossid WHERE baseSalary * 2 > mgr.salary) SELECT emp.baseId, emp.baseSalary, EmployeeLevel, emp.id as bossid, emp.salary as bossSalary FROM EmpMgrCTE emp WHERE baseSalary * 2 <= salary order by baseId;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_136", "db_id": "card_games", "query": "In the card_games database, we have a table named 'card_prices' that records the price changes of cards over time. Each entry includes the timestamp of the price change, the card's UUID, and the new price. When a new price is recorded, we need to take the first price older than 30 days, along with prices from the last 30 days, and return the minimum. When new price came, we should not include in range:  New Price Date: 2022/08/11; 30 days subtracted date: 2022/07/12. However, since price changes are not daily, we must also consider the price before the 30-day window to ensure we capture the correct minimum price. The current query is slow and sometimes returns incorrect results due to the way it handles the 30-day window and the price before it. We need to optimize the query to ensure it runs efficiently and accurately.", "issue_sql": ["SELECT min(price) FROM card_prices WHERE (timestamp >= (SELECT MAX(timestamp) FROM card_prices WHERE timestamp < '2022-07-12T15:30:00-00:00' AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c') OR timestamp >= '2022-07-12T15:30:00-00:00' AND timestamp < '2022-08-11T15:30:00-00:00') AND uuid = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' AND price > 0"], "preprocess_sql": ["CREATE TABLE card_prices (timestamp timestamp with time zone not null, uuid varchar(200) not null, price numeric(12, 2));", "INSERT INTO card_prices (timestamp, uuid, price) VALUES ('2022-07-09 18:18:39.000000 +00:00','5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 120.00), ('2022-07-10 15:45:56.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 125.00), ('2022-07-12 08:00:10.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 130.00), ('2022-07-14 13:15:55.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 135.00), ('2022-07-16 10:33:11.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 140.00), ('2022-07-18 20:18:48.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 145.00), ('2022-07-20 07:40:29.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 150.00), ('2022-07-22 14:11:59.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 155.00), ('2022-07-25 11:55:30.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 160.00), ('2022-07-28 16:05:07.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 165.00), ('2022-07-30 09:40:25.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 170.00), ('2022-08-02 18:30:13.000000 +00:00', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c', 175.00), ('2022-08-05 21:19:40.000000 +00:00','5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c',130.00), ('2022-08-10 11:20:39.000000 +00:00','5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c',140.00);"], "clean_up_sql": ["DROP TABLE card_prices;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["select distinct rarity, first_value(id) over(partition by rarity order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc) from cards;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_137", "db_id": "superhero", "query": "Imagine the following data representing the attribute scores of superheroes over five consecutive years. We are interested in identifying superheroes whose attribute scores have gaps (null values) or have changed from one year to another, or both. The output should include only those superheroes who have gaps or scores different from their maximum score recorded over the years. For example, if a superhero's maximum score in an attribute is 100, and their scores over the years are 100, 90, 100, null, 100, this superhero should be included in the output because of the gap in year 4. Similarly, if a superhero's scores are 100, 90, 100, 100, 100, this superhero should also be included because their score in year 2 is different from their maximum score.", "issue_sql": ["with hero_attribute_data (hero_id, attribute_id, max_score, year_1, year_2, year_3, year_4, year_5) as (values (1, 1, 80, 80, 80, 80, null, 80), (2, 2, 90, 90, 85, 90, 88, 90), (3, 3, 75, 75, 70, null, 75, 75), (4, 4, 60, null, 60, 60, 60, null)), score_check as (select *, case when (max_score <> year_1 or max_score <> year_2 or max_score <> year_3 or max_score <> year_4 or max_score <> year_5) then false else true end as is_a_match from hero_attribute_data) select * from score_check where is_a_match is false"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["DROP TABLE IF EXISTS card, account, disp CASCADE;CREATE TABLE account ( account_id INT PRIMARY KEY NOT NULL, district_id INT NOT NULL, frequency TEXT NOT NULL, date DATE NOT NULL );CREATE TABLE disp ( disp_id INT PRIMARY KEY NOT NULL, client_id INT NOT NULL, account_id INT NOT NULL, type TEXT NOT NULL, FOREIGN KEY (account_id) REFERENCES account(account_id) ON UPDATE CASCADE ON DELETE CASCADE );CREATE OR REPLACE FUNCTION check_account_disp() RETURNS TRIGGER AS $$ BEGIN IF NOT EXISTS (SELECT 1 FROM disp WHERE account_id = OLD.account_id) THEN RAISE EXCEPTION 'Every account has at least one disposition. '; END IF; RETURN OLD; END; $$ LANGUAGE plpgsql;CREATE TRIGGER ensure_account_has_disp BEFORE DELETE ON disp FOR EACH ROW EXECUTE FUNCTION check_account_disp();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    account_results = execute_queries([\"INSERT INTO account (account_id, district_id, frequency, date) VALUES (1, 1, 'MONTHLY', '2020-01-01'), (2, 2, 'MONTHLY', '2024-01-01'), (3, 3, 'MONTHLY', '2024-01-01') RETURNING *;\"], db_name, conn)[0]\n    disp_results = execute_queries([\"INSERT INTO disp (disp_id, client_id, account_id, type) VALUES (1, 1, 1, 'OWNER'), (2, 2, 2, 'OWNER'), (3, 3, 3, 'OWNER') RETURNING *;\"],db_name,conn)[0]\n\n    assert len(account_results) == 3, f'Expected 3 rows, but found {len(account_results)} rows'\n    assert account_results[0][0] == 1, f'Expected account_id to be 1, but found {account_results[0][0]}'\n    assert account_results[1][0] == 2, f'Expected account_id to be 2, but found {account_results[1][0]}'\n    assert account_results[2][0] == 3, f'Expected account_id to be 3, but found {account_results[2][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) AS total FROM disp WHERE account_id = 1;\"],db_name,conn)[0]\n    assert disp_results[0][1] == test_pred_query_result_1[0][0], f'Expected disp count for account_id 1 to be {test_pred_query_result_1[0][0]}, but found {disp_results[0][1]}'\n\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_138", "db_id": "superhero", "query": "In the superhero database, we have a table that represents the crafting recipes for special items used by superheroes. Each item can be bought directly from the store or crafted using other items and resources. The goal is to determine whether it is more cost-effective to buy an item directly or to craft it using the available resources and other items. The table includes the item ID, its retail price, the quantity needed, and the resources or items required to craft it along with their respective prices. We need to calculate both the partial craft price (cost of crafting using only resources) and the full craft price (cost of crafting using both resources and other items). The partial craft price is straightforward to calculate, but the full craft price requires a recursive approach to account for nested dependencies. The user attempted to use a recursive CTE to calculate the full craft price but encountered issues with the query logic. We need to correct the query to accurately compute the full craft price for each item.", "issue_sql": ["select item_id, item_price as retail_price, sum(coalesce(uses_item_price, 0) * quantity) + sum(coalesce(resource_price*quantity, 0))  as partial_craft_price FROM store GROUP BY item_id, retail_price;"], "preprocess_sql": ["CREATE TABLE store ( item_id integer, item_price real, quantity integer, uses_item_id integer, uses_item_price real, resource_id integer, resource_price real );", "INSERT INTO store (item_id, item_price, quantity, uses_item_id, uses_item_price, resource_id, resource_price) VALUES (1, 10000, 10, null, null, 5, 50 ), (1, 10000, 20, null, null, 6, 50 ), (2, 150, 1, 1, 10000, null, null), (2, 150, 5, null, null, 8, 50 ), (3, 5500, 3, null, null, 9, 50 ), (3, 5500, 50, 1, 10000, null, null ), (3, 5500, 1, 2, 150, null, null );"], "clean_up_sql": ["DROP TABLE store;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT COALESCE (ARRAY_AGG (json_build_object ('client_id', client.client_id, 'gender', client.gender, 'birth_date', client.birth_date)) FILTER (WHERE client.client_id IS NOT NULL), ARRAY[]::json[]) AS clients FROM client;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(sol_sqls, db_name, conn)[0];\n    assert pred_query_result_1[0][0] != '[null]', 'Expected an empty array instead of [null] when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n    assert isinstance(pred_query_result_1[0][0], list), 'Expected the result to be a list, but found {type(pred_query_result_1[0][0])}'\n    if len(pred_query_result_1[0][0]) == 0:\n        assert pred_query_result_1[0][0] == '[]', 'Expected an empty array when there are no qualifying rows, but found {pred_query_result_1[0][0]}'\n\n    if len(pred_query_result_1[0][0]) > 0:\n        for item in pred_query_result_1[0][0]:\n            assert 'client_id' in item, 'Each result should have client_id'\n            assert 'gender' in item, 'Each result should have gender'\n            assert 'birth_date' in item, 'Each result should have birth_date'\n            assert item['client_id'] is not None, 'client_id should not be NULL'\n\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_139", "db_id": "superhero", "query": "I want to UPDATE the superhero's full_name in the superhero table using a WHERE clause by team_id = 91 and using JOIN. The main table superhero structure looks like: | id | superhero_name | full_name | The two fields in two more connected tables with the values I need are in team_member and team_member_superhero tables. Table team_member_superhero structure looks like: | id | team_member_id | superhero_id | Table team_member: | id | team_id | superhero_id |", "issue_sql": ["UPDATE superhero SET full_name = 'Superman' JOIN team_member_superhero ON superhero.id = team_member_superhero.superhero_id JOIN team_member ON team_member_superhero.team_member_id = team_member.id WHERE team_id = 91;"], "preprocess_sql": ["CREATE TABLE team_member_superhero (id bigint NOT NULL, team_member_id bigint NULL, superhero_id bigint NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, membership_start_date DATE DEFAULT CURRENT_DATE, membership_end_date DATE DEFAULT NULL, status VARCHAR(50) DEFAULT 'active', notes TEXT DEFAULT NULL, version_number INTEGER DEFAULT 1, created_by VARCHAR(100) DEFAULT 'system', last_modified_by VARCHAR(100) DEFAULT 'system', metadata JSONB DEFAULT '{}'::jsonb, record_uuid UUID DEFAULT gen_random_uuid(), PRIMARY KEY (id))", "CREATE TABLE team_member (id bigint NOT NULL, team_id bigint NULL, joined_date DATE DEFAULT CURRENT_DATE, left_date DATE DEFAULT NULL, is_leader BOOLEAN DEFAULT FALSE, rank VARCHAR(50) DEFAULT 'member', contribution_score NUMERIC(5,2) DEFAULT 0.0, last_active_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, status VARCHAR(50) DEFAULT 'active', notes TEXT DEFAULT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, created_by VARCHAR(100) DEFAULT 'system', record_uuid UUID DEFAULT gen_random_uuid(), metadata JSONB DEFAULT '{}'::jsonb, PRIMARY KEY (id))", "INSERT INTO team_member_superhero (id, team_member_id, superhero_id, created_at, updated_at, is_active, membership_start_date, membership_end_date, status, notes, version_number, created_by, last_modified_by, metadata, record_uuid) VALUES (1, 1, 1, '2023-01-01 00:00:00+00', '2023-01-01 00:00:00+00', TRUE, '2023-01-01', NULL, 'active', 'Original founding member', 1, 'admin', 'admin', '{\"importance\": \"high\", \"founding_member\": true}'::jsonb, 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11')", "INSERT INTO team_member (id, team_id, joined_date, left_date, is_leader, rank, contribution_score, last_active_timestamp, status, notes, created_at, updated_at, created_by, record_uuid, metadata) VALUES (1, 91, '2023-01-01', NULL, TRUE, 'captain', 9.5, '2023-01-01 00:00:00+00', 'active', 'Team leader with exceptional leadership skills', '2023-01-01 00:00:00+00', '2023-01-01 00:00:00+00', 'admin', 'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a12', '{\"security_clearance\": \"level_5\", \"special_abilities\": [\"leadership\", \"strategy\"]}'::jsonb)"], "clean_up_sql": ["UPDATE superhero s SET full_name = 'Charles Chandler' FROM team_member_superhero tms JOIN team_member tm ON tms.team_member_id = tm.id WHERE s.id = tms.superhero_id AND tm.team_id = 91;", "DROP TABLE team_member_superhero;", "DROP TABLE team_member;"], "category": "Management", "efficiency": false, "sol_sql": ["DELETE FROM transactions_1k a\nUSING transactions_1k b\nWHERE a.productid = '5'\n  AND b.productid = '2'\n  AND a.date = b.date\n  AND a.cardid = b.cardid\n  AND a.gasstationid = b.gasstationid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM transactions_1k e WHERE EXISTS (SELECT 1 FROM transactions_1k e2 WHERE e.date = e2.date AND e.time = e2.time AND e.cardid = e2.cardid AND e.gasstationid = e2.gasstationid AND e.productid = '2' AND e2.productid = '5') ORDER BY e.date ASC;\"], db_name,conn)[0]\n    assert len(test_pred_query_result_1) == 0, f'Expected 0 row, but found {len(test_pred_query_result_1)}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_140", "db_id": "european_football_2", "query": "The football league management system requires a report that shows the performance of each team in terms of the number of matches played, victories, defeats, draws, and the total score. The score is calculated by awarding 3 points for a victory, 1 point for a draw, and 0 points for a defeat. The data is stored in the 'team' and 'match' tables. The 'team' table contains the team details, and the 'match' table contains the match details including the goals scored by the home and away teams. The task is to generate a report that includes the team name, number of matches, victories, defeats, draws, and the total score for each team. The user has attempted to write a query but is seeking a more efficient and cleaner solution.", "issue_sql": ["SELECT t.team_long_name, count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id) as matches, count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id AND m.home_team_goal > m.away_team_goal) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id AND m.away_team_goal > m.home_team_goal) as victories, count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id AND m.home_team_goal < m.away_team_goal) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id AND m.away_team_goal < m.home_team_goal) as defeats, count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id AND m.home_team_goal = m.away_team_goal) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id AND m.away_team_goal = m.home_team_goal) as draws, ((count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id AND m.home_team_goal > m.away_team_goal) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id AND m.away_team_goal > m.home_team_goal)) * 3) + count(m.home_team_api_id) filter(WHERE t.team_api_id = m.home_team_api_id AND m.home_team_goal = m.away_team_goal) + count(m.away_team_api_id) filter(WHERE t.team_api_id = m.away_team_api_id AND m.away_team_goal = m.home_team_goal) as score FROM team t JOIN match m ON t.team_api_id IN (m.home_team_api_id, m.away_team_api_id) GROUP BY t.team_long_name ORDER BY victories DESC"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH RECURSIVE cte AS (\n    SELECT id,\n           amount,\n           amount AS cum_sum,\n           1 AS bucket\n    FROM transfer\n    WHERE id = 1\n    UNION ALL\n    SELECT transfer.id,\n           transfer.amount,\n           CASE\n               WHEN cte.cum_sum + transfer.amount > 20 THEN transfer.amount\n               ELSE cte.cum_sum + transfer.amount\n           END AS cum_sum,\n           CASE\n               WHEN cte.cum_sum + transfer.amount > 20 THEN cte.bucket + 1\n               ELSE cte.bucket\n           END AS bucket\n    FROM cte\n    JOIN transfer ON transfer.id = cte.id + 1\n)\nSELECT id, amount, cum_sum, bucket\nFROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = any(row[2] > 20 for row in pred_query_result)\n    assert test_pred_query_result_1 == False, f'Expected not to find any value in cum_sum that is larger than 20, but the result is {test_pred_query_result_1}'\n    ", "\n\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import random\n    random_num = random.randint(2, len(pred_query_result))\n    diff = pred_query_result[random_num][2] - pred_query_result[random_num-1][2]\n    assert (diff == pred_query_result[random_num][1] or pred_query_result[random_num][2] == pred_query_result[random_num][1]), f'Expected to find the cum_sum equal to value or the difference of values, but found {diff}, {pred_query_result[random_num][1]} and {pred_query_result[random_num][2]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_141", "db_id": "thrombosis_prediction", "query": "We have two tables in our thrombosis_prediction database: patient and examination. The patient table contains patient information, and the examination table contains examination results for each patient. We want to create a report that shows each patient's ID and whether they have had an examination with specific diagnoses (e.g., 'SLE', 'PSS', 'RA susp.') recorded. The result should be a table with patient IDs and columns for each diagnosis, indicating TRUE if the patient has had an examination with that diagnosis and FALSE otherwise. The user attempted to write a query but encountered issues with multiple rows for each patient and incorrect TRUE/FALSE values.", "issue_sql": ["SELECT p.id, CASE WHEN e.id = p.id AND e.diagnosis = 'SLE' THEN TRUE ELSE FALSE END AS SLE, CASE WHEN e.id = p.id AND e.diagnosis = 'PSS' THEN TRUE ELSE FALSE END AS PSS, CASE WHEN e.id = p.id AND e.diagnosis = 'RA susp.' THEN TRUE ELSE FALSE END AS RA_susp FROM patient p LEFT JOIN examination e ON p.id = e.id WHERE e.diagnosis IN ('SLE', 'PSS', 'RA susp.') ORDER BY p.id DESC"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT raceid, laps AS modal_laps FROM (SELECT raceid, laps, COUNT(*) AS freq, MIN(resultid) AS first_occurrence, ROW_NUMBER() OVER (PARTITION BY raceid ORDER BY COUNT(*) DESC, MIN(resultid) ASC) AS rn FROM results GROUP BY raceid, laps) sub WHERE rn = 1 ORDER BY raceid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_142", "db_id": "superhero", "query": "We have two tables in our superhero database, 'hero_birth_info' and 'hero_birth_info_alt'. The 'hero_birth_info' table contains the birthdate of superheroes, while the 'hero_birth_info_alt' table contains an alternative date of birth for some superheroes. We need to combine these two tables to get a single birth date for each superhero, prioritizing the date from 'hero_birth_info_alt' if it exists. However, when we run the following query, we get incorrect results where the birthdate from 'hero_birth_info_alt' is not correctly combined with the birthdate from 'hero_birth_info'.", "issue_sql": ["SELECT hbi.id, hbi.hero_name, hbi.birthdate, hbialt.date_of_birth FROM hero_birth_info hbi LEFT JOIN hero_birth_info_alt hbialt ON hbi.id = hbialt.id"], "preprocess_sql": ["CREATE TABLE hero_birth_info (id bigint NOT NULL, hero_name text NULL, birthdate date NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, origin_story TEXT DEFAULT 'Unknown origin', power_level INTEGER DEFAULT 5, is_active BOOLEAN DEFAULT true, last_appearance_date DATE DEFAULT NULL, secret_identity_known BOOLEAN DEFAULT false, universe_designation VARCHAR(50) DEFAULT 'Earth-616', metadata JSONB DEFAULT '{}'::jsonb, version_number INTEGER DEFAULT 1, notes TEXT DEFAULT NULL, popularity_rating NUMERIC(5,2) DEFAULT 0.0, PRIMARY KEY (id))", "INSERT INTO hero_birth_info (id, hero_name, birthdate, created_at, updated_at, origin_story, power_level, is_active, last_appearance_date, secret_identity_known, universe_designation, metadata, version_number, notes, popularity_rating) VALUES (1, 'Sylvie', '2016-06-01', '2023-01-01 12:00:00+00', '2023-01-01 12:00:00+00', 'Born with magical abilities', 7, true, '2023-05-15', true, 'Earth-616', '{\"abilities\": [\"magic\", \"illusion\"]}'::jsonb, 1, 'Potential future storyline development', 8.5), (2, 'Rolf', NULL, '2023-01-02 12:00:00+00', '2023-01-02 12:00:00+00', 'Mysterious past', 6, true, '2023-04-20', false, 'Earth-199999', '{\"abilities\": [\"strength\", \"durability\"]}'::jsonb, 1, 'Background character with potential', 7.2), (3, 'Jose', '2004-02-16', '2023-01-03 12:00:00+00', '2023-01-03 12:00:00+00', 'Gained powers in lab accident', 8, true, '2023-06-01', true, 'Earth-616', '{\"abilities\": [\"speed\", \"agility\"]}'::jsonb, 2, 'Popular character with fans', 9.1), (4, 'Eugin', NULL, '2023-01-04 12:00:00+00', '2023-01-04 12:00:00+00', 'Alien heritage', 9, true, '2023-05-22', false, 'Earth-616', '{\"abilities\": [\"flight\", \"energy projection\"]}'::jsonb, 1, 'Complex backstory being developed', 8.3), (5, 'Andrey', '1998-09-29', '2023-01-05 12:00:00+00', '2023-01-05 12:00:00+00', 'Cybernetically enhanced', 7, true, '2023-06-10', true, 'Earth-199999', '{\"abilities\": [\"hacking\", \"enhanced intelligence\"]}'::jsonb, 3, 'Tech-based hero', 8.7), (6, 'Ivan', '2000-05-12', '2023-01-06 12:00:00+00', '2023-01-06 12:00:00+00', 'Trained by ancient order', 6, false, '2022-12-15', false, 'Earth-616', '{\"abilities\": [\"martial arts\", \"stealth\"]}'::jsonb, 1, 'Currently on hiatus in storyline', 7.5), (7, 'Vasiys', '2001-07-17', '2023-01-07 12:00:00+00', '2023-01-07 12:00:00+00', 'Mutant abilities', 8, true, '2023-06-05', true, 'Earth-616', '{\"abilities\": [\"telepathy\", \"telekinesis\"]}'::jsonb, 2, 'Rising star character', 8.9), (8, 'Alexey', '1993-09-05', '2023-01-08 12:00:00+00', '2023-01-08 12:00:00+00', 'Cosmic event exposure', 9, true, '2023-06-12', false, 'Earth-199999', '{\"abilities\": [\"energy manipulation\", \"invulnerability\"]}'::jsonb, 1, 'Powerful cosmic-level hero', 9.3)", "CREATE TABLE hero_birth_info_alt (id bigint NOT NULL, hero_name text NULL, date_of_birth date NULL, verification_status VARCHAR(50) DEFAULT 'unverified', source_reliability INTEGER DEFAULT 3, last_verified_date TIMESTAMP WITH TIME ZONE DEFAULT NULL, verification_notes TEXT DEFAULT NULL, conflicting_records BOOLEAN DEFAULT false, record_confidence_score NUMERIC(5,2) DEFAULT 5.0, created_by VARCHAR(100) DEFAULT 'system', created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, data_source VARCHAR(200) DEFAULT 'internal database', record_version INTEGER DEFAULT 1, PRIMARY KEY (id))", "INSERT INTO hero_birth_info_alt (id, hero_name, date_of_birth, verification_status, source_reliability, last_verified_date, verification_notes, conflicting_records, record_confidence_score, created_by, created_at, updated_at, data_source, record_version) VALUES (1, 'Sylvie', NULL, 'pending', 2, '2023-01-15 09:30:00+00', 'Birth records sealed by government agency', true, 3.5, 'data_analyst_1', '2023-01-01 10:00:00+00', '2023-01-15 09:30:00+00', 'SHIELD archives', 2), (2, 'Rolf', '2015-12-06', 'verified', 4, '2023-02-10 14:45:00+00', 'Birth certificate obtained from Asgardian records', false, 8.7, 'historian_42', '2023-01-02 11:15:00+00', '2023-02-10 14:45:00+00', 'Asgardian Hall of Records', 1), (3, 'Jose', NULL, 'disputed', 2, '2023-01-20 16:20:00+00', 'Multiple conflicting records exist', true, 4.2, 'researcher_7', '2023-01-03 09:45:00+00', '2023-01-20 16:20:00+00', 'Public records database', 3), (4, 'Eugin', '1995-04-01', 'verified', 5, '2023-03-05 11:10:00+00', 'Confirmed by multiple reliable sources', false, 9.5, 'archivist_15', '2023-01-04 13:30:00+00', '2023-03-05 11:10:00+00', 'Avengers database', 1), (5, 'Andrey', '1998-09-29', 'verified', 5, '2023-02-28 10:00:00+00', 'Date matches across all known records', false, 9.8, 'data_analyst_1', '2023-01-05 15:45:00+00', '2023-02-28 10:00:00+00', 'Multiple verified sources', 2)"], "clean_up_sql": ["DROP TABLE hero_birth_info;", "DROP TABLE hero_birth_info_alt;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT CASE WHEN t1.table_name IS NULL THEN 'extra' ELSE 'missing' END AS kind, table_name FROM required_tables t1 FULL JOIN (SELECT table_name FROM information_schema.tables WHERE  table_schema='public') t2 USING (table_name) WHERE (t1.table_name IS NULL OR t2.table_name IS NULL);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_143", "db_id": "superhero", "query": "In the superhero database, there are instances where the hair_colour_ids of superheroes within the same publisher are not contiguous due to deletions. To address this, I want to create a function that will reindex these hair_colour_ids to make them contiguous again. The function should take a publisher ID as input and reindex the hair_colour_ids of superheroes belonging to that publisher. I attempted to create a function that uses a temporary sequence to achieve this, but encountered an error when trying to use the sequence within the function. The error message was 'relation &quot;id_seq_temp&quot; does not exist'. I tried creating the sequence outside the function, but I prefer to keep the sequence within the function for cleaner code. Here is my function, with some names anonymized for privacy reasons.", "issue_sql": ["CREATE OR REPLACE FUNCTION reindex_superhero_ids(IN BIGINT) RETURNS VOID LANGUAGE SQL AS $$ CREATE TEMPORARY SEQUENCE id_seq_temp MINVALUE 1 START WITH 1 INCREMENT BY 1; ALTER SEQUENCE id_seq_temp RESTART; UPDATE superhero SET hair_colour_id=hair_colour_id+2000 WHERE publisher_id=$1; UPDATE superhero SET hair_colour_id=nextval('id_seq_temp') WHERE publisher_id=$1; $$;"], "preprocess_sql": [], "clean_up_sql": ["DROP FUNCTION IF EXISTS reindex_superhero_ids(BIGINT);", "UPDATE superhero SET hair_colour_id = 1 WHERE publisher_id = 9;"], "category": "Management", "efficiency": false, "sol_sql": ["ALTER TABLE dependency DROP CONSTRAINT dependency_match1_stage1_fkey, DROP CONSTRAINT dependency_match2_stage2_fkey;", "ALTER TABLE dependency ADD CONSTRAINT dependency_match1_stage1_fkey FOREIGN KEY (match1, stage1) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE, ADD CONSTRAINT dependency_match2_stage2_fkey FOREIGN KEY (match2, stage2) REFERENCES match (id, stage) ON DELETE CASCADE ON UPDATE CASCADE;", "UPDATE match SET stage = stage + 1 WHERE id = 'match1';"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries([\"SELECT * FROM match WHERE id = 'match1';\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result[0][1] == 2, 'The update does not happen.'\n    test_pred_query_result_1 = execute_queries([\"SELECT * FROM dependency;\"], 'european_football_2', conn)[0]\n    assert test_pred_query_result_1[0][1] == 2, 'The update does not happen in dependency.'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_144", "db_id": "card_games", "query": "In the card_games database, a table named card_versions was created to track different versions of a card with a unique sequence number, definition ID, attribute ID, and input data. The primary key is a composite key consisting of defn_id, attr_id, and seqnr. Records were inserted into the card_versions table with sequential seqnr values for a specific defn_id and attr_id. When attempting to update the seqnr values by incrementing them for all records with defn_id = 100 and attr_id = 100, an error occurred in PostgreSQL due to the immediate uniqueness constraint check on the primary key. The task is to reproduce this issue and provide a solution to update the seqnr values without violating the primary key constraint.", "issue_sql": ["UPDATE card_versions SET seqnr=seqnr+1 WHERE defn_id = 100 AND attr_id = 100 AND seqnr >= 1"], "preprocess_sql": ["CREATE TABLE card_versions(\n  seqnr smallint NOT NULL, \n  defn_id int NOT NULL, \n  attr_id int NOT NULL, \n  input CHAR(50) NOT NULL, \n  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, \n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, \n  is_active BOOLEAN DEFAULT TRUE, \n  version_notes TEXT DEFAULT NULL, \n  modified_by VARCHAR(100) DEFAULT 'system', \n  revision_count INTEGER DEFAULT 0, \n  last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT NULL, \n  metadata JSONB DEFAULT '{}'::jsonb, \n  version_hash UUID DEFAULT gen_random_uuid(), \n  approval_status VARCHAR(20) DEFAULT 'pending', \n  expiration_date DATE DEFAULT NULL, \n  CONSTRAINT pk_card_versions PRIMARY KEY (defn_id, attr_id, seqnr)\n);", "INSERT INTO card_versions(seqnr, defn_id, attr_id, input, created_at, updated_at, is_active, version_notes, modified_by, revision_count, last_accessed_at, metadata, version_hash, approval_status, expiration_date) VALUES \n(1, 100, 100, 'test1', '2023-01-01 10:00:00+00', '2023-01-01 10:00:00+00', TRUE, 'Initial version', 'admin', 0, '2023-01-02 15:30:00+00', '{\"source\": \"manual\", \"importance\": \"high\"}'::jsonb, 'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', 'approved', '2024-01-01'), \n(2, 100, 100, 'test2', '2023-01-02 11:15:00+00', '2023-01-02 11:15:00+00', TRUE, 'Second version', 'editor', 1, '2023-01-03 09:45:00+00', '{\"source\": \"api\", \"importance\": \"medium\"}'::jsonb, 'b0eebc99-9c0b-4ef8-bb6d-6bb9bd380a22', 'approved', '2024-02-01'), \n(3, 100, 100, 'test3', '2023-01-03 14:30:00+00', '2023-01-03 14:30:00+00', TRUE, 'Third version', 'admin', 2, '2023-01-04 16:20:00+00', '{\"source\": \"import\", \"importance\": \"low\"}'::jsonb, 'c0eebc99-9c0b-4ef8-bb6d-6bb9bd380a33', 'approved', '2024-03-01'), \n(4, 100, 100, 'test4', '2023-01-04 09:45:00+00', '2023-01-04 09:45:00+00', TRUE, 'Fourth version', 'editor', 1, '2023-01-05 11:10:00+00', '{\"source\": \"manual\", \"importance\": \"high\"}'::jsonb, 'd0eebc99-9c0b-4ef8-bb6d-6bb9bd380a44', 'pending', '2024-04-01'), \n(5, 100, 100, 'test5', '2023-01-05 16:20:00+00', '2023-01-05 16:20:00+00', FALSE, 'Fifth version', 'admin', 3, '2023-01-06 14:30:00+00', '{\"source\": \"api\", \"importance\": \"critical\"}'::jsonb, 'e0eebc99-9c0b-4ef8-bb6d-6bb9bd380a55', 'rejected', '2024-05-01');"], "clean_up_sql": ["DROP TABLE card_versions;"], "category": "Management", "efficiency": false, "sol_sql": ["with hero_attribute(hero_id, attribute_id, attribute_value) as ( values (1, 1, 80), (2, 1, 75), (3, 1, 95), (4, 1, 85), (5, 1, 90), (6, 1, 70) ), running as ( select hero_id, sum(attribute_value) over (order by hero_id rows between 2 preceding and 3 following) from hero_attribute) select sum from running where (hero_id-1) % 2 = 0;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_145", "db_id": "european_football_2", "query": "As part of an analysis for a football analytics project, I need to create a JSONB column in the 'team_attributes' table that consolidates several existing attributes into a single JSONB object. Initially, I attempted to use the following query to populate this JSONB column with values from other columns in the same table:", "issue_sql": ["UPDATE team_attributes SET attributes_jsonb = jsonb_insert('{}', '{buildupplayspeed}', buildupplayspeed) WHERE team_api_id = 1773;", "SELECT id, attributes_jsonb FROM team_attributes WHERE team_api_id = 1773 ORDER BY id;"], "preprocess_sql": ["ALTER TABLE team_attributes ADD COLUMN attributes_jsonb jsonb"], "clean_up_sql": ["ALTER TABLE team_attributes DROP COLUMN attributes_jsonb"], "category": "Management", "efficiency": false, "sol_sql": ["select id, name, jsonb_path_query_array(skills::jsonb,'$[*].description') as skill from player_skills;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    for row in pred_query_result:\n        if row[0] == 1:\n            skill = row[2]\n            assert skill == [\"Passing\", \"Shooting\"], \"ID 1 returns wrong skills.\"\n        elif row[0] == 2:\n            skill = row[2]\n            assert skill == [\"Defending\", \"Tackling\"], \"ID 2 returns wrong skills.\"\n        else:\n            skill = row[2]\n            assert skill == [], \"ID 3 returns wrong skills.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_146", "db_id": "toxicology", "query": "In the toxicology database, we need to identify all ancestor atoms of a given atom using the 'connection' table, which contains the relationships between atoms through bonds. Each atom is linked to its parent atom via the 'atom_id' and 'parent_id' fields in the 'connection' table. Additionally, each atom has an 'enabled' status in the table, which indicates whether the atom is active or not. If any ancestor atom of a given atom has its 'enabled' status set to false, the query should return no results for that atom. For example, if we are querying for all ancestor atoms of atom 'TR000_4', and any of its ancestor atoms have 'enabled' set to false, the query should return no results.", "issue_sql": ["WITH RECURSIVE atom_ancestors AS ( SELECT atom_id, parent_id, enabled FROM connection WHERE atom_id = 4 UNION ALL SELECT c.atom_id, c.parent_id, c.enabled FROM connection c INNER JOIN atom_ancestors aa ON c.atom_id = aa.parent_id) SELECT * FROM atom_ancestors"], "preprocess_sql": ["CREATE TABLE connection (\n  atom_id integer,\n  parent_id integer,\n  enabled boolean,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  connection_strength NUMERIC(5,2) DEFAULT 1.0,\n  bond_length_angstrom NUMERIC(8,4) DEFAULT 0.0,\n  connection_type VARCHAR(50) DEFAULT 'covalent',\n  stability_factor INTEGER DEFAULT 100,\n  is_verified BOOLEAN DEFAULT false,\n  verification_date DATE DEFAULT NULL,\n  notes TEXT DEFAULT NULL,\n  metadata JSONB DEFAULT '{}'::jsonb,\n  connection_uuid UUID DEFAULT gen_random_uuid(),\n  version_number INTEGER DEFAULT 1,\n  last_analyzed_by VARCHAR(100) DEFAULT 'system',\n  energy_level NUMERIC(10,4) DEFAULT 0.0,\n  is_deprecated BOOLEAN DEFAULT false,\n  priority_score INTEGER DEFAULT 5,\n  connection_hash VARCHAR(64) DEFAULT NULL\n)", "INSERT INTO connection (atom_id, parent_id, enabled, created_at, updated_at, connection_strength, bond_length_angstrom, connection_type, stability_factor, is_verified, verification_date, notes, metadata, connection_uuid, version_number, last_analyzed_by, energy_level, is_deprecated, priority_score, connection_hash) VALUES \n(1, null, true, '2023-01-01T00:00:00Z', '2023-01-01T00:00:00Z', 1.5, 1.2345, 'covalent', 95, true, '2023-01-01', 'Root atom connection', '{\"source\": \"initial_import\"}'::jsonb, 'a1b2c3d4-e5f6-4a5b-9c8d-1e2f3a4b5c6d', 1, 'admin', 0.0, false, 10, 'hash1'), \n(2, 1, false, '2023-01-02T00:00:00Z', '2023-01-02T00:00:00Z', 0.8, 2.3456, 'ionic', 75, true, '2023-01-02', 'Disabled connection', '{\"reason\": \"unstable_bond\"}'::jsonb, 'b2c3d4e5-f6a7-5b6c-0d1e-2f3a4b5c6d7e', 1, 'researcher1', 1.2, false, 3, 'hash2'), \n(3, 1, true, '2023-01-03T00:00:00Z', '2023-01-03T00:00:00Z', 2.0, 1.7890, 'covalent', 98, true, '2023-01-03', 'Strong connection', '{\"stability\": \"high\"}'::jsonb, 'c3d4e5f6-a7b8-6c7d-1e2f-3a4b5c6d7e8f', 1, 'researcher2', 0.5, false, 8, 'hash3'), \n(4, 2, true, '2023-01-04T00:00:00Z', '2023-01-04T00:00:00Z', 1.2, 1.5678, 'hydrogen', 85, false, NULL, 'Pending verification', '{\"status\": \"pending_review\"}'::jsonb, 'd4e5f6a7-b8c9-7d8e-2f3a-4b5c6d7e8f9a', 1, 'system', 0.8, false, 5, 'hash4');"], "clean_up_sql": ["DROP TABLE connection;"], "category": "Personalization", "efficiency": false, "sol_sql": ["select (select tt.value from json_array_elements(t.events) as tt where tt->>'id' = '2') FROM match_events as t;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert pred_query_result[0][0] == {\"id\": 2, \"description\": \"Yellow Card\"}, \"Wrong result 1.\"\n    assert pred_query_result[1][0] == {\"id\": 2, \"description\": \"Goal\"}, \"Wrong result 2.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_147", "db_id": "card_games", "query": "\nIs there an efficient way to aggregate data from a JSONB column in PostgreSQL? Given the table card_preference(customerid STRING, preference JSONB) and the data in the table. As you notice, I want unique values of keys (for example, \"dis\") across all records, grouped by customerid. I tried extracting values using jsonb_agg and jsonb_array_elements, but I couldnt aggregate all keys and distinct values correctly. I also couldn't figure out how to use jsonb_each to get all keys. What I tried is something like this to get a single key. Any help with the query is appreciated.\n", "issue_sql": ["select customerid,\n       (select jsonb_agg(t->>'dis') from jsonb_array_elements(preference::jsonb) as x(t) where t->>'dis' is not null) as sdata\nfrom card_preference where customerid='123.abc'"], "preprocess_sql": ["\nCREATE TABLE card_preference (\n    customerid TEXT NOT NULL,\n    preference JSONB NOT NULL\n);\nINSERT INTO card_preference (customerid, preference)\nVALUES\n    ('123.abc', '{\"dis\": [\"close\"]}'),\n    ('123.abc', '{\"purpose\": {\"score\": 0.1, \"text\": \"hi\"}, \"dis\": [\"hello\", \"close\"]}'),\n    ('123.abc', '{\"dis\": [\"bye\"], \"dir\": 1}'),\n    ('123.abc', '{}'),\n    ('567.bhy', '{\"dis\": [\"close\"]}');\n"], "clean_up_sql": ["drop table card_preference"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT DISTINCT ON (examination_year) c, \"ANA Pattern\", examination_year FROM (SELECT COUNT(\"ANA Pattern\") AS c, \"ANA Pattern\", EXTRACT(YEAR FROM \"Examination Date\") AS examination_year FROM examination WHERE EXTRACT(YEAR FROM \"Examination Date\") BETWEEN 1993 AND 1996 GROUP BY EXTRACT(YEAR FROM \"Examination Date\"), \"ANA Pattern\") AS sub ORDER BY examination_year, c DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 4, f'Expected 4 rows, but found {len(pred_query_result)} rows.' \n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_148", "db_id": "superhero", "query": "In the superhero database, we have a table named 'hero_attribute' that stores the attribute values for each superhero. Each superhero can have multiple attributes, and each attribute can have different values for different superheroes. The goal is to identify any differences in attribute values for the same superhero across different records. For example, if a superhero has different values for the same attribute in different records, we need to flag that attribute for that superhero. The outcome should be a list of superheroes with the attribute names that have differences.", "issue_sql": ["SELECT hero_id, 'attribute_value' AS Difference FROM hero_attribute\nGROUP BY hero_id HAVING COUNT(DISTINCT attribute_value) > 1\nOR (COUNT(attribute_value) != COUNT(*) AND COUNT(DISTINCT attribute_value) > 0)\nUNION ALL SELECT hero_id, 'attribute_id' AS Difference FROM hero_attribute GROUP BY hero_id\nHAVING COUNT(DISTINCT attribute_id) > 1 OR (COUNT(attribute_id) != COUNT(*)\nAND COUNT(DISTINCT attribute_id) > 0)"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH player_names AS (SELECT 1 AS source, ROW_NUMBER() OVER (ORDER BY player_name) AS row_number, CONCAT(player_name, '(', LEFT(birthday, 4), ')') AS dest FROM player_table), birth_year_summary AS (SELECT 2 AS source, ROW_NUMBER() OVER (ORDER BY COUNT(*), LEFT(birthday, 4)) AS row_number, CONCAT('There are a total of ', COUNT(*), ' player', CASE WHEN COUNT(*) > 1 THEN 's' ELSE '' END, ' born in ', LEFT(birthday, 4), '.') AS dest FROM player_table GROUP BY LEFT(birthday, 4)) SELECT dest FROM (SELECT * FROM player_names UNION ALL SELECT * FROM birth_year_summary) AS combined_results ORDER BY source, row_number;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    for i in range(len(sol_query_result)):\n        assert pred_query_result[i] == sol_query_result[i], 'Wrong order.' \n        return\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_149", "db_id": "student_club", "query": "In the student_club database, there is a table named `member` with the following columns: `member_id` (primary key), `first_name`, `last_name`, `email`, `position`, `t_shirt_size`, `phone`, `zip`, and `link_to_major`. The `link_to_major` column has a `NOT NULL` constraint. The user attempted to insert a new member into the `member` table with the following query:\n\nsql\nINSERT INTO member(member_id, first_name, last_name)\nVALUES ('new_member_id', 'John', 'Doe', 'rec06DF6vZ1CyPKpc')\nON CONFLICT (member_id)\nDO UPDATE SET first_name=excluded.first_name, last_name=excluded.last_name;\n\n\nHowever, the query resulted in an error because the `link_to_major` column, which has a `NOT NULL` constraint, was not provided a value. The error message from PostgreSQL was:\n\n> ERROR:  null value in column \"link_to_major\" of relation \"member\" violates not-null constraint\n\nThe user expected the `ON CONFLICT` clause to handle the update without requiring a value for `link_to_major`, but this did not happen. The user is unsure why the `NOT NULL` constraint is being enforced during the `ON CONFLICT` update, even though the column has a value in the existing row.", "issue_sql": ["INSERT INTO member(member_id, first_name, last_name) VALUES ('new_member_id', 'John', 'Doe','rec06DF6vZ1CyPKpc') ON CONFLICT (member_id) DO UPDATE SET first_name=excluded.first_name, last_name=excluded.last_name;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT rs.raceId as race_id, (SELECT string_agg(constructorId::TEXT, ',' ORDER BY res.resultId) FROM results res WHERE res.raceId = rs.raceId) as constructor_ids, (SELECT string_agg(p.stop::TEXT, ', ' ORDER BY p.raceId) FROM pitstops p WHERE rs.raceId = p.raceId) AS stops FROM races rs"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_150", "db_id": "student_club", "query": "I have a table called `event` that stores `event_id` and `event_date`. I want to grab the most recent 'streak' for an event with a given name. A 'streak' is the number of consecutive days that the event has occurred at least once. An event may occur more than once a day. Big gotcha: The streak should also take into account a given timezone. Given a query for 'April Meeting' in 'MST' timezone, I'd expect the streak to be: | Streak Count | Name | TimeZone | Start Date | End Date |. However, my current query is not working as expected and I'm not sure why. Here's the problematic SQL statement I used:", "issue_sql": ["SELECT COUNT(*) AS streak_count, 'April Meeting' AS event_name, 'MST' AS timezone, MIN(event_date) AS start_date, MAX(event_date) AS end_date FROM attendance WHERE event_name = 'April Meeting' GROUP BY DATE_TRUNC('day', event_date AT TIME ZONE 'UTC' AT TIME ZONE 'MST') ORDER BY end_date DESC LIMIT 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT r.* FROM route r WHERE EXISTS(SELECT 1 FROM route_detail rd WHERE r.id = rd.route_id AND rd.visit_status = 5) AND NOT EXISTS(SELECT 1 FROM route_detail rd INNER JOIN route_event e ON rd.id = e.route_detail_id WHERE r.id = rd.route_id AND e.event_type = 3);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_sqls_result) == 2, f\"Expected 2 rows in pred_result but found {len(pred_sqls_result)} rows.\"\n    assert pred_sqls_result[0][0] == 4, f'Expected route 4, but found route {pred_sqls_result[0][0]}'\n    assert pred_sqls_result[1][0] == 5, f'Expected route 5, but found route {pred_sqls_result[1][0]}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_151", "db_id": "formula_1", "query": "We have a table named 'pitstops' that stores pit stop data for Formula 1 races, including a column 'transaction_timestamp' which records the timestamp of each pit stop in nanoseconds. We need to group and count the number of pit stops by day. We attempted to convert the nanosecond timestamp to milliseconds and then use DATE_TRUNC to group by day, but encountered errors in our SQL queries.", "issue_sql": ["SELECT DATE_TRUNC('day', to_timestamp(transaction_timestamp / 1000000000.0)), COUNT(*) FROM pitstops GROUP BY DATE_TRUNC('day', transaction_timestamp)"], "preprocess_sql": ["ALTER TABLE pitstops ADD COLUMN transaction_timestamp bigint;", "UPDATE pitstops SET transaction_timestamp = EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000000000 + (random() * 1000000000)::bigint;"], "clean_up_sql": ["ALTER TABLE pitstops DROP COLUMN transaction_timestamp;"], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION update_team_attributes_eff_to() RETURNS TRIGGER AS $$ BEGIN UPDATE team_attributes SET eff_to = subquery.next_date FROM ( SELECT id, team_api_id, COALESCE(LEAD(TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE, 1) OVER (PARTITION BY team_api_id ORDER BY TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE ASC), TO_DATE('6000-00-00', 'YYYY-MM-DD')) - 1 AS next_date FROM team_attributes ) AS subquery WHERE team_attributes.team_api_id = subquery.team_api_id AND team_attributes.id = subquery.id; RETURN NEW; END; $$ LANGUAGE plpgsql;CREATE OR REPLACE TRIGGER after_insert_team_attributes AFTER INSERT ON team_attributes FOR EACH ROW EXECUTE PROCEDURE update_team_attributes_eff_to();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"INSERT INTO team_attributes (team_api_id, date) VALUES (9930, '2010-09-08 00:00:00'), (9930, '2014-09-08 00:00:00'), (9930, '2015-09-08 00:00:00')\"], db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT date, eff_to FROM team_attributes WHERE team_api_id = 9930;\"], db_name, conn)[0]\n    assert set((str(date), str(eff_to)) for date, eff_to in pred_sqls_result) == set((str(date), str(eff_to)) for date, eff_to in [(\"2014-09-08 00:00:00\", \"2014-09-18\"), (\"2015-09-08 00:00:00\", \"2015-09-09\"), (\"2010-02-22 00:00:00\", \"2010-09-07\"), (\"2010-09-08 00:00:00\", \"2014-09-07\"), (\"2014-09-19 00:00:00\", \"2015-09-07\"), (\"2015-09-10 00:00:00\", \"5999-12-31\")]), f\"Expected pred_result and sol_result to be the same, but pred_result is {pred_sqls_result} and sol_result is [('2014-09-08 00:00:00', '2014-09-18'), ('2015-09-08 00:00:00', '2015-09-09'), ('2010-02-22 00:00:00', '2010-09-07'), ('2010-09-08 00:00:00', '2014-09-07'), ('2014-09-19 00:00:00', '2015-09-07'), ('2015-09-10 00:00:00', '5999-12-31')].\""]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_152", "db_id": "thrombosis_prediction", "query": "I am trying to obtain the laboratory test results for each patient where the values of 'got' and 'gpt' at the minimum end_date are equal to the values of 'got' and 'gpt' at the maximum end_date, grouped by patient id. My current query only obtains the laboratory test results from the maximum end_date for each patient, but I need the row minimum end_date where 'got' and 'gpt 'match the 'got' and 'gpt' in the maximum end_date, grouped by patient id.", "issue_sql": ["select a.id, a.date, a.got, a.gpt from laboratory as a inner join ( select id, max(date) as date from laboratory group by id ) as b on a.id = b.id and a.date = b.date order by id, date"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["select position, array_agg(driverid) as driverids from results where driverid not in (select max(driverid) from results group by position) group by position order by position;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_153", "db_id": "formula_1", "query": "In the Formula 1 database, we need to generate a report that lists the financial roles associated with each race based on the roles of the constructors in that race. Each race can have multiple constructors, and each constructor can have multiple roles such as 'AR (Customer Billing)', 'AP (Commander)', and 'AP (Agent)'. The roles are determined by the constructor's performance and participation in the race. The issue arises when a constructor has multiple roles in a race, and the query only considers the first true value, ignoring the others. We need to ensure that all roles for each constructor in a race are considered and listed in the report.", "issue_sql": ["WITH constructor_roles AS ( SELECT 18 race_id, 1 constructor_id, false customer_billing, true commander, true agent UNION ALL SELECT 18, 2, true, false, false ) SELECT n.race_id, string_agg(distinct CASE WHEN n.customer_billing = TRUE THEN 'AR (Customer Billing)' WHEN n.commander = TRUE THEN 'AP (Commander)' WHEN n.agent = TRUE THEN 'AP (Agent)' ELSE NULL END, ', ') AS finance FROM constructor_roles n WHERE n.race_id = 18 AND (n.customer_billing = TRUE or n.commander = TRUE or n.agent = TRUE) GROUP BY race_id"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["DO $do$ DECLARE _max_depth int := (SELECT max(length(id::text)) - 1 FROM superhero2); _depth int; BEGIN FOR _depth IN REVERSE _max_depth .. 1 LOOP UPDATE superhero2 p SET color = c.color FROM (SELECT parent_id AS parent, CASE WHEN min(color) = max(color) THEN min(color) ELSE 'gray' END AS color FROM superhero2 WHERE length(id::text) = _depth + 1 GROUP BY parent_id) c WHERE p.id = c.parent AND p.color IS DISTINCT FROM c.color; END LOOP; END $do$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"select * from superhero2;\"], db_name, conn)[0]\n    assert set(pred_sqls_result) == set(sol_sqls_result), f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_154", "db_id": "california_schools", "query": "A school district is analyzing the academic performance of students across different years and classes. They have a database with tables that track students, the years they attended, and the classes they took. The district wants to generate a report that lists each student's first name along with the years they attended and the classes they took in each year. The current query is producing duplicate entries for years when a student takes multiple classes in the same year. The goal is to merge these entries so that each year appears only once with all the classes listed under it.", "issue_sql": ["SELECT s.firstName, jsonb_agg(DISTINCT jsonb_build_object('yearId', y.id, 'classes', (SELECT jsonb_agg(jsonb_build_object('classId', c.id)) FROM classes AS c WHERE y.id = cy.yearId AND c.id = cy.classId AND s.id = cys.studentId))) AS years FROM users3 AS s LEFT JOIN classYearStudents AS cys ON cys.studentId = s.id LEFT JOIN classYears AS cy ON cy.id = cys.classYearId LEFT JOIN years AS y ON y.id = cy.yearId GROUP BY s.id order by s.id"], "preprocess_sql": ["CREATE TABLE users3 (id SERIAL PRIMARY KEY, firstName TEXT);", "CREATE TABLE years (id UUID PRIMARY KEY);", "CREATE TABLE classes (id UUID PRIMARY KEY);", "CREATE TABLE classYears (id SERIAL PRIMARY KEY, yearId UUID, classId UUID);", "CREATE TABLE classYearStudents (id SERIAL PRIMARY KEY, studentId INT, classYearId INT);", "INSERT INTO users3 (firstName) VALUES ('Jarrell'), ('Kevon'), ('Antone');", "INSERT INTO years (id) VALUES ('bd5b69ac-6638-4d3e-8a52-94c24ed9a039'), ('7f5789b5-999e-45e4-aba4-9f45b29a69ef');", "INSERT INTO classes (id) VALUES ('2590b596-e894-4af5-8ac5-68d109eee995'), ('fe4a11f2-5f38-4f7a-bbce-609bc7ad8f99'), ('c8cda7d1-7321-443c-b0ad-6d18451613b5');", "INSERT INTO classYears (yearId, classId) VALUES ('bd5b69ac-6638-4d3e-8a52-94c24ed9a039', '2590b596-e894-4af5-8ac5-68d109eee995'), ('bd5b69ac-6638-4d3e-8a52-94c24ed9a039', 'fe4a11f2-5f38-4f7a-bbce-609bc7ad8f99'), ('7f5789b5-999e-45e4-aba4-9f45b29a69ef', 'c8cda7d1-7321-443c-b0ad-6d18451613b5');", "INSERT INTO classYearStudents (studentId, classYearId) VALUES (1, 1), (1, 2), (2, 3), (2, 1), (2, 2), (3, 3), (3, 1), (3, 2);"], "clean_up_sql": ["DROP TABLE users3;", "DROP TABLE years;", "DROP TABLE classes;", "DROP TABLE classYears;", "DROP TABLE classYearStudents;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT artist, setcode, COUNT(setcode) AS counter\nFROM cards\nGROUP BY artist, setcode\nORDER BY MAX(COUNT(*)) OVER (PARTITION BY artist) DESC, artist, COUNT(*) DESC, setcode;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_155", "db_id": "thrombosis_prediction", "query": "In the thrombosis_prediction database, there is a need to analyze the hierarchy of medical staff within the hospital. Each staff member has an employeeid, a bossid, and a salary. The hierarchy is already established, and each staff member can have direct and indirect managers. The task is to find, for each staff member, the lowest-ranked indirect manager in the hierarchy who earns at least twice as much as the staff member. I has attempted to create a recursive CTE to establish the hierarchy but is struggling to find the correct indirect manager based on the salary condition. The user's query is provided below and is producing incorrect results. In the final result, I need the employeeId, employeeSalary, hierarchical_level, bossId, bossSalary where the boss is the first one whose salary is at least twice as much as the employee.", "issue_sql": ["WITH RECURSIVE EmpMgrCTE AS (SELECT id, bossid, salary, 0 as EmployeeLevel FROM staff WHERE bossid IS NULL UNION ALL SELECT emp.id, emp.bossid, emp.salary, mgr.EmployeeLevel + 1 as EmployeeLevel FROM staff emp INNER JOIN EmpMgrCTE mgr ON emp.bossid = mgr.id) SELECT * FROM EmpMgrCTE emp"], "preprocess_sql": ["CREATE TABLE staff (id bigint PRIMARY KEY, bossid bigint, salary int, hire_date DATE DEFAULT CURRENT_DATE, last_promotion_date DATE, department VARCHAR(100) DEFAULT 'General', job_title VARCHAR(150) DEFAULT 'Staff Member', performance_rating NUMERIC(3,2) DEFAULT 3.50, vacation_days_remaining INTEGER DEFAULT 20, is_active BOOLEAN DEFAULT TRUE, last_review_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, employee_notes TEXT DEFAULT '', contact_details JSONB DEFAULT '{}'::jsonb, security_clearance_level INTEGER DEFAULT 1, employee_uuid UUID DEFAULT gen_random_uuid(), years_of_experience INTEGER DEFAULT 0);", "INSERT INTO staff (id, bossid, salary, hire_date, last_promotion_date, department, job_title, performance_rating, vacation_days_remaining, is_active, last_review_timestamp, employee_notes, contact_details, security_clearance_level, employee_uuid, years_of_experience) VALUES (20, NULL, 10000, '2010-01-15', '2019-06-30', 'Executive', 'Chief Medical Officer', 4.85, 30, TRUE, '2023-01-15 09:00:00+00', 'Excellent leadership skills', '{\"email\":\"cmo@hospital.org\",\"phone\":\"555-1000\"}'::jsonb, 5, 'a1b2c3d4-e5f6-4a5b-8c9d-1e2f3a4b5c6d', 25), (10, 20, 4500, '2012-03-20', '2020-02-15', 'Medical', 'Department Head', 4.50, 25, TRUE, '2023-02-10 10:30:00+00', 'Strong team management', '{\"email\":\"depthead@hospital.org\",\"phone\":\"555-2000\"}'::jsonb, 4, 'b2c3d4e5-f6a7-5b6c-9d0e-2f3a4b5c6d7e', 18), (50, 10, 3000, '2015-07-10', '2021-05-20', 'Cardiology', 'Senior Physician', 4.20, 22, TRUE, '2023-01-20 11:15:00+00', 'Specializes in cardiac care', '{\"email\":\"cardio@hospital.org\",\"phone\":\"555-3000\"}'::jsonb, 3, 'c3d4e5f6-a7b8-6c7d-0e1f-3a4b5c6d7e8f', 12), (70, 10, 1500, '2018-09-05', '2022-01-10', 'Neurology', 'Physician', 3.90, 20, TRUE, '2023-02-05 14:45:00+00', 'New to the department', '{\"email\":\"neuro@hospital.org\",\"phone\":\"555-4000\"}'::jsonb, 2, 'd4e5f6a7-b8c9-7d0e-1f2a-4b5c6d7e8f9a', 8), (40, 50, 1500, '2019-11-12', '2022-08-15', 'Cardiology', 'Resident', 3.75, 18, TRUE, '2023-01-25 09:30:00+00', 'Promising young doctor', '{\"email\":\"resident1@hospital.org\",\"phone\":\"555-5000\"}'::jsonb, 2, 'e5f6a7b8-c9d0-8e1f-2a3b-5c6d7e8f9a0b', 5), (60, 70, 2000, '2017-05-22', '2021-11-30', 'Neurology', 'Specialist', 4.10, 21, TRUE, '2023-02-12 13:20:00+00', 'Excellent diagnostic skills', '{\"email\":\"neurospec@hospital.org\",\"phone\":\"555-6000\"}'::jsonb, 3, 'f6a7b8c9-d0e1-9f2a-3b4c-6d7e8f9a0b1c', 9), (30, 50, 1501, '2020-02-28', NULL, 'Cardiology', 'Junior Physician', 3.60, 15, TRUE, '2023-01-18 16:00:00+00', 'Recently completed residency', '{\"email\":\"junior@hospital.org\",\"phone\":\"555-7000\"}'::jsonb, 2, 'a7b8c9d0-e1f2-0a3b-4c5d-7e8f9a0b1c2d', 3);"], "clean_up_sql": ["DROP TABLE staff;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT rec.circuitid, rec.name FROM circuit_json, jsonb_to_record(circuit_id_name::jsonb) AS rec(circuitid int, name text);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, 'student_club', conn)       \n    sol_sqls_result = execute_queries(sol_sqls, 'student_club', conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_156", "db_id": "card_games", "query": "In the card_games database, there is a table named 'cards' which contains various attributes of Magic: The Gathering cards. Each card has a unique identifier (id), a name, a converted mana cost (convertedmanacost), a rarity, and other attributes. For each rarity, I want to find the card with the highest converted mana cost, highest edhrecrank, and lowest multiverseid. For a single rarity, I can do it like this: sql select rarity, id from cards where rarity = 'uncommon' order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc limit 1;  but I haven't been able to make it for all rarities. So the output should be something like this: I am using PostgreSQL. Any idea how I should do this?", "issue_sql": ["select rarity, id from cards order by convertedmanacost desc nulls last, edhrecrank desc nulls last, multiverseid asc limit 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT y.district_id,\n       array_agg(y.loan_id) FILTER (WHERE y.status IN ('A', 'B')) AS type_A_B,\n       array_agg(y.loan_id) FILTER (WHERE y.status = 'C') AS type_C\nFROM (\n  SELECT x.district_id, l.loan_id, l.status\n  FROM loan l\n  JOIN account x ON l.account_id = x.account_id\n) y\nGROUP BY 1\nORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f'Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_157", "db_id": "financial", "query": "In the financial database, we have a scenario where each account must have at least one associated disposition (disp). However, when attempting to enforce this relationship, the following SQL query fails due to a chicken-egg problem. The user's attempt to create the tables and enforce the relationship is as follows:", "issue_sql": ["DROP TABLE IF EXISTS card, account, disp;CREATE TABLE account (account_id INT PRIMARY KEY NOT NULL, district_id INT NOT NULL, frequency TEXT NOT NULL, date DATE NOT NULL, disp_id INT NOT NULL, FOREIGN KEY (disp_id) REFERENCES disp(disp_id) ON UPDATE CASCADE ON DELETE CASCADE);CREATE TABLE disp (disp_id INT PRIMARY KEY NOT NULL, client_id INT NOT NULL, account_id INT NOT NULL, type TEXT NOT NULL, FOREIGN KEY (account_id) REFERENCES account(account_id) ON UPDATE CASCADE ON DELETE CASCADE);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["WITH labeled_ends AS (SELECT lag(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts - interval '5' minute IS NOT TRUE AS begins_period, sa.ts, lead(sa.ts) OVER (PARTITION BY sa.superhero_id, sa.activity_code ORDER BY sa.ts) = sa.ts + interval '5' minute IS NOT TRUE AS ends_period, sa.superhero_id, sa.activity_code FROM superhero_activities sa), periods AS (SELECT labeled_ends.ts, CASE WHEN labeled_ends.ends_period THEN labeled_ends.ts ELSE lead(labeled_ends.ts) OVER (PARTITION BY labeled_ends.superhero_id, labeled_ends.activity_code ORDER BY labeled_ends.ts) END AS period_end, labeled_ends.superhero_id, labeled_ends.activity_code, labeled_ends.begins_period FROM labeled_ends WHERE labeled_ends.begins_period OR labeled_ends.ends_period) SELECT tstzrange(periods.ts, periods.period_end, '[]') AS valid_interval, periods.superhero_id, periods.activity_code FROM periods WHERE periods.begins_period ORDER BY periods.superhero_id, periods.activity_code, periods.ts;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_158", "db_id": "financial", "query": "In the financial database, I am trying to aggregate client information into a  array, but I am encountering an issue where the array contains a null value as `[null]` instead of an empty array when there are no qualifying rows. I am using PostgreSQL and have tried using `COALESCE` to replace null values, but it doesn't seem to work as expected. Here is the problematic SQL query I used:", "issue_sql": ["SELECT COALESCE(json_agg(CASE WHEN client.client_id IS NULL THEN NULL ELSE json_build_object('client_id', client.client_id, 'gender', client.gender, 'birth_date', client.birth_date) END), '[]') AS AS clients FROM client;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT COUNT(DISTINCT tournament_id) FROM card_matches WHERE player1_id IN (SELECT id FROM card_players WHERE type = 'Pro') OR player2_id IN (SELECT id FROM card_players WHERE type = 'Pro')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_159", "db_id": "debit_card_specializing", "query": "In the debit_card_specializing database, we have a table named transactions_1k that records all transactions made by customers at various gas stations. Each transaction includes details such as the date, time, customer ID, card ID, gas station ID, product ID, amount, and price. We have noticed that there are duplicate transactions in the table, where the same transaction (based on card ID, gas station ID, product ID) appears multiple times with different transaction IDs. Specifically, we want to identify and delete the duplicate transactions where the product ID is 5 (Natural) and keep the ones where the product ID is 2 (Nafta). However, our current query is only selecting the transactions with product ID 5.", "issue_sql": ["select * from transactions_1k e\nwhere exists\n ( select * from transactions_1k e2\n   where e.date=e2.date and e.time=e2.time\n     and e.cardid=e2.cardid\n     and e.gasstationid=e2.gasstationid\n     and e.productid='2' and e2.productid='5') order by e.date asc;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT league_id, season, STRING_AGG(DISTINCT id::TEXT, ',') as match_ids, STRING_AGG(DISTINCT date:: TEXT, ',') AS match_dates FROM match WHERE season IS NOT NULL AND league_id IS NOT NULL AND date IS NOT NULL GROUP BY league_id, season order by league_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_160", "db_id": "financial", "query": "I have a table named \"transfer\" under the database \"financial\". The customer id and their transfer amount columns are given, Cum.sum and Bucket columns we need to find using postgresql. To Find cumulative sum , i can write sum(amount) over (order by id rows between unbounded preceding and current row) . But ask is reset cum.sum if amount reach threshold amount. For example threshold amount is 20 and sum of the row 1,2 and 3 values are 23 which is greater than 20 . so we reset the window function. The next threshold value calculate from id 4 onwards. How to write Postgresql code to implement these functions?", "issue_sql": ["select id, amount as cum_sum, 1 as bucket from transfer where id = 1 union all select transfer.id, (case when cum_sum + amount > 20 then amount else cum_sum + amount end), (case when cum_sum + amount > 20 then bucket + 1 else bucket end) from cte join transfer on transfer.id = cte.id + 1"], "preprocess_sql": ["CREATE TABLE transfer (\n    id INT,\n    amount INT,\n    transaction_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    customer_id UUID DEFAULT gen_random_uuid(),\n    transaction_type VARCHAR(50) DEFAULT 'standard',\n    status VARCHAR(20) DEFAULT 'completed',\n    description TEXT DEFAULT 'Regular transfer',\n    currency_code CHAR(3) DEFAULT 'USD',\n    exchange_rate NUMERIC(12, 6) DEFAULT 1.0,\n    fee_amount NUMERIC(10, 2) DEFAULT 0.00,\n    is_international BOOLEAN DEFAULT FALSE,\n    metadata JSONB DEFAULT '{}'::jsonb,\n    created_by VARCHAR(100) DEFAULT 'system',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    is_flagged BOOLEAN DEFAULT FALSE,\n    risk_score SMALLINT DEFAULT 0,\n    processing_time_ms INTEGER DEFAULT 0,\n    source_account_id BIGINT DEFAULT 0,\n    destination_account_id BIGINT DEFAULT 0\n);", "INSERT INTO transfer (id, amount, transaction_date, customer_id, transaction_type, status, description, currency_code, exchange_rate, fee_amount, is_international, metadata, created_by, created_at, updated_at, is_flagged, risk_score, processing_time_ms, source_account_id, destination_account_id) VALUES (1, 11, '2023-01-01 10:00:00+00', 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', 'deposit', 'completed', 'January deposit', 'USD', 1.0, 0.50, FALSE, '{\"channel\": \"mobile\", \"device_id\": \"ABC123\"}'::jsonb, 'user_101', '2023-01-01 10:00:00+00', '2023-01-01 10:01:30+00', FALSE, 10, 235, 10001, 20001), (2, 6, '2023-01-02 11:15:00+00', 'b2c3d4e5-f6a7-8901-bcde-f12345678901', 'transfer', 'completed', 'Utility payment', 'EUR', 1.12, 0.25, TRUE, '{\"channel\": \"web\", \"reference\": \"UTIL-123\"}'::jsonb, 'user_102', '2023-01-02 11:15:00+00', '2023-01-02 11:16:45+00', FALSE, 5, 189, 10002, 20002), (3, 6, '2023-01-03 09:30:00+00', 'c3d4e5f6-a7b8-9012-cdef-123456789012', 'withdrawal', 'completed', 'ATM withdrawal', 'USD', 1.0, 1.00, FALSE, '{\"location\": \"Main St ATM\", \"atm_id\": \"ATM456\"}'::jsonb, 'user_103', '2023-01-03 09:30:00+00', '2023-01-03 09:32:10+00', FALSE, 15, 312, 10003, 20003), (4, 6, '2023-01-04 14:45:00+00', 'd4e5f6a7-b8c9-0123-defa-4567890123ab', 'transfer', 'completed', 'Friend payment', 'USD', 1.0, 0.00, FALSE, '{\"channel\": \"mobile\", \"memo\": \"Lunch\"}'::jsonb, 'user_104', '2023-01-04 14:45:00+00', '2023-01-04 14:46:20+00', FALSE, 8, 276, 10004, 20004), (5, 13, '2023-01-05 16:20:00+00', 'e5f6a7b8-c9d0-1234-ef01-56789012abcd', 'deposit', 'completed', 'Salary deposit', 'GBP', 1.35, 0.00, TRUE, '{\"channel\": \"direct\", \"employer\": \"ABC Corp\"}'::jsonb, 'user_105', '2023-01-05 16:20:00+00', '2023-01-05 16:22:15+00', FALSE, 3, 198, 10005, 20005), (6, 6, '2023-01-06 08:10:00+00', 'f6a7b8c9-d0e1-2345-f01a-6789012abcde', 'payment', 'completed', 'Subscription payment', 'USD', 1.0, 0.30, FALSE, '{\"service\": \"StreamingPlus\", \"period\": \"monthly\"}'::jsonb, 'user_106', '2023-01-06 08:10:00+00', '2023-01-06 08:11:40+00', FALSE, 7, 245, 10006, 20006), (7, 15, '2023-01-07 13:25:00+00', 'a7b8c9d0-e1f2-3456-01ab-789012abcdef', 'transfer', 'completed', 'Investment transfer', 'USD', 1.0, 1.50, FALSE, '{\"investment_type\": \"stock\", \"ticker\": \"AAPL\"}'::jsonb, 'user_107', '2023-01-07 13:25:00+00', '2023-01-07 13:27:30+00', TRUE, 25, 387, 10007, 20007), (8, 6, '2023-01-08 17:40:00+00', 'b8c9d0e1-f2a3-4567-a1b2-89012abcdef0', 'withdrawal', 'completed', 'Cash withdrawal', 'USD', 1.0, 2.00, FALSE, '{\"location\": \"Downtown Branch\", \"teller_id\": \"T789\"}'::jsonb, 'user_108', '2023-01-08 17:40:00+00', '2023-01-08 17:42:15+00', FALSE, 12, 290, 10008, 20008), (9, 19, '2023-01-09 10:55:00+00', 'c9d0e1f2-a3b4-5678-abcd-9012abcdef01', 'transfer', 'completed', 'Rent payment', 'USD', 1.0, 0.00, FALSE, '{\"recipient\": \"Property Management LLC\", \"property_id\": \"APT123\"}'::jsonb, 'user_109', '2023-01-09 10:55:00+00', '2023-01-09 10:57:20+00', FALSE, 6, 210, 10009, 20009), (10, 10, '2023-01-10 15:30:00+00', 'd0e1f2a3-b4c5-6789-bcde-012abcdef012', 'deposit', 'completed', 'Refund deposit', 'CAD', 0.75, 0.00, TRUE, '{\"merchant\": \"Online Store\", \"order_id\": \"ORD-987654\"}'::jsonb, 'user_110', '2023-01-10 15:30:00+00', '2023-01-10 15:31:45+00', FALSE, 4, 167, 10010, 20010);"], "clean_up_sql": ["drop table if exists transfer;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT row_id, MAX(CASE WHEN col_name = '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' THEN value ELSE NULL END) AS card1, MAX(CASE WHEN col_name = '56f4935b-f6c5-59b9-88bf-9bcce20247ce' THEN value ELSE NULL END) AS card2, MAX(CASE WHEN col_name = '6d268c95-c176-5766-9a46-c14f739aba1c' THEN value ELSE NULL END) AS card3 FROM (SELECT uuid as col_name, text as value, ROW_NUMBER() OVER (PARTITION BY uuid ORDER BY id) as row_id FROM ruling) r group by row_id order by row_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_161", "db_id": "formula_1", "query": "In the Formula 1 database, we have a table named 'results' that contains various performance metrics for each driver in each race. We are interested in analyzing the modal value of certain performance metrics (laps) for each race. The modal value is the most frequent value in a data set, and if there are multiple equally frequent values, we want to return the one that occurs first in the data set. For example, if in a race, the laps completed by drivers are [10, 10, 20, 20, 30], the modal value should be 10 because it occurs first among the most frequent values. We need to calculate the modal value for each race based on the laps columns and return the result along with the raceid.", "issue_sql": ["SELECT raceid mode() within group(order by laps) as modal_laps FROM results;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT c.*\nFROM cards_info c\nWHERE NOT EXISTS (\n    SELECT *\n    FROM card_choice cc\n    WHERE cc.non_valid_cards::jsonb @> to_jsonb(c.id)\n    AND cc.card_id = c.id\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT * FROM card_choice cc WHERE cc.card_id = {pred_query_result[i][0]} AND cc.non_valid_cards::jsonb @> to_jsonb({pred_query_result[i][0]});\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0]\n        assert test_pred_query_result_1 == [], f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 1, f'Expected 1 row, but found {len(pred_query_result)} rows'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_162", "db_id": "card_games", "query": "In the card_games database, I want to run two tests: 1. Identify tables in the 'public' schema that are not listed in the 'required_tables' table. 2. Identify tables listed in the 'required_tables' table that are not present in the 'cards_schema' schema. For the first test, I use the following query which works correctly:\\nsql \\\\/* First Query *\\\\/\\nselect t1.table_name as t1_table_name, t2.table_name as t2_extra_tables_in_schema \\\\/nfrom required_tables t1 \\\\/nright join information_schema.tables t2 \\\\/non t1.table_name = t2.table_name \\\\/nwhere t2.table_schema='public' \\\\/nand t1.table_name IS NULL \\\\/n\\nHowever, for the second test, when I try the following query (the equivalent to the first query but with a left join this time):\\nsql \\\\/* Second Query *\\\\/\\nselect t1.table_name as t1_tables_missing_from_schema, t2.table_name from required_tables t1 left join information_schema.tables t2 on t1.table_name = t2.table_name where t2.table_schema='public' and t2.table_name IS NULL; \\\\/n\\nI always get zero results, even though I know that there are some tables in required_tables which is not in the 'public' schema. How do I get around this issue? Can you provide me with a way to get both missing results in a single query (maybe somehow with a full outer join is my guess), the results should include two colums: 'kind' (WHEN required_tables.table_name IS NULL THEN 'extra' ELSE 'missing') and the corresponding 'table_name'?", "issue_sql": ["select t1.table_name as t1_table_name, t2.table_name as t2_extra_tables_in_schema from required_tables t1 right join information_schema.tables t2 on t1.table_name = t2.table_name where t2.table_schema='public' and t1.table_name IS NULL;", "select t1.table_name as t1_tables_missing_from_schema, t2.table_name from required_tables t1 left join information_schema.tables t2 on t1.table_name = t2.table_name where t2.table_schema='public' and t2.table_name IS NULL;"], "preprocess_sql": ["CREATE SCHEMA IF NOT EXISTS cards_schema;", "CREATE TABLE IF NOT EXISTS required_tables (table_name name PRIMARY KEY, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, priority INTEGER DEFAULT 5, description TEXT DEFAULT 'Standard required table', version VARCHAR(50) DEFAULT '1.0.0', last_verified_date DATE DEFAULT CURRENT_DATE, verification_status VARCHAR(20) DEFAULT 'verified', metadata JSONB DEFAULT '{}'::jsonb, owner VARCHAR(100) DEFAULT 'system', access_level VARCHAR(20) DEFAULT 'public', notes TEXT DEFAULT NULL, external_reference_id UUID DEFAULT gen_random_uuid(), dependency_count INTEGER DEFAULT 0, last_accessed_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP);", "INSERT INTO required_tables (table_name, is_active, priority, description, version, verification_status, metadata, owner, access_level, notes, dependency_count) VALUES ('cards', TRUE, 1, 'Main cards table containing card information', '1.2.0', 'verified', '{\"importance\": \"critical\", \"category\": \"core\"}'::jsonb, 'system', 'public', 'Primary table for card data', 5), ('foreign_data', TRUE, 2, 'Foreign language data for cards', '1.1.0', 'verified', '{\"importance\": \"high\", \"category\": \"localization\"}'::jsonb, 'system', 'public', 'Contains translations and foreign data', 3), ('rulings', TRUE, 2, 'Card rulings and official clarifications', '1.0.5', 'verified', '{\"importance\": \"high\", \"category\": \"rules\"}'::jsonb, 'system', 'public', 'Official rulings for cards', 2), ('sets', TRUE, 1, 'Card sets information', '1.3.0', 'verified', '{\"importance\": \"critical\", \"category\": \"core\"}'::jsonb, 'system', 'public', 'Information about card sets', 4), ('price', TRUE, 3, 'Pricing information for cards', '0.9.0', 'pending', '{\"importance\": \"medium\", \"category\": \"financial\"}'::jsonb, 'system', 'restricted', 'Historical and current pricing data', 1), ('source', TRUE, 4, 'Source information for card data', '1.0.0', 'verified', '{\"importance\": \"medium\", \"category\": \"metadata\"}'::jsonb, 'system', 'public', 'Data sources and attribution', 0);"], "clean_up_sql": ["DROP TABLE IF EXISTS required_tables CASCADE;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE RCTE_NODES AS (\n  SELECT\n    uuid\n  , card_name AS name\n  , uuid as root_uuid\n  , card_name as root_name\n  , 1 as lvl\n  , ARRAY[]::uuid[] as children\n  , true as has_next\n  FROM card_type\n  WHERE parent_uuid IS null\n\n  UNION ALL\n\n  SELECT\n    cat.uuid\n  , cat.card_name AS name\n  , cte.root_uuid\n  , cte.root_name\n  , cte.lvl+1\n  , cte.children || cat.uuid\n  , (exists(select 1 from card_type cat2 where cat2.parent_uuid = cat.uuid))\n  FROM RCTE_NODES cte\n  JOIN card_type cat\n    ON cat.parent_uuid = cte.uuid\n)\nSELECT root_uuid as uuid, root_name as name\n, array_agg(children) as children\nFROM RCTE_NODES\nWHERE has_next = false\nGROUP BY root_uuid, root_name\nORDER BY root_uuid;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    for i in range(len(pred_query_result)):\n        sql_query = f\"SELECT parent_uuid FROM card_type WHERE card_name = '{pred_query_result[0][1]}';\"\n        test_pred_query_result_1 = perform_query_on_postgresql_databases(sql_query, db_name)[0][0]\n        assert test_pred_query_result_1[0] is None, f'Expected to find nothing, but found {test_pred_query_result_1}'\n     ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_163", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, we are managing a graph-like structure to represent football matches and their dependencies. Each match is a node, and the dependencies between matches (such as follow-up matches or related matches) are represented as edges. The match table has id as the primary key and a unique constraint on (id, stage). The dependency table references both id and stage from the match table for match1 and match2.The business requirement is that whenever a match's stage changes, its dependencies need to be re-evaluated and possibly updated. To handle this, we have a 'match' table and a 'dependency' table. The 'match' table includes a stage number to track changes, and the 'dependency' table references the 'match' table using the match ID and stage number. However, when we try to update the version of a match, we encounter an error due to foreign key constraints ('dependency_match1_stage1_fkey' and 'dependency_match2_stage2_fkey'). We need to find a way to update the stage number (the stage number of match1 incresed by 1) and automatically handle the dependencies without starting a transaction manually.", "issue_sql": ["update match set stage = stage + 1 where id = 'match1';"], "preprocess_sql": ["drop table if exists dependency;", "drop table if exists match;", "create table match (id varchar(32), stage int not null default 1, status varchar(32), primary key (id), unique (id, stage));", "create table dependency (match1 varchar(32) not null, stage1 int not null, match2 varchar(32) not null, stage2 int not null, constraint normalize check (match1 < match2), foreign key (match1, stage1) references match (id, stage) on delete cascade, foreign key (match2, stage2) references match (id, stage) on delete cascade, primary key (match1, match2));", "insert into match (id, stage, status) values ('match1', 1, 'Scheduled'), ('match2', 2, 'Scheduled');", "insert into dependency (match1, stage1, match2, stage2) values ('match1', 1, 'match2', 2);"], "clean_up_sql": ["drop table if exists dependency;", "drop table if exists match;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT d.the_day AS \"Date\", COUNT(DISTINCT e.event_id) AS \"Number of Events\", AVG(b.avg_remaining) AS \"Avg Remaining Budget\" FROM (SELECT ts::date AS the_day FROM generate_series('2020-01-01'::timestamp, '2020-03-31'::timestamp, '1 day'::interval) AS ts) d LEFT JOIN \"event\" e ON e.event_date::date = d.the_day AND e.status IN ('Open', 'Closed') LEFT JOIN (SELECT link_to_event, SUM(remaining) as avg_remaining FROM budget GROUP BY link_to_event) b ON b.link_to_event = e.event_id GROUP BY d.the_day ORDER BY d.the_day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) == 91, f'Expected 91 rows, but found {len(pred_query_result_1)} rows'\n    assert str(pred_query_result_1[0][0]) == '2020-01-01', f'Expected the first date to be 2020-01-01, but found {pred_query_result_1[0][0]}'\n    assert str(pred_query_result_1[-1][0]) == '2020-03-31', f'Expected the last date to be 2020-03-31, but found {pred_query_result_1[-1][0]}'\n    assert pred_query_result_1[13][1] == 2, f'Expected the number of events on 2020-01-14 day to be 2, but found {pred_query_result_1[13][1]}'\n    assert pred_query_result_1[27][2] > 0, f'Expected the average remaining budget on 2020-01-28 day to be greater than 0, but found {pred_query_result_1[27][2]}'\n    assert pred_query_result_1[41][1] == 1, f'Expected the number of events on 2020-02-11 day to be 1, but found {pred_query_result_1[41][1]}'\n    assert pred_query_result_1[33][2] is None or pred_query_result_1[33][2] >= 0, f'Expected the average remaining budget on 2020-02-02 day to be 0 or NULL, but found {pred_query_result_1[33][2]}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_164", "db_id": "superhero", "query": "Suppose we have a superhero event schedule where each superhero is scheduled to perform at different events. We have a table `superhero_events` that records the start and end times of these events. We want to retrieve a list of events that: Started within the last 3 days (inclusive) and end before 5 hours into the future (exclusive). The results should be ordered so that events that started in the past appear first, followed by events that start in the future. We can do something like the following query, but it is slow and needs optimization. Is there a way to use indexes to make this faster?", "issue_sql": ["DROP INDEX IF EXISTS idx_a;", "SELECT * from superhero_events WHERE start_time >= Now()::timestamp - INTERVAL '3 days' AND end_time < now()+'5 hours'::interval ORDER BY CASE WHEN now()+'5 hours'::interval > Now()::timestamp AND start_time < Now()::timestamp THEN 1 WHEN start_time < Now()::timestamp THEN 2 ELSE 3 END;"], "preprocess_sql": ["CREATE TABLE superhero_events (hero_id bigint NOT NULL, start_time timestamp without time zone NOT NULL, end_time timestamp without time zone NOT NULL);", "ALTER TABLE superhero_events ADD COLUMN event_id SERIAL PRIMARY KEY;", "ALTER TABLE superhero_events ADD CONSTRAINT chk_time_order CHECK (start_time < end_time);", "INSERT INTO superhero_events (hero_id, start_time, end_time) SELECT s.id, NOW() - INTERVAL '1 hour' * (random()+0.5), NOW() + INTERVAL '1 hour' * (random()+0.5) FROM superhero s ORDER BY random() LIMIT 250;", "INSERT INTO superhero_events (hero_id, start_time, end_time) SELECT s.id, NOW() + INTERVAL '5 hour' * (random()+0.5), NOW() + INTERVAL '5 hour' * (random()+0.5) + INTERVAL '2 hour' * (random()+0.5) FROM superhero s ORDER BY random() LIMIT 500;", "INSERT INTO superhero_events (hero_id, start_time, end_time) SELECT s.id, NOW() - INTERVAL '3 day' * (random()+0.5), (NOW() - INTERVAL '3 day' * (random()+0.5)) + INTERVAL '3 hour' * (random()+0.5) FROM superhero s ORDER BY random() LIMIT 1500;", "INSERT INTO superhero_events (hero_id, start_time, end_time) SELECT s.id, NOW() - INTERVAL '15 day' * (random()+0.5) - INTERVAL '3 day', (NOW() - INTERVAL '15 day' * (random()+0.5) - INTERVAL '3 day') + INTERVAL '4 hour' * (random()+0.5) FROM superhero s ORDER BY random() LIMIT 2750;"], "clean_up_sql": ["DROP TABLE IF EXISTS superhero_events;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1997 THEN trans.amount ELSE 0 END) AS a1997, SUM(CASE WHEN EXTRACT(YEAR FROM trans.date) = 1998 THEN trans.amount ELSE 0 END) AS a1998 FROM trans WHERE trans.date >= '1997-01-01' AND trans.date < '1999-01-01' GROUP BY month ORDER BY 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    print(pred_query_result_1)\n    assert len(pred_query_result_1) == 12, f'Expected 12 rows (one for each month), but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == '01', 'The first month should be January (01).'\n    assert pred_query_result_1[-1][0] == '12', 'The last month should be December (12).'\n    assert pred_query_result_1[0][2] is not None, 'The sum of transactions for January 1998 should not be None.'\n    test_pred_query_result_1 = execute_queries([\"SELECT LPAD(EXTRACT(MONTH FROM trans.date)::text, 2, '0') AS month, SUM(trans.amount) AS total FROM trans WHERE EXTRACT(YEAR FROM trans.date) = 1997 GROUP BY month ORDER BY month;\"], db_name, conn)[0]\n    assert pred_query_result_1[0][1] == test_pred_query_result_1[0][1], f'Expected the sum of transactions for January 1997 to be {test_pred_query_result_1[0][1]}, but found {pred_query_result_1[0][1]}.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_165", "db_id": "california_schools", "query": "In the context of analyzing superhero attributes, I have a table ordered by the `hero_id` column. I aim to perform an aggregation on `n` rows at a time but also wish to incorporate the previous `k` and the next `k'` rows as context. For instance, considering the `hero_attribute` table with data ordered by `hero_id`, I want to aggregate `n` rows with overlapping context from adjacent rows. An example query to get the sum of `attribute_value` for `n=2` would group the rows into `[1, 2]`, `[3, 4]`, `[5, 6]` based on `(hero_id-1) / 2`. However, achieving overlapping groups, say with `k = k' = 2`, to get groups like `[1, 2, 3, 4]`, `[1, 2, 3, 4, 5, 6]`, `[3, 4, 5, 6]` based on `attribute_value`, proves challenging. Is there a way to accomplish this in PostgreSQL using `group by` or window functions? The output should contain only one column 'sum', which stores the three aggregation values of group `[1, 2, 3, 4]`, `[1, 2, 3, 4, 5, 6]` and `[3, 4, 5, 6]`.", "issue_sql": ["with hero_attribute(hero_id, attribute_id, attribute_value) as ( values (1, 1, 80), (2, 1, 75), (3, 1, 95), (4, 1, 85), (5, 1, 90), (6, 1, 70) ) select sum(attribute_value) from hero_attribute group by (hero_id-1) / 2;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls,db_name,conn)[0];\n    assert len(pred_query_result_1) > 0, 'Expected at least one circuit within the given distance, but found none.'\n    assert pred_query_result_1[0][2] == 'Hungaroring', 'Expected the first circuit to be Hungaroring, but found a different one.'\n    assert pred_query_result_1[2][2] == 'Zeltweg', 'Expected the first circuit to be Zeltweg, but found a different one.'\n    test_pred_query_result_1 = execute_queries([\"SELECT DISTINCT * FROM circuits c WHERE EXISTS (SELECT 1 FROM (SELECT ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography AS point UNION ALL SELECT ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography) points WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(c.lng, c.lat), 4326)::geography, points.point, 1000000));\"], db_name, conn)[0]\n    assert pred_query_result_1[0][0] == test_pred_query_result_1[0][0], f'Expected circuit count to match, but found {pred_query_result_1[0][0]} instead of {test_pred_query_result_1[0][0]}.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_166", "db_id": "european_football_2", "query": "In the database 'european_football_2', there is a table named 'players' that stores information about football players, including their skills in different areas of the game. Each player has a unique ID, a name, and a array of skills where each skill has a unique skill ID and a description. The task is to retrieve a list of players along with their skills in a specific format, where each player only has a single row, and their skills are represented as an array of skill descriptions. For example, (1, Alice, ['Passing', 'Shooting']). If a player has no skills, their skill array should be empty. The user attempted to write a query to achieve this but encountered issues with duplicate rows and missing entries for players with no skills.", "issue_sql": ["select id, name, d ->> 'description' as skill from player_skills, json_array_elements(skills) as d;"], "preprocess_sql": ["CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";", "CREATE TABLE player_skills (id INT PRIMARY KEY, name TEXT, skills JSON, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, skill_count INTEGER DEFAULT 0, last_evaluation_date DATE DEFAULT CURRENT_DATE, performance_rating NUMERIC(3,1) DEFAULT 0.0, nationality VARCHAR(100) DEFAULT 'Unknown', contract_status VARCHAR(50) DEFAULT 'Active', metadata JSONB DEFAULT '{}'::jsonb, player_uuid UUID DEFAULT uuid_generate_v4(), notes TEXT DEFAULT '', version_number INTEGER DEFAULT 1);", "INSERT INTO player_skills (id, name, skills, created_at, updated_at, is_active, skill_count, last_evaluation_date, performance_rating, nationality, contract_status, metadata, player_uuid, notes, version_number) VALUES (1, 'Alice', '[{\"id\": 11, \"description\": \"Passing\"}, {\"id\": 13, \"description\": \"Shooting\"}]'::json, '2023-01-15 08:30:00+00', '2023-03-20 14:45:00+00', TRUE, 2, '2023-03-15', 8.5, 'England', 'Active', '{\"preferred_position\": \"Midfielder\", \"years_experience\": 5}'::jsonb, 'a1b2c3d4-e5f6-4a1b-8c2d-3e4f5a6b7c8d', 'Excellent ball control and vision', 3), (2, 'Bob', '[{\"id\": 10, \"description\": \"Defending\"}, {\"id\": 9, \"description\": \"Tackling\"}]'::json, '2023-02-10 10:15:00+00', '2023-04-05 09:20:00+00', TRUE, 2, '2023-04-01', 7.8, 'Spain', 'Active', '{\"preferred_position\": \"Defender\", \"years_experience\": 7}'::jsonb, 'b2c3d4e5-f6a7-5b2c-9d3e-4f5a6b7c8d9e', 'Strong defensive capabilities', 2), (3, 'Sam', '[]'::json, '2023-03-05 15:45:00+00', '2023-03-05 15:45:00+00', FALSE, 0, '2023-03-01', 6.2, 'France', 'Inactive', '{\"preferred_position\": \"Forward\", \"years_experience\": 2}'::jsonb, 'c3d4e5f6-a7b8-6c3d-0e4f-5a6b7c8d9e0f', 'New player with potential', 1);"], "clean_up_sql": ["DROP TABLE player_skills;"], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION words_get_uid(in_social integer, in_sid text) RETURNS integer AS $func$ SELECT uid FROM words_social WHERE social = in_social AND sid = in_sid; $func$ LANGUAGE sql IMMUTABLE;", "CREATE OR REPLACE FUNCTION words_get_chat(in_gid integer, in_uid integer) RETURNS TABLE (out_mine integer, out_msg text) AS $func$ SELECT CASE WHEN c.uid = in_uid THEN 1 ELSE 0 END, c.msg FROM words_chat c JOIN words_games g USING (gid) JOIN words_users opponent ON (opponent.uid IN (g.player1, g.player2) AND opponent.uid <> in_uid) WHERE c.gid = in_gid AND (c.uid = in_uid OR NOT opponent.muted) ORDER BY c.created ASC; $func$ LANGUAGE sql;", "SELECT words_get_chat(10, words_get_uid(100, 'abc')) AS nice_user;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_167", "db_id": "european_football_2", "query": "The database contains a table named 'match_events' with a column 'events' that stores JSON arrays of event objects for each football match. Each event object includes an 'id' and 'description'. The task is to extract all event objects with 'id' equal to 2 from each match record. The user attempted to achieve this using a CASE statement but encountered issues when the number of events in a match exceeded the hardcoded indices in the query. Can you write a sql query without using 'WHERE' or 'HAVING' clause - only inside 'SELECT' without relying on indices?", "issue_sql": ["SELECT CASE when (t.events::json->0->'id')::varchar::int = 2 then (t.events::json->0)::varchar when (t.events::json->1->'id')::varchar::int = 2 then (t.events::json->1)::varchar when (t.events::json->2->'id')::varchar::int = 2 then (t.events::json->2)::varchar else null::varchar end as \"result\" FROM match_events as t;"], "preprocess_sql": ["CREATE TABLE match_events (match_id SERIAL PRIMARY KEY, events JSON, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, event_count INTEGER DEFAULT 0, match_date DATE DEFAULT CURRENT_DATE, is_processed BOOLEAN DEFAULT FALSE, processing_status VARCHAR(50) DEFAULT 'pending', metadata JSONB DEFAULT '{}'::jsonb, event_hash VARCHAR(64) DEFAULT NULL, source_system VARCHAR(100) DEFAULT 'manual_entry', version INTEGER DEFAULT 1, importance_level INTEGER DEFAULT 5, notes TEXT DEFAULT NULL, last_modified_by VARCHAR(100) DEFAULT 'system')", "INSERT INTO match_events (events, event_count, is_processed, processing_status, metadata, event_hash, source_system, version, importance_level, notes, last_modified_by) VALUES ('[{\"id\": 1, \"description\": \"Goal\"}, {\"id\": 2, \"description\": \"Yellow Card\"}, {\"id\": 3, \"description\": \"Substitution\"}]'::json, 3, TRUE, 'completed', '{\"referee\": \"John Smith\", \"stadium\": \"Main Arena\"}'::jsonb, 'a1b2c3d4e5f6', 'match_system', 1, 3, 'Regular season match with standard events', 'data_import_job'), ('[{\"id\": 1, \"description\": \"Goal\"}, {\"id\": 4, \"description\": \"Substitution\"}, {\"id\": 3, \"description\": \"Red Card\"}, {\"id\": 2, \"description\": \"Goal\"}]'::json, 4, TRUE, 'completed', '{\"referee\": \"Jane Doe\", \"stadium\": \"East Stadium\", \"weather\": \"rainy\"}'::jsonb, 'f6e5d4c3b2a1', 'match_system', 1, 4, 'High-profile match with controversial red card', 'data_import_job')"], "clean_up_sql": ["DROP TABLE match_events;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH cte AS (SELECT driverid, points, (points * 100) as earnings FROM driverstandings) SELECT driverid, points, earnings, CASE WHEN earnings > 5000 THEN earnings * 0.2 WHEN earnings > 3000 THEN earnings * 0.15 ELSE null END AS bonus FROM cte"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    count_price_times = sum(sql.lower().count('points * 100') for sql in pred_sqls)\n    assert count_price_times <= 3, f'Expected at most 3 occurrences of \"price * 100\" in the query, but got {count_price_times}.'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_168", "db_id": "thrombosis_prediction", "query": "In the context of a medical database, we have a table `examination` that records various tests and diagnoses for patients over time. Each record includes a patient ID, the date of examination, and several test results including `aCL IgG`, `aCL IgM`, `ANA`, and `aCL IgA`. We are interested in finding out how many times each test result occurs in each year between 1993 and 1996. Specifically, we want to count the occurrences of each `ANA Pattern` in each year, and then find the pattern with the highest count. Here is a query that attempts to do this but fails to return only the rows with the highest count of `ANA Pattern` per year. How to get only rows with the highest count of `ANA Pattern` per year between 1993 and 1996?", "issue_sql": ["SELECT COUNT(\"ANA Pattern\") AS c, \"ANA Pattern\", EXTRACT(YEAR FROM \"Examination Date\") AS examination_year FROM examination WHERE EXTRACT(YEAR FROM \"Examination Date\") BETWEEN 1993 AND 1996 GROUP BY EXTRACT(YEAR FROM \"Examination Date\"), \"ANA Pattern\" ORDER BY examination_year, c DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["with dataset as (\n  SELECT\n      date,\n      COUNT(*) as rows_added\n  FROM\n      team_attributes\n  WHERE\n      date between '2010-01-01 00:00:00'\n      AND '2015-12-31 00:00:00'\n  GROUP BY\n      date\n )\nSELECT\n    COUNT(*) as total_days_in_result_set,\n    COUNT(DISTINCT rows_added) as total_days_w_distinct_record_counts,\n    COUNT(*) - COUNT(DISTINCT rows_added) as total_days_w_duplicate_record_counts,\n    COUNT(*) - COUNT(DISTINCT date) as duplicate_dates\nFROM dataset"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_169", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, a user is trying to generate a report that combines two parts: a list of players along with their birth year, ordered by the player's name, and a summary of the total number of players in each birth year, ordered by the count of players and the year. The user has two separate queries that work individually but when combined using UNION ALL, the order of the first part changes unexpectedly. The user wants to maintain the order of the first part when combined with the second part.", "issue_sql": ["WITH player_names AS (SELECT 1 AS source, ROW_NUMBER() OVER (ORDER BY player_name) AS row_number, CONCAT(player_name, '(', LEFT(birthday, 4), ')') AS dest FROM player_table), birth_year_summary AS (SELECT 2 AS source, ROW_NUMBER() OVER (ORDER BY COUNT(*), LEFT(birthday, 4)) AS row_number, CONCAT('There are a total of ', COUNT(*), ' player', CASE WHEN COUNT(*) > 1 THEN 's' ELSE '' END, ' born in ', LEFT(birthday, 4), '.') AS dest FROM player_table GROUP BY LEFT(birthday, 4)) SELECT dest FROM (SELECT * FROM player_names UNION ALL SELECT * FROM birth_year_summary) AS combined_results ORDER BY ROW_NUM;"], "preprocess_sql": ["CREATE TABLE player_table AS SELECT * FROM player ORDER BY RANDOM();"], "clean_up_sql": ["DROP TABLE player_table;"], "category": "Personalization", "efficiency": false, "sol_sql": ["insert into card_counters (card_name, counters) values ('Lightning Bolt', array[2,0,2,1]) on conflict (card_name) do update set counters = (select array_agg(e1 + e2) from unnest(card_counters.counters, excluded.counters) as u(e1, e2))"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries([\"SELECT * FROM card_counters;\"], db_name, conn)[0]\n    sol_sqls_result = [('Lightning Bolt', [3, 3, 3, 1])]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_170", "db_id": "formula_1", "query": "In the Formula 1 database, I want to generate a report that lists each race along with the stops and ids of all constructors who participated in that race. However, when I use a query with two LEFT JOINs, I encounter duplicates in the constructor and stops. I need a solution to ensure that the constructor and stop are listed without duplicates while maintaining the correct aggregation of data. Particularly, I can't just add distinct to remove duplicates because duplicate name is allowed.", "issue_sql": ["SELECT rs.raceId AS race_id, string_agg(constructorId::TEXT, ',' ORDER BY res.resultId) AS constructor_ids, string_agg(p.stop::TEXT, ', ' ORDER BY p.raceId) AS stops FROM races rs LEFT JOIN results res ON res.raceId = rs.raceId LEFT JOIN pitstops p ON rs.raceId = p.raceId GROUP BY rs.raceId"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION f_special_running_sum() RETURNS TABLE(id int, result numeric(10,6)) LANGUAGE plpgsql AS $func$ DECLARE t record; BEGIN DROP TABLE IF EXISTS pg_temp.result; CREATE TEMP TABLE result (id int, trx int, result float8) ON COMMIT DROP; FOR t IN TABLE sales_transactions ORDER BY id LOOP INSERT INTO result(id, trx, result) SELECT t.id, t.trx, (COALESCE(sum(r.trx + r.result), 0) + t.trx) * t.event FROM result r; END LOOP; RETURN QUERY SELECT r.id, r.result::numeric(10,6) FROM result r; END $func$;", "SELECT * FROM f_special_running_sum();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_171", "db_id": "formula_1", "query": "In the context of the 'formula_1' database, we have a scenario involving race routes and their events. The 'routes' table represents the race routes, and we have two additional tables, 'route_detail' and 'route_event', which track various events and their details for each route. The 'route_events' table contains records of events for each route, and the 'route_detail' table contains detailed information about each route. We need to find all routes with a specific status (e.g., status 5, which is stored in route_detail) but do not have an event of a certain type (e.g., type 3, which is stored in route_event). However, the provided SQL query does not correctly filter out the routes with the unwanted event type, leading to incorrect results.", "issue_sql": ["SELECT r.id, r.start_day, r.end_day, de.point_of_delivery_plant_name, de.point_of_delivery_plant_number, de.visit_status FROM route r JOIN route_detail de ON de.route_id = r.id WHERE NOT EXISTS (SELECT 1 FROM route ro JOIN route_detail rd ON rd.route_id = ro.id JOIN route_event ev ON ev.route_detail_id = rd.id WHERE rd.route_id = r.id AND ev.event_type !=3 AND rd.visit_status = '5' AND rd.id = de.id) AND de.visit_status = '5' GROUP BY 1,2,3,4,5,6 ORDER BY r.id;"], "preprocess_sql": ["CREATE TABLE route(id INT, start_day DATE, end_day DATE);", "INSERT INTO route VALUES (1, '2023/05/01', '2023/05/07'), (2, '2023/05/01', '2023/05/07'), (3, '2023/05/01', '2023/05/07'), (4, '2023/05/01', '2023/05/07'), (5, '2023/05/01', '2023/05/07');", "CREATE TABLE route_detail(id INT, route_id INT, visit_status INT, point_of_delivery_plant_name VARCHAR(30), point_of_delivery_plant_number INT);", "INSERT INTO route_detail VALUES (1, 1, 5, 'CROP SOLUTIONS S.A.', 563), (2, 1, 5, 'CROP SOLUTIONS S.A.', 563), (3, 1, 5, 'CROP SOLUTIONS S.A.', 563), (4, 2, 0, 'SAMA S.A.', 781), (5, 3, 0, 'WALTER SAMA HARMS', 732), (6, 4, 5, 'AGROSER S.A.', 242), (7, 4, 5, 'AGROSER S.A.', 242), (8, 5, 5, 'AGROFERTIL S.A.', 287), (9, 5, 5, 'AGROFERTIL S.A.', 287), (10, 5, 5, 'AGROFERTIL S.A.', 287);", "CREATE TABLE route_event (id INT, route_detail_id INT, event_type INT, event_description VARCHAR(30));", "INSERT INTO route_event VALUES (50, 1, 1, 'start visit'), (51, 2, 2, 'recurrent form'), (52, 3, 3, 'end visit'), (53, 4, 1, 'start visit'), (54, 5, 1, 'start visit'), (55, 6, 1, 'start visit'), (56, 7, 2, 'recurrent form'), (57, 8, 1, 'start visit'), (58, 9, 2, 'recurrent form'), (59, 10, 4, 'harvest advance')"], "clean_up_sql": ["DROP TABLE route_event;", "DROP TABLE route;", "DROP TABLE route_detail;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH cte_funding_count AS (SELECT fundingtype, COUNT(*) AS count FROM schools GROUP BY fundingtype), p as( SELECT fundingtype,  count,  ROUND(count*100./(SELECT SUM(count) FROM cte_funding_count),0) AS percent FROM cte_funding_count ) select fundingtype, count, case(row_number() over(order by percent desc)) when 1  then 100 - sum(percent) over(order by percent desc rows between 1 following and unbounded following)  else percent end pp from p"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    total = sum([item[2] for item in pred_sqls_result])\n    assert total == 100, f'Expected the total percentage is 100, but found {total}'"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_172", "db_id": "european_football_2", "query": "We are managing a database for a football analytics platform where we track the attributes of teams over time. Each record in the 'team_attributes' table represents the attributes of a team on a specific date. We need to ensure that the 'date' field of each record is correctly associated with an 'eff_to' field, which indicates the date just before the next record for the same team. If there is no subsequent record for the team, 'eff_to' should be set to '5999-12-31'. We are trying to automate this process using a trigger function that updates the 'eff_to' field whenever a new record is inserted into the 'team_attributes' table. However, our current trigger function is incorrectly updating all 'eff_to' fields with the last 'date' value instead of calculating them individually for each team. We need to correct this issue to ensure accurate data representation.", "issue_sql": ["CREATE OR REPLACE FUNCTION update_team_attributes_eff_to() RETURNS TRIGGER AS $$ BEGIN UPDATE team_attributes SET eff_to = subquery.next_date FROM ( SELECT COALESCE( LEAD(TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE, 1) OVER ( ORDER BY TO_TIMESTAMP(date, 'YYYY-MM-DD HH24:MI:SS')::DATE DESC), TO_DATE('6000-00-00', 'YYYY-MM-DD') ) - 1 AS next_date FROM team_attributes ) AS subquery; RETURN NULL; END; $$ LANGUAGE plpgsql;CREATE OR REPLACE TRIGGER after_insert_team_attributes AFTER INSERT ON team_attributes FOR EACH ROW EXECUTE PROCEDURE update_team_attributes_eff_to();"], "preprocess_sql": ["ALTER TABLE team_attributes ADD COLUMN eff_to DATE;"], "clean_up_sql": ["ALTER TABLE team_attributes DROP COLUMN eff_to;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH RankedLabs AS (SELECT lab.date AS firstActivity, pat.ID as id, ROW_NUMBER() OVER (PARTITION BY pat.id ORDER BY lab.date ASC) AS rn FROM patient pat JOIN laboratory lab ON lab.id = pat.id AND lab.date <= pat.description AND lab.date > pat.\"First Date\" WHERE pat.sex = 'F') SELECT firstActivity, id FROM RankedLabs WHERE rn = 1 ORDER BY id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_173", "db_id": "formula_1", "query": "In the Formula 1 database, I need to analyze the results of a specific race to identify the drivers who finished in the same position across multiple races, excluding the driver with the highest driver ID in each group. For example, if drivers 5 and 9 both finished in 3rd place in different races, and drivers 8, 12, and 13 all finished in 2nd place in different races, I want to exclude the driver with the highest ID in each group and get the remaining driver IDs. The final result should be a list of driver IDs excluding the highest ID in each group of drivers who finished in the same position across multiple races.", "issue_sql": ["select position, array_agg(driverid) as driverids from results group by position having COUNT(*)>1 order by position"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE or replace FUNCTION f_arr_except_arr(a1 text[], a2 text[])  RETURNS text[] LANGUAGE SQL IMMUTABLE PARALLEL SAFE BEGIN ATOMIC SELECT ARRAY (SELECT unnest(a1) EXCEPT ALL SELECT unnest(a2)); END;", "SELECT id, f_arr_except_arr(string_to_array(c.keywords, ',')::text[], s.RemoveKeywords) AS updated_keywords FROM  cards c JOIN (SELECT id, RemoveKeywords FROM SelectQuery) s USING (id) order by id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_174", "db_id": "superhero", "query": "In the superhero2 database, we have a representation of a (binary) tree where each superhero2 is a node, and each node has a parent column and a color column. The color column represents the color of the superhero2's costume. The leaf nodes (superheroes without children) have a color (their color column is not null and can be either green or red). The goal is to color the whole tree based on the following rules: If a parent has one child, then the parent's color is the child's color. If a parent has two children and both have the same color, then the parent color is its children's color. If a parent has two children and they have different colors, then the parent color is gray. The id and parent id are text and (their length - 1) is the their depth, for example, 'A' is the root node and 'AB' is the child and 'ABC' is the child of 'AB'. The id represents the path from the root to the node. If the leaf node is 'ABDE', then the path is 'A', 'AB', 'ABD', 'ABDE'.   How can I write a recursive query in PostgreSQL for this algorithm?", "issue_sql": ["WITH RECURSIVE cte AS ( SELECT id, parent_id, color FROM superhero2 WHERE parent_id IS NULL UNION ALL SELECT s.id, s.parent_id, CASE WHEN c1.color IS NULL THEN c2.color WHEN c2.color IS NULL THEN c1.color WHEN c1.color = c2.color THEN c1.color ELSE 'gray' END AS color FROM superhero2 s LEFT JOIN cte c1 ON s.id = c1.parent_id LEFT JOIN cte c2 ON s.id = c2.parent_id ) UPDATE superhero2 SET color = cte.color FROM cte WHERE superhero2.id = cte.id"], "preprocess_sql": ["CREATE TABLE superhero2 ( id text NOT NULL, parent_id text NULL, color text NULL, PRIMARY KEY (id) );", "INSERT INTO superhero2 (parent_id, id, color) VALUES (null, 'A', null), ('A', 'AB', null), ('A', 'AC', null), ('AB', 'ABD', null), ('ABD', 'ABDE', 'green'), ('AC', 'ACF', null), ('AC', 'ACG', null), ('ACF', 'ACFH', 'red'), ('ACF', 'ACFI', 'green'), ('ACG', 'ACGJ', 'red'), ('ACG', 'ACGK', 'red');"], "clean_up_sql": ["DROP TABLE IF EXISTS superhero2;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT week_start, count(*) AS count, AVG(\"CL\") AS cl, AVG(\"C\") AS c FROM (SELECT generate_series('2021-01-07 00:00:00'::timestamp, '2022-01-06 23:59:59'::timestamp, '7 days'::interval) AS week_start) gs INNER JOIN \"Experiment\" e ON e.\"TIMESTAMP\" >= gs.week_start AND e.\"TIMESTAMP\" < gs.week_start + '7 days'::interval GROUP BY week_start ORDER BY week_start ASC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_175", "db_id": "superhero", "query": "We need to count the occurrences of specific superheroes in two different datasets: one dataset includes superheroes with a specific gender, and the other includes superheroes with a specific alignment. We want to return a single result set that includes the counts of these superheroes from both datasets. The challenge is to ensure that the query is optimized and that the database planner can effectively use indexes to speed up the query. The user encountered an issue where applying the filter condition after the join operation prevented the planner from using indexes, leading to a suboptimal execution plan. The user wants to avoid manually applying the filter condition to each joined table to maintain query simplicity and performance.", "issue_sql": ["SELECT *\nFROM (\n  SELECT gender_id, COUNT(*) as cnt1\n  FROM superhero\n  WHERE gender_id IN (1, 2)\n  GROUP BY gender_id\n) AS c1\nFULL OUTER JOIN (\n  SELECT alignment_id, COUNT(*) as cnt2\n  FROM superhero\n  WHERE alignment_id IN (1, 2)\n  GROUP BY alignment_id\n) AS c2\nON c1.gender_id = c2.alignment_id\nWHERE c1.gender_id IN (1,2) AND c2.alignment_id IN (1,2);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["CREATE FUNCTION calculate_loan_status()\n    RETURNS SETOF loan_last\n    AS $$\n    BEGIN\n    CREATE TABLE  IF NOT EXISTS temp_table AS\n    SELECT loan_id, status\n    FROM loan_first;\n    INSERT INTO loan_last SELECT loan_id, status FROM temp_table;\n    DROP TABLE temp_table;\n    END;\n    $$ LANGUAGE plpgsql;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries([\"DROP FUNCTION IF EXISTS calculate_loan_status;\"], db_name, conn)\n    res, exec_err, _ = execute_queries(pred_sqls, db_name, conn)\n    assert exec_err == False\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_176", "db_id": "card_games", "query": "In the context of a card games database, I have a table named 'cards' that tracks each card's details, including its artist, name, and set code. Each card can belong to multiple sets, and each set can contain multiple cards. I want to generate a list of artists with the most cards in the database. However, for a comprehensive view, I need to list all sets and the count of cards per set for each artist, alongside the set with the highest number of cards. I'm not interested in artists with only one card. The result should be ordered by the artist with the most cards first, followed by the rest of the sets for the same artist, and so on. Here's the SQL query I tried, but it doesn't fully meet my requirements:", "issue_sql": ["SELECT artist, setcode, COUNT(setcode) AS counter FROM cards GROUP BY setcode, artist HAVING COUNT(setcode) > 1 ORDER BY counter DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["UPDATE superhero SET total_powers = (SELECT COUNT(power_id) FROM hero_power WHERE hero_id = superhero.id)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    execute_queries(sol_sqls, db_name, conn)\n    sol_sqls_result = execute_queries([\"SELECT total_powers FROM superhero ORDER BY id;\"], db_name, conn)\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\""]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_177", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, we have a table that tracks the lineup changes between consecutive matches for football teams. Each row in the table represents a match, and it includes the match ID, the player IDs in the current lineup, and the player IDs in the next lineup. We need to count the number of players who are scheduled to play in the next match and are already in the current lineup. For example, if a player is listed twice in the current lineup and once in the next lineup, they should be counted only once. The user attempted to write a query to achieve this but encountered issues with the logic and syntax.", "issue_sql": ["SELECT match_id, current_lineup, next_lineup, (SELECT COUNT(case when arr=matches then matches end) FROM unnest(current_lineup) arr CROSS JOIN unnest(next_lineup) matches WHERE arr IS NOT NULL AND matches IS NOT NULL ) FROM match_lineups;"], "preprocess_sql": ["CREATE TABLE match_lineups (match_id Integer PRIMARY KEY, current_lineup Integer[], next_lineup Integer[], created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, lineup_status VARCHAR(50) DEFAULT 'confirmed', lineup_version INTEGER DEFAULT 1, lineup_notes TEXT DEFAULT 'Standard lineup configuration', lineup_change_count INTEGER DEFAULT 0, is_final BOOLEAN DEFAULT true, metadata JSONB DEFAULT '{}'::jsonb, last_modified_by VARCHAR(100) DEFAULT 'system', lineup_effectiveness_rating NUMERIC(3,1) DEFAULT 0.0, scheduled_announcement_time TIMESTAMP DEFAULT NULL, tags TEXT[] DEFAULT '{}'::TEXT[])", "INSERT INTO match_lineups(match_id, current_lineup, next_lineup, created_at, updated_at, lineup_status, lineup_version, lineup_notes, lineup_change_count, is_final, metadata, last_modified_by, lineup_effectiveness_rating, scheduled_announcement_time, tags) VALUES (101, '{1, 2, 3, 4}', '{2, 4, 5}', '2023-01-15 08:30:00', '2023-01-16 10:15:00', 'confirmed', 2, 'Regular season lineup with defensive focus', 3, true, '{\"coach_approval\": true, \"tactical_formation\": \"4-3-3\"}'::jsonb, 'coach_smith', 7.5, '2023-01-16 12:00:00', '{\"defensive\",\"regular_season\"}')", "INSERT INTO match_lineups(match_id, current_lineup, next_lineup, created_at, updated_at, lineup_status, lineup_version, lineup_notes, lineup_change_count, is_final, metadata, last_modified_by, lineup_effectiveness_rating, scheduled_announcement_time, tags) VALUES (102, '{1, 3, 5, 6}', '{3, 5, 5, 7}', '2023-01-18 09:45:00', '2023-01-19 11:30:00', 'tentative', 3, 'Cup match lineup with offensive strategy', 5, false, '{\"coach_approval\": false, \"tactical_formation\": \"3-5-2\"}'::jsonb, 'coach_johnson', 8.2, '2023-01-20 14:30:00', '{\"offensive\",\"cup_match\",\"experimental\"}')"], "clean_up_sql": ["DROP TABLE match_lineups;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT id,\n       date,\n       got,\n       gpt\nFROM (\n    SELECT t.*,\n           ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY t.date DESC) AS rn,\n           COUNT(*) OVER (PARTITION BY t.id) AS cnt\n    FROM Laboratory t\n) AS sub\nWHERE rn = 1\n  AND cnt > 1;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_178", "db_id": "formula_1", "query": "I have a table called circuit_json that contains details about Formula 1 circuits. The table has a column named circuit_id_name, which stores JSON data with information about circuit IDs and their corresponding names. I am trying to extract the circuit ID and name into separate columns for better readability. Here is my attempt and the query I used:", "issue_sql": ["SELECT *\nFROM jsonb_to_record(circuit_id_name) AS x(circuitid int, name text)\nFROM circuit_json;"], "preprocess_sql": ["CREATE TABLE circuit_json AS SELECT json_build_object('circuitid', circuitid, 'name', name) as circuit_id_name FROM circuits;"], "clean_up_sql": ["DROP TABLE circuit_json;"], "category": "Personalization", "efficiency": false, "sol_sql": ["with u as (select *, row_number() over(order by circui_name_A1, circui_name_A2, circui_name_A3, circui_name_B1, circui_name_B2, circui_name_B3) as rn from race_info), v as (select circui_name_A1 AS A, circui_name_B1 as B, rn from u union all select circui_name_A2 AS A, circui_name_B2 as B, rn from u union all select circui_name_A3 AS A, circui_name_B3 as B, rn from u) select string_agg(A, ' ' order by A) as A, string_agg(B, ' ' order by B) as B from v group by rn"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_179", "db_id": "superhero", "query": "We have a table `hero_attribute` that stores the attribute values of superheroes. Each superhero can have multiple attributes, such as Intelligence, Strength, and Speed. The data in `hero_attribute` includes the `hero_id`, `attribute_id`, and `attribute_value`. We want to insert this data into another table `hero_attribute_bifurcation` where each attribute value greater than 50 is split into multiple rows of 50 and the remaining amount (if any) is inserted as a separate row. The new table `hero_attribute_bifurcation` should include the columns `hero_id`, `attribute_id`, `attribute_value`, and `is_bifurcated` indicating whether the attribute value was split (1) or not (0). The inserted data set should reflect this bifurcation logic.", "issue_sql": ["INSERT INTO hero_attribute_bifurcation (hero_id, attribute_id, attribute_chunk, is_bifurcated)\nSELECT\n    hero_id,\n    attribute_id,\n    attribute_value,\n    CAST(attribute_value > 100 AS integer) AS is_bifurcated\nFROM hero_attribute;"], "preprocess_sql": ["CREATE TABLE hero_attribute_bifurcation (hero_id bigint, attribute_id bigint, attribute_chunk bigint, is_bifurcated integer, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, last_calculation_date DATE DEFAULT CURRENT_DATE, calculation_version INTEGER DEFAULT 1, attribute_status VARCHAR(50) DEFAULT 'active', calculation_method VARCHAR(100) DEFAULT 'standard', notes TEXT DEFAULT NULL, is_verified BOOLEAN DEFAULT false, confidence_score NUMERIC(5,2) DEFAULT 0.0, metadata JSONB DEFAULT '{}'::jsonb, processing_batch_id UUID DEFAULT gen_random_uuid(), attribute_history TEXT[] DEFAULT ARRAY[]::TEXT[], calculation_duration_ms INTEGER DEFAULT 0, source_system VARCHAR(100) DEFAULT 'main_database', is_manually_adjusted BOOLEAN DEFAULT false, adjustment_reason TEXT DEFAULT NULL);"], "clean_up_sql": ["DROP TABLE hero_attribute_bifurcation;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH day_min_time AS (SELECT Min(date_value) min_time, Date(date_value) dt, card_id FROM card_prices GROUP BY Date(date_value), card_id), day_max_time AS (SELECT Max(cp.date_value) max_time, Date(cp.date_value) dt, cp.card_id FROM card_prices cp JOIN day_min_time dmt ON cp.card_id = dmt.card_id AND Date(cp.date_value) = dmt.dt WHERE cp.date_value <= dmt.min_time + interval '15 minutes' GROUP BY date(cp.date_value), cp.card_id) SELECT card_id, round(avg(price_difference)) average_difference FROM (SELECT max(cp.price)-min(cp.price) price_difference, cp.card_id, date(cp.date_value) FROM card_prices cp INNER JOIN day_min_time min_dmt ON min_dmt.card_id = cp.card_id AND date(cp.date_value) = min_dmt.dt INNER JOIN day_max_time max_dmt ON max_dmt.card_id = cp.card_id AND date(cp.date_value) = max_dmt.dt WHERE cp.date_value BETWEEN min_dmt.min_time AND max_dmt.max_time GROUP BY cp.card_id, date(cp.date_value)) final_inline_view GROUP BY card_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_180", "db_id": "financial", "query": "I need to get a list of all districts from the account table. For each district, I want two arrays of loan IDs from the loan table. The first array should include loan IDs where the status is either 'A' or 'B', and the second array should include loan IDs where the status is 'C'. The results should be grouped by district_id and ordered by district_id.", "issue_sql": ["SELECT y.district_id,\n       CASE WHEN y.status IN ('A', 'B') THEN array_agg(loan_id) END AS type_A_B,\n       CASE WHEN y.status = 'C' THEN array_agg(loan_id) END AS type_C\nFROM (\n  SELECT x.district_id, l.loan_id, l.status\n  FROM loan l\n  JOIN account x ON l.account_id = x.account_id\n) y\nGROUP BY 1, y.status\nORDER BY 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT bond_id as current_bond, LEAD(bond_id) OVER (ORDER BY bond_id) as next_bond, bond_type as bond_type FROM bond b"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_181", "db_id": "superhero", "query": "In the superhero database, we have a timeseries of superhero activities recorded at 5-minute intervals. Each activity is associated with a specific superhero and an activity code. We need to aggregate these activities so that consecutive activities (over several continuous intervals) by the same superhero with the same activity code are grouped together, and the interval is summed up. The goal is to produce a list of valid intervals for each superhero and activity code combination.", "issue_sql": ["SELECT ts, superhero_id, activity_code, LEAD(ts) OVER (PARTITION BY superhero_id, activity_code ORDER BY ts) as next_ts FROM superhero_activities"], "preprocess_sql": ["CREATE TABLE superhero_activities ( ts timestamptz, activity_code bigint, superhero_id bigint );", "INSERT INTO superhero_activities VALUES ('2023-03-01 12:00:00', 1, 1), ('2023-03-01 12:05:00', 1, 1), ('2023-03-01 12:10:00', 1, 1), ('2023-03-01 12:10:00', 2, 1), ('2023-03-01 12:25:00', 1, 1), ('2023-03-01 12:30:00', 1, 1), ('2023-03-01 12:00:00', 1, 2), ('2023-03-01 12:20:00', 1, 2), ('2023-03-01 12:20:00', 3, 2), ('2023-03-01 12:25:00', 3, 2);"], "clean_up_sql": ["DROP TABLE superhero_activities;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT timestamp, avg(strength) over (partition by (date_trunc('hour', timestamp - interval '1 minute'))) as avg_strength FROM bond_strength WHERE timestamp >= date_trunc('hour', '2023-10-01 02:30:00'::timestamp) - INTERVAL '1 hour' AND timestamp < date_trunc('hour', '2023-10-01 02:30:00'::timestamp)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_182", "db_id": "card_games", "query": "I am working on a project to analyze card game tournaments and their participants. I have three tables: 'card_players', 'card_matches', and 'tournaments'. The 'card_players' table contains information about the players, the 'card_matches' table contains information about the matches played, and the 'tournaments' table contains information about the tournaments. I want to count how many tournaments have had at least one match where a player of type 'Pro' has participated. However, if both players in a match are of type 'Pro', I only want to count one tournament. Here's a simplified SQL of my database schema and some seed data. The problematic SQL query I used is provided below, and it counts both players in a match as separate tournaments, which is incorrect. I need a corrected query that counts each tournament only once if there is at least one 'Pro' player in any match.", "issue_sql": ["SELECT count(*) FROM card_matches INNER JOIN card_players ON card_matches.player1_id = card_players.id OR card_matches.player2_id = card_players.id WHERE card_players.type = 'Pro'"], "preprocess_sql": ["CREATE TABLE card_players (id bigint NOT NULL, name text NOT NULL, type text NOT NULL, PRIMARY KEY(id));", "CREATE TABLE card_matches (id bigint NOT NULL, tournament_id bigint NOT NULL, player1_id bigint NOT NULL, player2_id bigint NOT NULL, PRIMARY KEY(id));", "CREATE TABLE tournaments (id bigint NOT NULL, name text NOT NULL, PRIMARY KEY(id));", "INSERT INTO card_players (id, name, type) VALUES (1, 'Alice', 'Pro'), (2, 'Bob', 'Pro'), (3, 'Charlie', 'Amateur'), (4, 'David', 'Amateur');", "INSERT INTO tournaments (id, name) VALUES (1, 'Grand Prix'), (2, 'Pro Tour'), (3, 'Super Bowl');", "INSERT INTO card_matches (id, tournament_id, player1_id, player2_id) VALUES (1, 1, 1, 3), (2, 1, 2, 4), (3, 2, 1, 2), (4, 3, 3, 4), (5, 2, 3, 4);"], "clean_up_sql": ["DROP TABLE card_players;", "DROP TABLE card_matches;", "DROP TABLE tournaments;"], "category": "Query", "efficiency": false, "sol_sql": ["select jsonb_set(t.data, '{purchaseurls}', (select jsonb_agg(case when v.value::text ~ 'tcgplayer' or v.value::text ~ 'cardKingdom' then v.value::text else md5(v.value::text) end) from jsonb_array_elements(t.data -> 'purchaseurls') v)) from cards_info t"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_183", "db_id": "european_football_2", "query": "In the context of the European Football database, I have a set of matches where each match has a related home team, away team, season, and date. Most matches have been played several times during a season. In some cases, several matches took place at the same day and in the same league. I'd like to have one group (a match series) for all matches that have been played together during one season in one specific league, something like this:\n| League ID | Season | Match IDs(a list of match ids) | Dates(a list of match dates)\nI've been doing the heavy lifting in Python, but the code is quite slow and involves lots of queries. I've been wondering if any of you has ideas to combine the matches in one (or a few) queries?\\nI have had no success doing this in Postgres so far.", "issue_sql": ["WITH all_dates AS (SELECT league_id, season, ARRAY_AGG(DISTINCT id order by id) as match_ids, date AS match_date FROM match WHERE season IS NOT NULL AND league_id IS NOT NULL AND id is not null AND date IS NOT NULL GROUP BY league_id, season, date) SELECT DISTINCT league_id, season, match_ids, ARRAY_AGG(DISTINCT all_dates.match_date ORDER BY match_date) AS dates FROM all_dates GROUP BY season, league_id, match_ids order by league_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["select t1.product_id, t1.sales_value - t2.sales_value from sales_data t1 join sales_data t2 on t1.product_id = t2.product_id and t2.date_num = 567 where t1.date_num = 123"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_184", "db_id": "card_games", "query": "We have a dataset of card rulings in the 'ruling' table, where each ruling is associated with a unique card UUID. We need to transform this dataset into a format where each row represents a unique ruling id, and each column represents a different card UUID. The values in the cells should be the ruling text for that card. For each unique id, group all rules by card_uuid (e.g., card1, card2, card3). Assign a row number starting from 1 for each card_uuid grouping, and place the corresponding rule in the appropriate column. If a card_uuid doesn't have a rule for an id, insert NULL. The final output should have one row per id, with columns for each card_uuid and the corresponding rules or NULLs. The expected output should have ruling ids as rows and card UUIDs as columns, with ruling texts as the cell values. There are 3 uuids:'5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c' as card1, '56f4935b-f6c5-59b9-88bf-9bcce20247ce' as card2, '6d268c95-c176-5766-9a46-c14f739aba1c' as card3.\n The expected output is like | id | card1 ruling | card2 ruling | card3 ruling |\nHowever, when attempting to use the crosstab function, we encountered an error. Here is the problematic query we tried:", "issue_sql": ["select * from crosstab ('select id, uuid, text from ruling order by 1,2') AS final_result(id int, uuid1 text, uuid2 text, uuid3 text);"], "preprocess_sql": ["CREATE TABLE ruling ( id integer, text text NULL, uuid text NULL);", "INSERT INTO ruling (id, text, uuid) VALUES (1, 'First ruling text', '5f8287b1-5bb6-5f4c-ad17-316a40d5bb0c'), (2, 'Second ruling text', '56f4935b-f6c5-59b9-88bf-9bcce20247ce'), (2, 'Second ruling text 2', '56f4935b-f6c5-59b9-88bf-9bcce20247ce'), (2, 'Second ruling text 3', '56f4935b-f6c5-59b9-88bf-9bcce20247ce'), (3, 'Third ruling text', '6d268c95-c176-5766-9a46-c14f739aba1c');"], "clean_up_sql": ["DROP TABLE ruling;"], "category": "Query", "efficiency": false, "sol_sql": ["DROP TABLE IF EXISTS temp_superhero;", "CREATE TABLE temp_superhero (id int);", "CREATE OR REPLACE FUNCTION insert_and_return(int) RETURNS int AS $$ BEGIN INSERT INTO temp_superhero VALUES ($1); RETURN $1; END; $$ LANGUAGE plpgsql;", "table temp_superhero union all select insert_and_return(10);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_185", "db_id": "card_games", "query": "\nIn the card_games database, there are two tables: cards_info and card_choice. The cards_info table contains information about various Magic: The Gathering cards, including their IDs and names. The card_choice table contains information about the customers' selections of different card types, including the card's ID and a JSONB field that lists the IDs of corresponding non-valid cards. These non-valid cards are the ones that a customer has deemed unsuitable or irrelevant to their selection, represented as an array of card IDs. The goal is to query the cards_info table and return the cards that are not listed in the non_valid_cards array for each card choice, based on the matching card_id.\n", "issue_sql": ["SELECT c.*\nFROM cards_info c\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM card_choice cc\n    WHERE cc.card_id = c.id\n    AND c.id = ANY (cc.non_valid_cards)\n);"], "preprocess_sql": ["\nCREATE TABLE cards_info (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL\n);\nINSERT INTO cards_info (id, name)\nVALUES\n    (1, 'Ancestor`s Chosen'),\n    (2, 'Angel of Mercy'),\n    (3, 'Aven Cloudchaser');\n                   \nCREATE TABLE card_choice (\n    id SERIAL PRIMARY KEY,\n    card_id INT REFERENCES cards_info(id),\n    non_valid_cards JSONB\n);\nINSERT INTO card_choice (id, card_id, non_valid_cards)\nVALUES\n    (1, 1, '[1,3]'),\n    (2, 3, '[1]'),\n    (3, 2, '[2,3]');\n"], "clean_up_sql": ["DROP TABLE IF EXISTS cards_info; DROP TABLE IF EXISTS card_choice;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT count(*) FROM (SELECT DISTINCT molecule_id FROM bond WHERE bond_type != '-') AS molecule_without_bond_type;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_186", "db_id": "card_games", "query": "\nI have a certain hierarchy of data in the card_type table, where each row represents a type of cards with a unique identifier (uuid), a type name (card_name), and a reference to its parent card through the parent_uuid. The data is structured in a way that cards can be grouped under parent cards, forming a tree-like hierarchy.\nI initially managed to create a recursive query that fetches the data, but the result isn't in the format I desire. The query correctly returns each card along with a list of parent uuids. However, instead of having the list of parent uuids, I would prefer to have a structured output where each parent card includes a list of its child cards (i.e., uuid and card_name).\nFor example, I want to convert the result into a structure where each parent card lists all its direct child cards grouped together, forming a tree-like structure. This would help me better visualize the hierarchy and relationships between the cards, with each parent card having an array of its children's uuid values.\nCan you guide me on how to achieve this transformation using SQL?\n", "issue_sql": ["WITH RECURSIVE nodes AS (\n    SELECT\n        uuid,\n        card_name AS name,\n        ARRAY[]::uuid[] AS parents\n    FROM card_type\n    WHERE parent_uuid IS NULL\n\n    UNION ALL\n\n    SELECT\n        c.uuid,\n        c.card_name AS name,\n        nodes.parents || c.uuid\n    FROM card_type c\n    JOIN nodes ON nodes.uuid = c.parent_uuid\n)\nSELECT * FROM nodes;"], "preprocess_sql": ["CREATE TABLE card_type (\n    uuid uuid NOT NULL PRIMARY KEY,\n    card_name character varying(32),\n    parent_uuid uuid REFERENCES card_type(uuid),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    is_active BOOLEAN DEFAULT TRUE,\n    popularity_score INTEGER DEFAULT 0,\n    description TEXT DEFAULT '',\n    metadata JSONB DEFAULT '{}'::jsonb,\n    version_number INTEGER DEFAULT 1,\n    last_used_date DATE DEFAULT CURRENT_DATE,\n    color_identity VARCHAR(50) DEFAULT 'colorless',\n    rarity_level VARCHAR(20) DEFAULT 'common',\n    search_tags TEXT[] DEFAULT ARRAY[]::TEXT[],\n    historical_references JSONB DEFAULT '[]'::jsonb\n);", "INSERT INTO card_type (uuid, card_name, parent_uuid, created_at, updated_at, is_active, popularity_score, description, metadata, version_number, last_used_date, color_identity, rarity_level, search_tags, historical_references) \nVALUES \n('8a70180b-3644-4b17-af5f-93cbe0090cce', 'Creature', null, '2022-01-01 00:00:00+00', '2022-01-01 00:00:00+00', true, 100, 'Base creature type for all living entities', '{\"power_range\": \"0-15\", \"toughness_range\": \"0-15\"}'::jsonb, 1, '2022-01-01', 'all', 'common', ARRAY['monster', 'living', 'being']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb),\n('d9093660-241a-48f6-bf09-b6a8c6c7f12a', 'Human', '8a70180b-3644-4b17-af5f-93cbe0090cce', '2022-01-02 00:00:00+00', '2022-01-02 00:00:00+00', true, 95, 'Human creature type representing people', '{\"typical_power\": \"1-3\", \"typical_toughness\": \"1-3\"}'::jsonb, 1, '2022-01-02', 'white', 'common', ARRAY['humanoid', 'person', 'mortal']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb),\n('376ae1cb-425d-44d2-b19a-19b6f1e86314', 'Cleric', 'd9093660-241a-48f6-bf09-b6a8c6c7f12a', '2022-01-03 00:00:00+00', '2022-01-03 00:00:00+00', true, 80, 'Religious figures with healing abilities', '{\"abilities\": [\"healing\", \"protection\", \"buffing\"]}'::jsonb, 1, '2022-01-03', 'white', 'uncommon', ARRAY['healer', 'priest', 'religious']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb),\n('5d5f174a-5c8e-4d12-912f-8173e255e35a', 'Knight', 'd9093660-241a-48f6-bf09-b6a8c6c7f12a', '2022-01-04 00:00:00+00', '2022-01-04 00:00:00+00', true, 85, 'Armored warriors with combat training', '{\"abilities\": [\"first strike\", \"vigilance\", \"protection\"]}'::jsonb, 1, '2022-01-04', 'white', 'uncommon', ARRAY['warrior', 'soldier', 'mounted']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb),\n('f79f5fa0-6eaf-465b-9b14-e3b49c5ac9ef', 'Enchantment', null, '2022-01-05 00:00:00+00', '2022-01-05 00:00:00+00', true, 90, 'Magical effects that persist on the battlefield', '{\"permanence\": \"high\", \"removal_difficulty\": \"medium\"}'::jsonb, 1, '2022-01-05', 'all', 'common', ARRAY['magic', 'spell', 'persistent']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb),\n('8aa95eda-7963-40ef-be44-076cdf06c5c1', 'Aura', 'f79f5fa0-6eaf-465b-9b14-e3b49c5ac9ef', '2022-01-06 00:00:00+00', '2022-01-06 00:00:00+00', true, 75, 'Enchantments that attach to other permanents', '{\"target_types\": [\"creature\", \"land\", \"artifact\", \"player\"]}'::jsonb, 1, '2022-01-06', 'all', 'common', ARRAY['attachment', 'buff', 'debuff']::TEXT[], '[{\"edition\": \"alpha\", \"year\": 1993}]'::jsonb);"], "clean_up_sql": ["DROP TABLE IF EXISTS card_type;"], "category": "Personalization", "efficiency": false, "sol_sql": ["create or replace function setup_vector_store(table_name text) returns void language plpgsql as $f1$ begin execute format($dynsql$ create table %1$I (id bigint primary key generated always as identity, description text, metadata jsonb); drop function if exists match_strategies(int, jsonb); create function match_strategies (match_count int default null, filter jsonb default '{}'::jsonb) returns table (id bigint, description text, metadata jsonb, similarity float) language plpgsql as $f2$ begin return query select id, description, metadata, 1 as similarity from %1$I where metadata @> filter limit match_count; end; $f2$; $dynsql$, table_name); end; $f1$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    execute_queries(pred_sqls, db_name, conn)\n    execute_queries([\"SELECT setup_vector_store('my_strategy');\"], db_name, conn)\n    pred_sqls_result = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'my_strategy';\"], db_name, conn)[0]\n    execute_queries(sol_sqls, db_name, conn)\n    execute_queries([\"DROP TABLE IF EXISTS my_strategy\"], db_name, conn)\n    execute_queries([\"SELECT setup_vector_store('my_strategy');\"], db_name, conn)\n    sol_sqls_result = execute_queries([\"SELECT table_name FROM information_schema.tables WHERE table_name = 'my_strategy';\"], db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_187", "db_id": "student_club", "query": "In the context of the student_club database, we have two tables: `event` and `budget`. The `event` table contains information about various events, including their start dates and statuses. The `budget` table contains financial details related to these events, including the amount budgeted and the remaining budget. The user wants to know the average remaining budget and the number of events that are open or closed on a daily basis between '2020-01-01' and '2020-03-31'. The user attempted to write a query to achieve this, but it resulted in incorrect results or errors. Below is the problematic SQL statement the user used, followed by the corrected solution.", "issue_sql": ["SELECT d.the_day AS \"Date\", COUNT(e.event_id) AS \"Number of Events\", AVG(b.remaining) AS \"Avg Remaining Budget\" FROM (SELECT ts::date AS the_day FROM generate_series (timestamp '2020-01-01', timestamp '2020-03-31', interval '1 day'::interval) ts) d LEFT JOIN \"event\" e ON e.event_date::date = d.the_day LEFT JOIN budget b ON b.link_to_event = e.event_id GROUP BY d.the_day ORDER BY d.the_day;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT sd.name AS \"Country\", td.years AS \"Year\", bt.name AS \"ProductType\", pl.name AS \"Language\", g.name AS \"Genre\", COALESCE(SUM(dp.value), 0) AS \"sum\" FROM spatial_dimension sd CROSS JOIN time_dimension td CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'ProductType')) bt CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'publishing_language')) pl CROSS JOIN (SELECT id, name FROM variablevalue WHERE variable_id = (SELECT id FROM variable WHERE name = 'genre')) g LEFT JOIN datapoints dp ON dp.spatial_dimension_id = sd.id AND dp.time_dimension_id = td.id AND EXISTS (SELECT 1 FROM datapoint_variablevalue dv WHERE dv.datapoint_id = dp.id AND dv.variablevalue_id IN (bt.id, pl.id, g.id) GROUP BY dv.datapoint_id HAVING COUNT(DISTINCT dv.variablevalue_id) = 3) GROUP BY sd.name, td.years, bt.name, pl.name, g.name ORDER BY \"Year\" DESC, \"Country\", \"ProductType\", \"Language\", \"Genre\";"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_188", "db_id": "financial", "query": "I log the daily transactions of my bank accounts. Now I want to create a SQL statement to get the sum of transaction amounts for each month but separate columns for each year. I came up with the following SQL statement: sql SELECT LPAD(extract (month from trans.date)::text, 2, '0') as month, sum(trans.amount) as 1998 from trans WHERE trans.date >= '1998-01-01' and trans.date < '1999-01-01' group by month order by 1;  This results in only getting the values from 1998: | month | a1998 | | -------- | -------------- | | 1    | 100            | | 2   | 358            | | 3   | 495            | How could I change the SQL statement to get new columns for each year? Is this even possible?", "issue_sql": ["SELECT LPAD(extract (month from trans.date)::text, 2, '0') as month, sum(trans.amount) as a1997 from trans WHERE trans.date >= '1997-01-01' and trans.date < '1998-01-01' group by month order by 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT relname, pg_size_pretty(pg_relation_size(relid)) AS table_size FROM pg_stat_user_tables ORDER BY pg_relation_size(relid) DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_189", "db_id": "formula_1", "query": "I'm trying to run a query that will find circuits within a given distance of any of the selected locations. This is for a search result where users can select multiple locations to look around. My current approach is to use `ST_ClosestPoint` and pass in an array of `ST_Point` generated in PHP. Then I pass that string into `ST_Collect`. However, this doesn't work because it looks like `ST_ClosestPoint` doesn't like these mixed arguments. I have a `gist(coordinate::geography)` index on `circuits` which seems like it would be useful to use. What am I missing - is there a better way to do this, or is this a bad approach? Should I be performing the query each time with a different location?", "issue_sql": ["SELECT * FROM circuits WHERE ST_DWithin(ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography, ST_ClosestPoint((ST_MakePoint(lng, lat), 4326)::geography, ST_Collect(Array[ST_SetSRID(ST_MakePoint(2.76083, 101.73800), 4326)::geography, ST_SetSRID(ST_MakePoint(26.03250, 50.51060), 4326)::geography])), 1000000, FALSE);"], "preprocess_sql": ["CREATE EXTENSION postgis;"], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT string_agg(token, '#') AS result FROM (SELECT token, idx, row_number() OVER (ORDER BY idx) AS rn FROM match_events, string_to_table(event_description, '#') WITH ORDINALITY AS a(token, idx) GROUP BY token, idx HAVING count(token) = (SELECT count(*) FROM match_events) ORDER BY idx) sub WHERE  idx = rn;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_190", "db_id": "formula_1", "query": "In the Formula 1 database, I have a results table currently containing around 400 million entries and the following query on it:\n\nThe query retrieves the top 10 result IDs for a specific driver or another driver, ordered by the result ID in descending order. The query works fine when filtering by a single driver ID, but it takes several minutes when filtering by two driver IDs, even if both drivers have a small number of results (e.g., 2 for the first driver and 57 for the second driver). The issue seems to be related to the combination of ORDER BY and LIMIT clauses.", "issue_sql": ["SELECT resultid FROM results WHERE driverid = 3 OR driverid = 4 ORDER BY resultid DESC LIMIT 10"], "preprocess_sql": [], "clean_up_sql": [], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT player_api_id, player_name FROM player WHERE id = (SELECT MAX(id) FROM player WHERE player_name LIKE 'Ale%' AND player_fifa_api_id > 220000);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_191", "db_id": "card_games", "query": "In a multiplayer card game platform, when a player is misbehaving, their 'muted' status is set to true. Chat messages from muted players should be hidden from all other players except the muted player themselves to prevent them from noticing their muted status and creating new accounts. The platform uses PostgreSQL 14.2 and has the following tables: 'words_users', 'words_social', 'words_games', and 'words_chat'. The user has prepared a test case with two users, one of whom is muted, and a game where both users have exchanged messages. The user's current SQL function to retrieve chat messages does not filter out messages from muted players for other players. The user seeks to modify the SQL function to hide messages from muted players for everyone except the muted player themselves.", "issue_sql": ["CREATE OR REPLACE FUNCTION words_get_chat(in_gid integer, in_social integer, in_sid text) RETURNS TABLE (out_mine integer, out_msg text) AS $func$ SELECT CASE WHEN c.uid = s.uid THEN 1 ELSE 0 END, c.msg FROM words_chat c JOIN words_games g USING (gid) JOIN words_social s ON s.uid IN (g.player1, g.player2) WHERE c.gid = in_gid AND s.social = in_social AND s.sid = in_sid ORDER BY c.CREATED ASC; $func$ LANGUAGE sql;", "SELECT words_get_chat(10, 100, 'abc') AS nice_user;"], "preprocess_sql": ["CREATE TABLE words_users (uid SERIAL PRIMARY KEY, muted BOOLEAN NOT NULL DEFAULT false);", "CREATE TABLE words_social (sid text NOT NULL CHECK (sid ~ '\\S'), social integer NOT NULL CHECK (0 < social AND social <= 256), given text NOT NULL CHECK (given ~ '\\S'), uid integer NOT NULL REFERENCES words_users ON DELETE CASCADE, PRIMARY KEY(sid, social));", "CREATE TABLE words_games (gid SERIAL PRIMARY KEY, player1 integer REFERENCES words_users(uid) ON DELETE CASCADE NOT NULL CHECK (player1 <> player2), player2 integer REFERENCES words_users(uid) ON DELETE CASCADE);", "CREATE TABLE words_chat (cid BIGSERIAL PRIMARY KEY, created timestamptz NOT NULL, gid integer NOT NULL REFERENCES words_games ON DELETE CASCADE, uid integer NOT NULL REFERENCES words_users ON DELETE CASCADE, msg text NOT NULL);", "INSERT INTO words_users (uid, muted) VALUES (1, false), (2, true);", "INSERT INTO words_social (sid, social, given, uid) VALUES ('abc', 100, 'Nice user', 1), ('def', 200, 'Bad user', 2);", "INSERT INTO words_games (gid, player1, player2) VALUES (10, 1, 2);", "INSERT INTO words_chat (gid, uid, created, msg) VALUES (10, 1, CURRENT_TIMESTAMP + INTERVAL '1 min', 'Hi how are you doing?'), (10, 1, CURRENT_TIMESTAMP + INTERVAL '2 min', 'I am a nice user'), (10, 2, CURRENT_TIMESTAMP + INTERVAL '3 min', 'F*** ***!!'), (10, 2, CURRENT_TIMESTAMP + INTERVAL '4 min', 'I am a bad user'), (10, 1, CURRENT_TIMESTAMP + INTERVAL '5 min', 'Are you there??');"], "clean_up_sql": ["DROP TABLE words_users;", "DROP TABLE words_social;", "DROP TABLE words_games;", "DROP TABLE words_chat;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT match_id, match_date FROM detail WHERE jsonb_path_exists (match_details, '$.player_stats[*] ? (@.player_id == $playerId && @.goals > 0)', jsonb_build_object('playerId', 103));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_192", "db_id": "formula_1", "query": "A Formula 1 team is analyzing the performance and financial impact of their drivers in various races. They need to calculate the total earnings for each driver based on their points and a bonus system. The bonus is calculated as follows: if the total earnings exceed 5000 points, a 20% bonus is applied; if the total earnings exceed 3000 points, a 15% bonus is applied. The team wants to avoid repeating the calculation of total earnings multiple times in their query.", "issue_sql": ["SELECT driverid, points, (points * 100) as earnings, CASE WHEN (points * 100) > 5000 THEN (points * 100) * 0.2 WHEN (points * 100) > 3000 THEN (points * 100) * 0.15 ELSE null END AS bonus FROM driverstandings"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH t AS (SELECT bond_id AS id, j.val, SUM((j.val ->> 'time')::numeric) OVER (partition by bond_id) AS s FROM bond CROSS JOIN LATERAL jsonb_each(bond_stat_) AS j(k, val)) SELECT id, val FROM t WHERE val ->> 'type' = 'Unknown' AND (val ->> 'time')::numeric > 0.1 * s;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result) == 2, f'Expected 2 rows, but found {len(pred_query_result)} rows.'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    \n   pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]   \n   for i in range(2):\n      if pred_query_result[i][0] == \"TR000_1_2\":\n         assert pred_query_result[i][1] == {\"time\": 500, \"type\": \"Unknown\", \"complete\": 100.0}, \"Wrong result 1.\"  \n      elif pred_query_result[i][0] == \"TR000_2_4\":\n         assert pred_query_result[i][1] == {\"time\": 55, \"type\": \"Unknown\", \"complete\": 100.0}, \"Wrong result 2.\"\n      else:\n         assert False, \"Wrong ID.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_193", "db_id": "european_football_2", "query": "The data returned as `dataset` in the CTE below represents the number of times team attributes were recorded for each date within a specific time frame. The dataset looks like this:\n\n| date | rows_added |\nHow can I incorporate a count of the duplicate records, by date, in the following CTE? If I was going to only count the duplicate dates I would use the following but I can't incorporate it into the CTE above:\n\nsql\nSELECT date, COUNT(date)\nFROM dataset \nGROUP BY date \nHAVING COUNT(date) >1 \n\n\nDesired output given the example above:\n\n|total_days_in_result_set | total_days_w_distinct_record_counts | toal_days_w_duplicate_record_counts | duplicate_dates |\n", "issue_sql": ["with dataset as (\n  SELECT\n      date,\n      COUNT(*) as rows_added\n  FROM\n      team_attributes\n  WHERE\n      date between '2010-01-01 00:00:00'\n      AND '2015-12-31 00:00:00'\n  GROUP BY\n      date\n )\nSELECT\n    COUNT(*) as total_days_in_result_set,\n    COUNT(DISTINCT rows_added) as total_days_w_distinct_record_counts,\n    COUNT(*) - COUNT(DISTINCT rows_added) as toal_days_w_duplicate_record_counts\nFROM dataset"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION public.corrected_function(type text DEFAULT 'Unknown'::text) RETURNS SETOF bond LANGUAGE sql STABLE AS $function$ select * from bond where bond_stat_ @? '$.** ? (@ == \"Unknown\")'; $function$", "SELECT bond_id FROM corrected_function();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_194", "db_id": "card_games", "query": "I'm trying to handle an array of counters column in Postgres for a card collection tracking system. For example, let's say I have this table:\n\n| card_name | counters | where counters is a list of numbers like [1,2,3,4] and now I'm adding 2 values [2,0,2,1] and [1,3,1,0]).\n\nI expect the query to sum between the 2 counters vectors on conflict ([1,3,1,0] + [2,0,2,1] = [3,3,3,1]).\n\nThe expected counters are [3,3,3,1]. I had a try but it didn't seem to work, what am I missing?", "issue_sql": ["insert into card_counters (card_name, counters) values ('Lightning Bolt', array[2,0,2,1]) on conflict (card_name) do update set counters = array_agg(unnest(card_counters.counters) + unnest(array[2,0,2,1]))"], "preprocess_sql": ["CREATE TABLE card_counters (card_name text PRIMARY KEY, counters integer[]);", "INSERT INTO card_counters (card_name, counters) VALUES ('Lightning Bolt', array[1,3,1,0]);"], "clean_up_sql": ["DROP TABLE card_counters;"], "category": "Management", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION check_conditional_unique() RETURNS TRIGGER AS $f$ BEGIN IF EXISTS (SELECT FROM match_results t2 WHERE (t2.match_id,t2.team_id) = (NEW.match_id,NEW.team_id) AND t2.score <> NEW.score) THEN RAISE EXCEPTION 'New values in score for the same match_id and team_id combination.'; END IF; IF EXISTS (SELECT FROM match_results t2 WHERE (t2.match_id,t2.team_id) <> (NEW.match_id,NEW.team_id) AND t2.score = NEW.score) THEN RAISE EXCEPTION 'Duplicate values in score for different match_id and team_id combination.'; END IF; RETURN NEW; END; $f$ LANGUAGE plpgsql;", "CREATE OR REPLACE TRIGGER check_unique_score_per_match_team BEFORE INSERT OR UPDATE ON match_results FOR EACH ROW EXECUTE FUNCTION check_conditional_unique();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    q1 = [\"INSERT INTO match_results (match_id, team_id, score) VALUES (1, 101, 7);\"]\n    execute_queries(q1, db_name, conn)\n    test = [\"SELECT * FROM match_results;\"]\n    pred_query_result = execute_queries(test, db_name, conn)[0]\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows.'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    q2 = [\"INSERT INTO match_results (match_id, team_id, score) VALUES (3, 101, 2);\"]\n    execute_queries(q2, db_name, conn)\n    test = [\"SELECT * FROM match_results;\"]\n    pred_query_result = execute_queries(test, db_name, conn)[0]\n    assert len(pred_query_result) == 5, f'Expected 5 rows, but found {len(pred_query_result)} rows.'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_195", "db_id": "erolp", "query": "In the erolp database, we have a table named sales_transactions that records the transaction details of a financial application. Each transaction has an id, a transaction amount (trx), an event multiplier (event), and a desired result (result_good) which is the accumulation of the transaction amounts and previous results, multiplied by the event multiplier. The user is trying to calculate the 'result_good' column based on the recursive relationship between the rows. The user has attempted various methods including arrays, lateral views, recursive views, custom functions, and variables but has not been successful. The expected output is | id | result | and result is retained to 6 decimal places", "issue_sql": ["select id, round(prev + event * sum(prev) over(order by id range between unbounded preceding and 1 preceding)::numeric(10, 6), 6) as not_quite_my_tempo from (select *, event*sum(trx) over(order by id) as prev from sales_transactions) t order by id"], "preprocess_sql": ["CREATE TABLE sales_transactions (id int, trx int, event numeric(10,5), result_good numeric(10,6));", "INSERT INTO sales_transactions (id, trx, event, result_good) VALUES (1, 20, 0.1, 2.000000), (2,-10, 0.1, 1.200000), (3, 20,-0.1,-3.320000), (4,-10, 0.1, 1.988000), (5, 20, 0.1, 4.186800), (6,-10,-0.1,-3.605480), (7, 20, 0.1, 5.244932);"], "clean_up_sql": ["DROP TABLE IF EXISTS sales_transactions;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE monthly_periods AS (SELECT rate, lower(time_span) AS start_date, upper(time_span) AS end_date FROM budgets UNION ALL SELECT rate, (start_date + interval '1 month')::date, end_date FROM monthly_periods WHERE start_date + interval '1 month' <= now() OR (end_date IS NOT NULL AND start_date + interval '1 month' < end_date)), daily_rates AS (SELECT rate, start_date, LEAST((start_date + interval '1 month')::date, CASE WHEN end_date IS NULL THEN now()::date ELSE end_date::date END) as period_end FROM monthly_periods ), days_in_period AS (SELECT rate, start_date, period_end, EXTRACT(DAY FROM (period_end - start_date)) as days_in_period FROM daily_rates), daily_series AS (SELECT rate, start_date, period_end, generate_series(start_date, period_end, '1 day'::interval) as day FROM days_in_period WHERE days_in_period > 0) SELECT day::date, rate / EXTRACT(DAY FROM (period_end - start_date)) as daily_rate FROM daily_series ORDER BY day;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_196", "db_id": "california_schools", "query": "We have a dataset of schools in California, and we are interested in analyzing the distribution of schools based on their funding type. We have created a Common Table Expression (CTE) named cte_funding_count that contains the count of schools for each funding type. The CTE looks like this:\n| fundingtype | count |\nFrom this CTE, we want to calculate the percentage of the count compared to the sum of the count as a new third column, and we want the percentage without decimals. However, when we do that, we get a sum of the percent column that is not exactly 100 due to rounding. How do we avoid this?", "issue_sql": ["WITH cte_funding_count AS (SELECT fundingtype, COUNT(*) AS count FROM schools GROUP BY fundingtype) SELECT fundingtype, count, ROUND(count*100/(SELECT SUM(count) FROM cte_funding_count),0) AS percent FROM cte_funding_count"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR replace FUNCTION to_number(argument text, default_result integer default -1) RETURNS integer LANGUAGE plpgsql AS $$  BEGIN RETURN argument::integer; EXCEPTION WHEN OTHERS THEN RETURN default_result; END $$;SELECT attribute_name, to_number(attribute_name) FROM attribute;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_197", "db_id": "thrombosis_prediction", "query": "In the thrombosis_prediction database, I need to find the first laboratory test activity for each patient that occurred between the patient's first recorded data date and the date of their first hospital admission. The laboratory table contains the test dates, and the patient table contains the first recorded data date and the admission date. The patient's ID is the common key between the two tables. I want to retrieve the date of the first laboratory test activity and patient id for patients with sex F.", "issue_sql": ["SELECT lab.date AS firstActivity, pat.id FROM patient pat JOIN laboratory lab ON lab.id = pat.id AND lab.date <= pat.description AND lab.date > pat.\"First Date\" WHERE pat.sex='F' order by pat.id"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT molecule_id, COUNT(*) AS total_bonds FROM bond GROUP BY molecule_id HAVING COUNT(*) > 5;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_198", "db_id": "card_games", "query": "In the card_games database, I have a table (cards) that contains an id column (id) and another column (keywords) that contains an array of strings. I have a select query (SelectQuery) that gets me an id that matches cards.id, as well as an array of values (RemoveKeywords). I would like to now remove from the keywords array, any strings that are contained in the RemoveKeywords array that match on id. If the array is empty, the output return is []. For example, given cards (1, ['test']) and selectquery (1, ['test']), the output is (1, []) but not none", "issue_sql": ["select id, array_agg(elem) from cards, unnest(string_to_array(cards.keywords, ',')::text[]) elem where elem <> all(SELECT unnest(sq.RemoveKeywords) from SelectQuery sq) and id in (61, 65) group by id order by id;"], "preprocess_sql": ["CREATE TABLE SelectQuery (id bigint, RemoveKeywords text[], created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, query_name VARCHAR(100) DEFAULT 'Unnamed Query', query_description TEXT DEFAULT NULL, is_active BOOLEAN DEFAULT TRUE, execution_count INTEGER DEFAULT 0, last_executed_at TIMESTAMP WITH TIME ZONE DEFAULT NULL, priority SMALLINT DEFAULT 5, query_hash UUID DEFAULT gen_random_uuid(), metadata JSONB DEFAULT '{}'::jsonb, expiration_date DATE DEFAULT (CURRENT_DATE + INTERVAL '1 year'), owner_id BIGINT DEFAULT NULL, version_number INTEGER DEFAULT 1, processing_status VARCHAR(50) DEFAULT 'pending', execution_time_ms NUMERIC(12, 4) DEFAULT 0.0, is_system_generated BOOLEAN DEFAULT FALSE, tags TEXT[] DEFAULT '{}'::text[], source_application VARCHAR(100) DEFAULT 'manual_entry');", "INSERT INTO SelectQuery (id, RemoveKeywords, query_name, query_description, is_active, priority, metadata, tags, source_application, execution_count, version_number) VALUES (65, ARRAY['Flying'], 'Flying Removal Query', 'Removes flying keyword from card abilities', TRUE, 3, '{\"purpose\": \"keyword_cleanup\", \"category\": \"flying\"}'::jsonb, ARRAY['cleanup', 'flying', 'keywords'], 'card_maintenance_tool', 12, 2), (61, ARRAY['Landwalk'], 'Landwalk Removal Query', 'Removes landwalk keyword from card abilities', TRUE, 4, '{\"purpose\": \"keyword_cleanup\", \"category\": \"landwalk\"}'::jsonb, ARRAY['cleanup', 'landwalk', 'keywords'], 'card_maintenance_tool', 8, 1);"], "clean_up_sql": ["DROP TABLE SelectQuery;"], "category": "Management", "efficiency": false, "sol_sql": ["WITH range_values AS ( SELECT date_trunc('week', min(date)) as minval, date_trunc('week', max(date)) as maxval FROM laboratory ), week_range AS ( SELECT generate_series(date_trunc('week', '1991-01-01'::date), now(), '1 week') as week FROM range_values ), grouped_labs AS ( SELECT date_trunc('week', date) as week, count(id) as total_tests FROM laboratory WHERE date >= '1991-01-01' GROUP BY 1 ) SELECT week_range.week, COALESCE(sum(total_tests)::integer, 0) AS total_labs FROM week_range LEFT OUTER JOIN grouped_labs on week_range.week = grouped_labs.week GROUP BY 1 ORDER BY 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_199", "db_id": "toxicology", "query": "We have a table named \"Experiment\" in the toxicology database that records the hourly measurements of various chemical reactions over a period of 2009 to the present. Each record includes a timestamp and the concentration levels of different chemicals such as Chlorine (CL) and Carbon (C). We need to aggregate (average) the concentration levels across different intervals from specific timepoints, for example, data from 2021-01-07T00:00:00.000Z for one year at 7 day intervals, or 3 months at 1 day interval or 7 days at 1h interval etc. The date_trunc() function partly solves this, but rounds the weeks to the nearest Monday, e.g. the following query returns the first time series interval as 2021-01-04 with an incorrect count:", "issue_sql": ["SELECT date_trunc('week', \"TIMESTAMP\") AS week, count(*), AVG(\"CL\") AS cl, AVG(\"C\") AS c FROM \"Experiment\" WHERE \"TIMESTAMP\" >= '2021-01-07T00:00:00.000Z' AND \"TIMESTAMP\" <= '2022-01-06T23:59:59.999Z' GROUP BY week ORDER BY week ASC"], "preprocess_sql": ["CREATE TABLE \"Experiment\" (\"TIMESTAMP\" timestamp NOT NULL, \"CL\" numeric NOT NULL, \"C\" numeric NOT NULL);", "INSERT INTO \"Experiment\" (\"TIMESTAMP\", \"CL\", \"C\") VALUES ('2021-01-07 00:00:00', 10.0, 5.0), ('2021-01-07 01:00:00', 11.0, 6.0), ('2021-01-14 00:00:00', 9.0, 4.0), ('2021-01-14 01:00:00', 10.0, 5.0), ('2021-01-21 00:00:00', 8.0, 3.0), ('2021-01-21 01:00:00', 9.0, 4.0);"], "clean_up_sql": ["DROP TABLE \"Experiment\";"], "category": "Query", "efficiency": false, "sol_sql": ["DROP FUNCTION IF EXISTS update_school_inventory_after_supply() CASCADE;CREATE OR REPLACE FUNCTION update_school_inventory_after_supply() RETURNS TRIGGER LANGUAGE plpgsql AS $trigger$ BEGIN UPDATE school_inventory AS s SET quantity = s.quantity - coalesce(OLD.quantity,0) + coalesce(NEW.quantity,0)WHERE s.cdscode = NEW.cdscode AND s.supply_name = NEW.supply_name; RETURN NEW; END; $trigger$;DROP TRIGGER IF EXISTS trigger_insert_supply ON school_supplies;CREATE TRIGGER trigger_insert_supply AFTER INSERT ON school_supplies FOR EACH ROW EXECUTE FUNCTION update_school_inventory_after_supply();"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    res, _, _ = execute_queries([\"SELECT cdscode, coalesce(ncesschool, '0') FROM schools ORDER BY cdscode LIMIT 1;\"], db_name,conn)\n    res_cdscode, res_nces = res[0][0], res[0][1]\n    check_sql = [f\"INSERT INTO school_inventory (cdscode, supply_name, quantity) VALUES ('{res_cdscode}', 'Pencils', {res_nces});\"]\n    execute_queries(check_sql, db_name,conn)\n    check_sql = [f\"INSERT INTO school_supplies (cdscode, supply_name, quantity) VALUES ('{res_cdscode}', 'Pencils', 100);\"]\n    execute_queries(check_sql, db_name,conn)\n    res, _, _ = execute_queries([f\"SELECT cdscode, quantity FROM school_inventory WHERE cdscode = '{res_cdscode}' LIMIT 1;\"], db_name,conn)\n    res_cdscode, quantity = res[0][0], res[0][1]\n    assert quantity == int(res_nces)+100, f\"The trigger does not work.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_200", "db_id": "financial", "query": "I am trying to create a function that performs some calculations using temporary tables within the function `calculate_loan_status`. However, I am encountering syntax errors when attempting to declare and use these temporary tables. Below is the problematic SQL code I have tried, followed by the error messages I received. I want to understand the correct syntax to achieve this.", "issue_sql": ["CREATE FUNCTION calculate_loan_status()\n    RETURNS SETOF loan_last\n    AS $$\n    DECLARE temp_table TABLE (loan_id int, status text);\n    BEGIN INSERT INTO temp_table\n    SELECT loan_id, status FROM loan_first WHERE status = 'A';\n    INSERT INTO loan_last SELECT loan_id, status FROM temp_table;\n    RETURN;\n    END;\n    $$ LANGUAGE plpgsql;"], "preprocess_sql": ["\n    DROP TABLE IF EXISTS loan_first;\n    CREATE TABLE loan_first AS\n    SELECT loan_id, status\n    FROM loan\n    ORDER BY loan_id\n    LIMIT 100;\n    ", "\n    DROP TABLE  IF EXISTS loan_last;\n    CREATE TABLE loan_last AS\n    SELECT loan_id, status\n    FROM loan\n    ORDER BY loan_id DESC\n    LIMIT 100;\n    "], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT s.cname AS county, sch.school, AVG(s.avgscrread + s.avgscrmath + s.avgscrwrite) / 3 AS avg_total_sat FROM satscores s JOIN schools sch ON s.cds = sch.cdscode WHERE s.cname IN (SELECT s.cname FROM satscores s GROUP BY s.cname ORDER BY AVG(s.avgscrread + s.avgscrmath + s.avgscrwrite) / 3 DESC nulls last LIMIT 5) GROUP BY s.cname, sch.school ORDER BY s.cname, avg_total_sat DESC;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_201", "db_id": "california_schools", "query": "I am trying to find a solution in PostgreSQL to add an extra column to the output of the query that indicates whether a school has any records in the FRPM table or not. I need to perform the following tasks:\\n1. Join the schools table with the satscores table.\\n2. Add a new column to the result output that checks if the school exists in the FRPM table based on the cdscode.\\nMy tables are:\\n- schools (contains information about schools)\\n- satscores (contains SAT scores for schools)\\n- frpm (contains free and reduced-price meal data for schools)\\nThis is what I have now. I did a left outer join and it works as expected:\\nsql \\nSELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite \\nFROM schools \\nLEFT OUTER JOIN satscores \\nON schools.cdscode = satscores.cds \\nWHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500; \\n\\nwith output:\\n| cdscode        | school                           | avgscrread | avgscrmath | avgscrwrite |\\n|----------------|----------------------------------|------------|------------|-------------|\\n| 01100170109835 | FAME Public Charter                | 525        | 514        | 503         |\\n| 01100170112607 | Envision Academy for Arts & Technology | 550        | 530        | 520         |\\nNow I can't find a solution of how to add an extra column `has_frpm_data` to the query response, where I will check if `schools.cdscode exists in frpm table under cdscode column`.\\nFor example, frpm table can have such data:\\n| cdscode        | Academic Year | County Code | District Code | School Code | County Name | District Name | School Name | District Type | School Type | Educational Option Type | NSLP Provision Status | Charter School (Y/N) | Charter School Number | Charter Funding Type | irc | Low Grade | High Grade | Enrollment (K-12) | Free Meal Count (K-12) | Percent (%) Eligible Free (K-12) | FRPM Count (K-12) | Percent (%) Eligible FRPM (K-12) | Enrollment (Ages 5-17) | Free Meal Count (Ages 5-17) | Percent (%) Eligible Free (Ages 5-17) | FRPM Count (Ages 5-17) | Percent (%) Eligible FRPM (Ages 5-17) | 2013-14 CALPADS Fall 1 Certification Status |\\n| 01100170109835 | 2020-2021     | 0691051     | 109835      | 109835      | Alameda     | Alameda County Office of Education | FAME Public Charter | Unified School District | High Schools (Public) | Traditional             | Provision 3             | 1                    | 0728                | Directly funded        | 1   | 9           | 12          | 1000              | 200                    | 20.0                          | 300               | 30.0                          | 1200                     | 250                         | 21.0                            | 350                      | 35.0                            | 1                                                   |\\n| 01100170112607 | 2020-2021     | 0691051     | 112607      | 112607      | Alameda     | Alameda County Office of Education | Envision Academy for Arts & Technology | Unified School District | High Schools (Public) | Traditional             | Provision 3             | 1                    | 0811                | Directly funded        | 1   | 9           | 12          | 1200              | 250                    | 21.0                          | 350               | 35.0                          | 1400                     | 300                         | 22.0                            | 400                      | 40.0                            | 1                                                   |\\nSo we see that some schools can appear in FRPM data several times (so I'm looking for at least 1 match). And some schools don't have FRPM data at all.\\nOutput finally should be like that:\\n| cdscode        | school                           | avgscrread | avgscrmath | avgscrwrite | has_frpm_data |\\n|----------------|----------------------------------|------------|------------|-------------|---------------|\\n| 01100170109835 | FAME Public Charter                | 525        | 514        | 503         | true          |\\n| 01100170112607 | Envision Academy for Arts & Technology | 550        | 530        | 520         | true          |\\n| 01100170118489 | Another School                   | 510        | 520        | 515         | false         |\\nThanks a lot for any help :)", "issue_sql": ["SELECT schools.cdscode, schools.school, satscores.avgscrread, satscores.avgscrmath, satscores.avgscrwrite FROM schools LEFT OUTER JOIN satscores ON schools.cdscode = satscores.cds WHERE schools.county = 'Alameda' AND satscores.avgscrread >= 500"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH vars AS (SELECT max(date) AS vars_id FROM laboratory) SELECT * FROM laboratory l JOIN vars ON l.date = vars.vars_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_202", "db_id": "superhero", "query": "I am trying to create a SQL query to update a column in my superhero table to reflect the total number of powers each superhero has. The superhero table currently has a column 'total_powers' which is NULL for all entries. The hero_power table contains the mapping of heroes to their powers. The result set should look like this:\\nsuperhero table:\\n|ID  |  superhero_name|  total_powers|\\n-----|-----------------|--------------|\\n|1   |  3-D Man        |  2           |\\n|2   |  A-Bomb         |  1           |\\n|3   |  Abe Sapien     |  1           |\\n|4   |  Superman       |  0           |\\nWhen there are no power rows for a superhero, the result should return 0.\\nI tried using:\\n\\nUPDATE superhero \\\\\\\\nSET total_powers = (SELECT COUNT(power_id) FROM hero_power);\\n\\nI don't know how to use GROUP BY to calculate for distinct count. The result works to show the count for all powers not by superhero.\\", "issue_sql": ["UPDATE superhero SET total_powers = (SELECT COUNT(power_id) FROM hero_power);"], "preprocess_sql": ["ALTER TABLE superhero ADD COLUMN total_powers INT DEFAULT NULL;"], "clean_up_sql": ["ALTER TABLE superhero DROP COLUMN total_powers;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM match_location\nWHERE ST_DWithin(\n    location::geography,\n    ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography,\n    2 * 1609.34\n);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_2 = perform_query_on_postgresql_databases(\"SELECT id, ST_AsText(location) AS location, ST_Distance(location::geography, ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography) AS distance_in_meters FROM match_location WHERE ST_Distance(location::geography, ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)::geography) <= 2 * 1609.34;\", db_name)[0]\n    assert len(test_pred_query_result_2) == len(pred_query_result), f'Expected {len(test_pred_query_result_2)} rows, but found {test_pred_query_result_2} rows'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_203", "db_id": "thrombosis_prediction", "query": "In the context of a medical database, I am working with a table that records laboratory test results for patients. This table has multiple entries for the same patient, identified by their ID, and each entry has a unique date when the test was conducted. My goal is to retrieve only the most recent test result for each patient, excluding those who have only one test result recorded. The table includes the following columns: ID (identifying the patient), Date (when the test was conducted), and various test results. I attempted to use a query that groups by ID and selects the maximum date, but I encountered an error stating that other columns must appear in the GROUP BY clause or be used in an aggregate function. Here is the problematic SQL I used: sql SELECT ID, Date, GOT, GPT FROM Laboratory GROUP BY ID HAVING COUNT(ID) > 1 ORDER BY Date DESC", "issue_sql": ["SELECT ID, Date, GOT, GPT FROM Laboratory GROUP BY ID HAVING COUNT(ID) > 1 ORDER BY Date DESC"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT column_name\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE table_name = 'learners' AND\n      character_maximum_length = 15;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result = execute_queries(pred_sqls,db_name,conn)\n    sol_query_result = execute_queries(sol_sqls,db_name,conn)\n    result = pred_query_result == sol_query_result\n    assert result, f\"ex returned {result} but expected True.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_204", "db_id": "california_schools", "query": "Consider the following query that calculates the average SAT score for reading, math and writing combined for each school and assigns it to two different columns, 'combined_score' and 'total_score'. However, the user wants to avoid repeating the complex calculation of the combined score in the SELECT clause. Assume the calculation is complex and should not be repeated for performance reasons and the user cannot use a Common Table Expression (CTE) for this task.", "issue_sql": ["SELECT (avgscrread + avgscrmath + avgscrwrite) AS combined_score, (avgscrread + avgscrmath + avgscrwrite) AS total_score FROM satscores;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT\n    x.curriculum_id,\n    COUNT(DISTINCT x.elem) AS distinct_count\nFROM\n(\n\nSELECT\n        c.curriculum_id,\n        unnest(ARRAY[e.\"Content_Type\", e.\"Platform_Used\"]::text[]) AS elem\n    FROM curriculum_resources cr\n    JOIN educational_resources e\n      ON cr.resource_key = e.resource_key\n    JOIN curricula c\n      ON c.curriculum_id = cr.curriculum_id\n\n    UNION\n\n\nSELECT\n        c2.curriculum_id,\n        unnest(ARRAY[cr2.recommended::text]) AS elem\n    FROM curriculum_resources cr2\n    JOIN curricula c2\n      ON c2.curriculum_id = cr2.curriculum_id\n) AS x\nGROUP BY x.curriculum_id;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_205", "db_id": "formula_1", "query": "In the context of the Formula 1 database, we have a scenario where we need to compare the concatenated and sorted names of circuits for each race. Specifically, we want to concatenate the names of circuits associated with each race, sort these concatenated strings, and then compare them to see if they are the same when sorted. This comparison will help us identify any discrepancies in the naming conventions or associations between races and their respective circuits name.", "issue_sql": ["select (coalesce(circui_name_A1, '') || ' ' || coalesce(circui_name_A2,'') || ' ' || coalesce(circui_name_A3, '')) as A, (coalesce(circui_name_B1, '') || ' ' || coalesce(circui_name_B2,'') || ' ' || coalesce(circui_name_B3, '')) as B from race_info;"], "preprocess_sql": ["CREATE TABLE race_info (id integer, circui_name_A1 text, circui_name_A2 text, circui_name_A3 text, circui_name_B1 text, circui_name_B2 text, circui_name_B3 text, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_verified BOOLEAN DEFAULT false, verification_date DATE, data_source VARCHAR(100) DEFAULT 'manual_entry', metadata JSONB DEFAULT '{}'::jsonb, version_number INTEGER DEFAULT 1, record_status VARCHAR(50) DEFAULT 'active', last_modified_by VARCHAR(100), popularity_score NUMERIC(5,2) DEFAULT 0.0, is_featured BOOLEAN DEFAULT false, notes TEXT, race_year INTEGER, circuit_country VARCHAR(100), weather_conditions VARCHAR(50), track_temperature NUMERIC(4,1), air_humidity NUMERIC(5,2) DEFAULT 50.0, uuid UUID DEFAULT gen_random_uuid())", "insert into race_info (id, circui_name_A1, circui_name_A2, circui_name_A3, circui_name_B1, circui_name_B2, circui_name_B3, created_at, updated_at, is_verified, verification_date, data_source, metadata, version_number, record_status, last_modified_by, popularity_score, is_featured, notes, race_year, circuit_country, weather_conditions, track_temperature, air_humidity, uuid) values (1, 'Istanbul Park', 'Circuit de Monaco', 'Circuit Gilles Villeneuve', 'Circuit Gilles Villeneuve', 'Istanbul Park', 'Circuit de Monaco', '2023-01-15 10:30:00+00', '2023-01-15 10:30:00+00', true, '2023-01-16', 'official_f1_data', '{\"source_reliability\": \"high\", \"import_batch\": \"2023-Q1\"}'::jsonb, 1, 'active', 'admin_user', 8.5, true, 'Triple circuit comparison for race analysis', 2022, 'Multiple', 'Mixed', 28.5, 65.3, 'a1b2c3d4-e5f6-47a7-b8c9-d0e1f2a3b4c5'), (2, 'Istanbul Park', NULL, 'Circuit Gilles Villeneuve', 'Circuit Gilles Villeneuve', 'Istanbul Park', NULL, '2023-01-15 11:45:00+00', '2023-01-16 09:15:00+00', false, NULL, 'third_party', '{\"source_reliability\": \"medium\", \"import_batch\": \"2023-Q1\"}'::jsonb, 2, 'pending_review', 'data_analyst', 6.2, false, 'Partial circuit comparison with missing data', 2021, 'Turkey/Canada', 'Sunny', 32.1, 48.7, '5f6e7d8c-9b0a-41c2-83d4-e5f6a7b8c9d0')"], "clean_up_sql": ["drop table race_info;"], "category": "Query", "efficiency": false, "sol_sql": ["BEGIN;\n\n\n\nDO $$\nBEGIN\n    -- Check if \"status\" column exists in \"curricula\".\n    IF NOT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_name = 'curricula'\n          AND column_name = 'status'\n    ) THEN\n        EXECUTE 'ALTER TABLE curricula ADD COLUMN status TEXT NOT NULL DEFAULT ''installed''';\n    END IF;\n\n    -- Check if \"status\" column exists in \"educational_resources\".\n    IF NOT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_name = 'educational_resources'\n          AND column_name = 'status'\n    ) THEN\n        EXECUTE 'ALTER TABLE educational_resources ADD COLUMN status TEXT NOT NULL DEFAULT ''installed''';\n    END IF;\nEND$$;\n\n\n\nWITH RECURSIVE connected_curricula AS (\n\nSELECT c.curriculum_id\n    FROM curricula c\n    WHERE c.curriculum_id = 1\nAND c.status = 'installed'\nUNION\nSELECT cr2.curriculum_id\n    FROM connected_curricula cte\n    JOIN curriculum_resources cr1\n         ON cr1.curriculum_id = cte.curriculum_id\n    JOIN curriculum_resources cr2\n         ON cr2.resource_key = cr1.resource_key\n    WHERE cr2.curriculum_id <> cte.curriculum_id\n),\nupdated_curricula AS (\n    UPDATE curricula\n    SET status = 'to upgrade'\n    WHERE curriculum_id IN (SELECT curriculum_id FROM connected_curricula)\n    RETURNING curriculum_id\n),\nupdated_resources AS (\n    UPDATE educational_resources er\n    SET status = 'to upgrade'\n    WHERE er.resource_key IN (\n      SELECT cr.resource_key\n      FROM curriculum_resources cr\n      JOIN connected_curricula cc\n        ON cr.curriculum_id = cc.curriculum_id\n    )\n    RETURNING resource_key\n)\n\n\nSELECT\n    (SELECT COUNT(*) FROM updated_curricula) AS curricula_updated,\n    (SELECT COUNT(*) FROM updated_resources) AS resources_updated;\n\nCOMMIT;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n       \n                                        \n                                                                                                \n                                \n                                                                            \n                                                   \n       \n\n                                                                     \n    execute_queries(pred_sqls, db_name, conn)\n\n                                                                       \n                                                                                                \n                                                                                                       \n    result = execute_queries(\n        [\"SELECT COUNT(*) FROM curricula WHERE status = 'to upgrade'\"],\n        db_name,\n        conn\n    )\n    count_updated = result[0][0][0] if result else 0\n\n                                                            \n    if count_updated < 1:\n        raise AssertionError(\n            \"No rows were updated to 'to upgrade'. Your pred_sqls did not achieve the expected result.\"\n        )\n    else:\n        return 1"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_206", "db_id": "card_games", "query": "We have a table that records the prices of various Magic: The Gathering cards over time. Each record includes a timestamp, the card's unique identifier, and its price at that time. We want to calculate the average difference in price for each card between the first and the last available price within the first 15 minutes of each trading day. If the exact 15-minute mark is not available, we should use the last available price before 15 minutes. For example, if the price at 9:14 AM is the last available price before 9:15 AM, we should use that price. The goal is to find the average difference in price for each card over all trading days.The expected result is like | card_id | avg_difference |", "issue_sql": ["WITH s as ( SELECT DATE(date_value) as dt, date_value, card_id cid, price FROM card_prices ) SELECT cid, dt, date_value, s.price as second_price FROM s INNER JOIN ( SELECT q.card_id, DATE(q.date_value) as dat FROM card_prices q GROUP BY q.card_id, dat ORDER BY q.card_id ASC ) as end_price ON s.cid = end_price.card_id AND s.date_value = (SELECT date_value FROM s WHERE s.cid = end_price.card_id AND s.dt = end_price.dat LIMIT 1) + interval '15 minutes' ORDER BY cid, dt;"], "preprocess_sql": ["CREATE TABLE card_prices ( id SERIAL PRIMARY KEY, card_id BIGINT NOT NULL, date_value TIMESTAMP NOT NULL, price NUMERIC(10, 2) NOT NULL, source_platform VARCHAR(50) DEFAULT 'default_platform', currency_code CHAR(3) DEFAULT 'USD', is_verified BOOLEAN DEFAULT false, price_trend NUMERIC(5, 2) DEFAULT 0.00, last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, created_by VARCHAR(100) DEFAULT 'system', market_condition VARCHAR(20) DEFAULT 'normal', price_notes TEXT DEFAULT NULL, metadata JSONB DEFAULT '{}'::jsonb, version_number INTEGER DEFAULT 1, is_promotional BOOLEAN DEFAULT false, region_code VARCHAR(10) DEFAULT 'US', price_variance NUMERIC(8, 4) DEFAULT 0.0000, tracking_id UUID DEFAULT gen_random_uuid(), is_archived BOOLEAN DEFAULT false, data_quality_score INTEGER DEFAULT 5 CHECK (data_quality_score BETWEEN 1 AND 10) );", "INSERT INTO card_prices (card_id, date_value, price, source_platform, currency_code, is_verified, price_trend, last_updated, created_by, market_condition, price_notes, metadata, version_number, is_promotional, region_code, price_variance, tracking_id, is_archived, data_quality_score) VALUES (1, '2023-01-12 09:31:00', 10.00, 'TCGPlayer', 'USD', true, 1.25, '2023-01-12 10:00:00', 'data_import_job', 'stable', 'Initial morning price', '{\"source_url\": \"https://tcgplayer.com/card/1\", \"confidence\": 0.95}'::jsonb, 1, false, 'US', 0.0500, 'a1b2c3d4-e5f6-4a5b-8c9d-1e2f3a4b5c6d', false, 8), (1, '2023-01-12 09:46:00', 12.00, 'TCGPlayer', 'USD', true, 1.50, '2023-01-12 10:15:00', 'data_import_job', 'rising', 'Price increase observed', '{\"source_url\": \"https://tcgplayer.com/card/1\", \"confidence\": 0.92}'::jsonb, 2, false, 'US', 0.1200, '7d8e9f0a-1b2c-3d4e-5f6a-7b8c9d0e1f2a', false, 7), (1, '2023-02-12 09:31:00', 14.00, 'CardKingdom', 'USD', true, 0.75, '2023-02-12 10:00:00', 'data_import_job', 'volatile', 'Monthly comparison price', '{\"source_url\": \"https://cardkingdom.com/card/1\", \"confidence\": 0.98}'::jsonb, 1, false, 'US', 0.0800, 'b2c3d4e5-f6a7-8b9c-0d1e-2f3a4b5c6d7e', false, 9), (1, '2023-02-12 09:46:00', 20.00, 'CardKingdom', 'USD', true, 2.25, '2023-02-12 10:15:00', 'data_import_job', 'spiking', 'Significant price increase', '{\"source_url\": \"https://cardkingdom.com/card/1\", \"confidence\": 0.99}'::jsonb, 2, false, 'US', 0.2500, 'c3d4e5f6-a7b8-9c0d-1e2f-3a4b5c6d7e8f', false, 9), (2, '2023-01-12 09:31:00', 14.00, 'TCGPlayer', 'USD', true, -0.50, '2023-01-12 10:00:00', 'data_import_job', 'declining', 'Initial price for card 2', '{\"source_url\": \"https://tcgplayer.com/card/2\", \"confidence\": 0.90}'::jsonb, 1, false, 'US', 0.0300, 'd4e5f6a7-b8c9-0d1e-2f3a-4b5c6d7e8f9a', false, 7), (2, '2023-01-12 09:46:00', 16.00, 'TCGPlayer', 'USD', true, 1.00, '2023-01-12 10:15:00', 'data_import_job', 'recovering', 'Price recovery noted', '{\"source_url\": \"https://tcgplayer.com/card/2\", \"confidence\": 0.91}'::jsonb, 2, false, 'US', 0.0700, 'e5f6a7b8-c9d0-1e2f-3a4b-5c6d7e8f9a0b', false, 8), (2, '2023-02-12 09:31:00', 2.00, 'CardKingdom', 'USD', false, -5.00, '2023-02-12 10:00:00', 'data_import_job', 'crashing', 'Possible data error', '{\"source_url\": \"https://cardkingdom.com/card/2\", \"confidence\": 0.65}'::jsonb, 1, false, 'US', 0.8500, 'f6a7b8c9-d0e1-2f3a-4b5c-6d7e8f9a0b1c', false, 4), (2, '2023-02-12 09:46:00', 16.00, 'CardKingdom', 'USD', true, 4.50, '2023-02-12 10:15:00', 'data_import_job', 'rebounding', 'Price correction after error', '{\"source_url\": \"https://cardkingdom.com/card/2\", \"confidence\": 0.97}'::jsonb, 2, false, 'US', 0.1800, 'a7b8c9d0-e1f2-3a4b-5c6d-7e8f9a0b1c2d', false, 8);"], "clean_up_sql": ["DROP TABLE card_prices;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH working_hours AS (\n    SELECT\n        ru.learner_code,\n        ru.resource_key,\n        ru.start_timestamp,\n        ru.end_timestamp,\n        CASE\n            WHEN date_part('isodow', ru.start_timestamp) IN (1, 2, 3, 4, 5) THEN ru.start_timestamp + INTERVAL '9 hours'\n            ELSE NULL\n        END AS working_start,\n        CASE\n            WHEN date_part('isodow', ru.end_timestamp) IN (1, 2, 3, 4, 5) THEN ru.end_timestamp + INTERVAL '18 hours'\n            ELSE NULL\n        END AS working_end\n    FROM event_usage ru\n)\nSELECT\n    working_hours.learner_code,\n    working_hours.resource_key,\n    SUM(EXTRACT(EPOCH FROM (ru.end_timestamp - ru.start_timestamp))) AS total_time_spent_in_working_hours\nFROM working_hours\nJOIN event_usage ru\n    ON ru.learner_code = working_hours.learner_code\n    AND ru.resource_key = working_hours.resource_key\n    AND ru.start_timestamp = working_hours.start_timestamp\n    AND ru.end_timestamp = working_hours.end_timestamp\nWHERE\n    (ru.start_timestamp + INTERVAL '9 hours') < working_hours.working_end\n    AND (ru.end_timestamp + INTERVAL '18 hours') > working_hours.working_start\nGROUP BY working_hours.learner_code, working_hours.resource_key;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_207", "db_id": "toxicology", "query": "In the toxicology database, we have a requirement to analyze the sequence of bonds in molecules. Specifically, we need to generate a report that shows each bond along with the subsequent bond in the sequence, along with the bond type. The goal is to understand the connectivity pattern of atoms within a molecule. For example, if we have bonds labeled as 'TR000_1_2', 'TR000_2_3', 'TR000_2_4', we want to produce a report that shows 'TR000_1_2' followed by 'TR000_2_3', 'TR000_2_3' followed by 'TR000_2_4', and so on. The user attempted to write a query to achieve this but encountered issues with the SQL syntax and logic.", "issue_sql": ["SELECT b.bond_id as current_bond, b2.bond_id as next_bond, b.bond_type as bond_type FROM bond b INNER JOIN bond b2 ON b.molecule_id = b2.molecule_id WHERE b.bond_id < b2.bond_id ORDER BY b.bond_id"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT\n  last_value(rating) OVER (\n    PARTITION BY learner_code, resource_key\n    ORDER BY usage_date\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS filled_rating,\n  learner_code,\n  resource_key\nFROM\n  resource_usage_2\nORDER BY\n  learner_code, usage_date;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_208", "db_id": "toxicology", "query": "A researcher wants to analyze the average bond strength of a specific molecule over the last hour. If the current time is 2:30 PM, the query should return the bond strengths from 1:00 PM to 2:00 PM and the average bond strength for that hour. The bond strengths are recorded in a table named 'bond_strength' with columns 'timestamp' and 'strength'. The 'timestamp' column records when the bond strength was measured, and the 'strength' column records the bond strength value.", "issue_sql": ["SELECT timestamp, avg(strength) FROM bond_strength WHERE timestamp >= ('2023-10-01 02:30:00'::timestamp - INTERVAL '1 hour') GROUP BY timestamp, strength"], "preprocess_sql": ["CREATE TABLE bond_strength (timestamp timestamp NOT NULL, strength numeric NOT NULL);", "INSERT INTO bond_strength (timestamp, strength) VALUES ('2023-10-01 01:01:00', 1.2), ('2023-10-01 01:02:00', 1.3), ('2023-10-01 01:03:00', 1.4), ('2023-10-01 01:04:00', 1.1), ('2023-10-01 01:05:00', 1.2), ('2023-10-01 01:07:00', 1.2), ('2023-10-01 01:08:00', 1.5), ('2023-10-01 01:09:00', 1.7), ('2023-10-01 01:10:00', 1.6), ('2023-10-01 01:11:00', 1.5), ('2023-10-01 01:12:00', 1.4), ('2023-10-01 01:13:00', 1.8), ('2023-10-01 01:14:00', 1.8), ('2023-10-01 01:15:00', 1.8), ('2023-10-01 01:16:00', 2.1), ('2023-10-01 01:17:00', 2.9), ('2023-10-01 01:21:00', 1.8), ('2023-10-01 01:22:00', 1.9), ('2023-10-01 01:23:00', 1.8), ('2023-10-01 01:24:00', 1.5), ('2023-10-01 01:25:00', 1.6), ('2023-10-01 01:26:00', 1.6), ('2023-10-01 01:27:00', 1.5), ('2023-10-01 01:28:00', 1.5), ('2023-10-01 01:29:00', 1.5), ('2023-10-01 01:30:00', 1.3), ('2023-10-01 01:31:00', 1.3), ('2023-10-01 01:32:00', 1.4), ('2023-10-01 01:33:00', 1.7), ('2023-10-01 01:34:00', 1.8), ('2023-10-01 01:35:00', 1.7), ('2023-10-01 01:36:00', 1.5), ('2023-10-01 01:37:00', 1.6), ('2023-10-01 01:38:00', 1.3), ('2023-10-01 01:39:00', 1.4), ('2023-10-01 01:43:00', 1.7), ('2023-10-01 01:44:00', 1.3), ('2023-10-01 01:45:00', 1.4), ('2023-10-01 01:46:00', 1.4), ('2023-10-01 01:47:00', 1.1), ('2023-10-01 01:48:00', 1.3), ('2023-10-01 01:49:00', 1.2), ('2023-10-01 01:50:00', 1.4), ('2023-10-01 01:51:00', 1.3), ('2023-10-01 01:52:00', 1.5), ('2023-10-01 01:53:00', 1.5), ('2023-10-01 01:57:00', 1.4), ('2023-10-01 01:58:00', 1.2), ('2023-10-01 01:59:00', 1.4), ('2023-10-01 02:00:00', 1.3)"], "clean_up_sql": ["DROP TABLE bond_strength"], "category": "Query", "efficiency": false, "sol_sql": ["select d::date, extract(epoch from ((case when T.incident_end::date = d::date then T.incident_end else d::date + interval '1 day' end)))/60 from race_incidents T cross join generate_series(T.incident_start, T.incident_end, interval '1 day') d;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_209", "db_id": "card_games", "query": "We have a table named `cards` that contains a `jsonb` type column named `purchaseurls` which holds an array of URLs. Each URL is associated with a specific platform where the card can be purchased. We need to specifically hash/anonymize the URLs (using md5) within that array that follow certain requirements. Using the dummy data below, we're having a hard time trying to target the `purchaseurls` array specifically for any URLs not with a `tcgplayer` domain or `cardKingdom` domain. Ideally, the end result should be that URLs not matching these domains are hashed, while URLs matching these domains remain unchanged. The hash used is md5", "issue_sql": ["select jsonb_set(t.data, '{purchaseurls}',  (select jsonb_agg(case when v.value::text ~ 'tcgplayer' or v.value::text ~ 'cardKingdom' then md5(substring(v.value::text)), jsonb_array_elements(t.data -> 'purchaseurls') v))  from cards_info"], "preprocess_sql": ["CREATE TABLE cards_info (id bigint PRIMARY KEY, data jsonb, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, version_number INTEGER DEFAULT 1, is_active BOOLEAN DEFAULT TRUE, last_accessed_at TIMESTAMP WITH TIME ZONE, access_count BIGINT DEFAULT 0, metadata JSONB DEFAULT '{}'::jsonb, source_system VARCHAR(100) DEFAULT 'internal', data_quality_score NUMERIC(5,2) DEFAULT 0.0, processing_status VARCHAR(50) DEFAULT 'pending', external_reference_id UUID DEFAULT gen_random_uuid(), tags TEXT[] DEFAULT ARRAY[]::TEXT[], notes TEXT, archived_at TIMESTAMP WITH TIME ZONE);", "INSERT INTO cards_info (id, data, created_at, updated_at, version_number, is_active, last_accessed_at, access_count, metadata, source_system, data_quality_score, processing_status, external_reference_id, tags, notes, archived_at) VALUES (1, '{\"purchaseurls\": [\"https://mtg.com/links/9fb51af0ad6f0736\", \"https://mtg.com/links/ace8861194ee0b6a\", \"https://tcgplayer.com/product/4843cea124a0d515\"]}', '2023-01-15T10:30:00Z', '2023-01-15T10:30:00Z', 1, TRUE, '2023-02-01T14:22:15Z', 42, '{\"origin\": \"api\", \"batch_id\": \"2023-Q1-001\"}'::jsonb, 'mtg_database', 87.5, 'processed', 'a1b2c3d4-e5f6-4a5b-9c8d-7e6f5a4b3c2d', ARRAY['popular', 'verified']::TEXT[], 'Standard card with multiple purchase options', NULL), (2, '{\"purchaseurls\": [\"https://cardKingdom.com/item/027095d094e58f5b\", \"https://mtg.com/links/f6fb5098e1cd1b1e\", \"https://mtg.com/links/56c4b57293f350ef\"]}', '2023-01-16T11:45:00Z', '2023-01-18T09:12:30Z', 2, TRUE, '2023-02-05T08:17:22Z', 28, '{\"origin\": \"manual\", \"batch_id\": \"2023-Q1-002\"}'::jsonb, 'card_kingdom', 92.3, 'verified', 'b2c3d4e5-f6a7-5b6c-0d1e-2f3a4b5c6d7e', ARRAY['rare', 'foil']::TEXT[], 'Premium card with CardKingdom listing', NULL), (3, '{\"purchaseurls\": [\"https://mtg.com/links/9246105d88032a9f\", \"https://mtg.com/links/dcdfe48e6a8f9e1e\", \"https://mtg.com/links/3ce595aabe276f80\"]}', '2023-01-17T14:20:00Z', '2023-01-17T14:20:00Z', 1, FALSE, '2023-01-30T16:45:10Z', 7, '{\"origin\": \"import\", \"batch_id\": \"2023-Q1-003\"}'::jsonb, 'legacy_system', 65.8, 'flagged', 'c3d4e5f6-a7b8-6c7d-1e2f-3a4b5c6d7e8f', ARRAY['common', 'standard']::TEXT[], 'Basic card with standard links', '2023-02-10T00:00:00Z')"], "clean_up_sql": ["DROP TABLE cards"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT p.id AS PatientID, MAX(CASE WHEN l.rn = 1 THEN l.ldh     END) AS PatientLDH1, MAX(CASE WHEN l.rn = 1 THEN l.alp END) AS PatientALP1, MAX(CASE WHEN l.rn = 2 THEN l.ldh END) AS PatientLDH2, MAX(CASE WHEN l.rn = 2 THEN l.alp END) AS PatientALP2,  MAX(CASE WHEN l.rn = 3 THEN l.ldh END) AS PatientLDH3, MAX(CASE WHEN l.rn = 3 THEN l.alp END) AS PatientALP3 FROM  patient p LEFT JOIN  (SELECT *, ROW_NUMBER() OVER(PARTITION BY id ORDER BY date) AS rn FROM laboratory) l ON p.id = l.id GROUP BY PatientID ORDER BY PatientID"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_210", "db_id": "erolp", "query": "In the erolp database, we have a table named sales_data that records daily sales figures for various products. Each product can have sales data for all days of the year. For a specific range of dates (e.g., between 123 and 567), we need to calculate the trend in sales for each product by subtracting the sales value at the start date from the sales value at the end date. If a product does not have sales data for either the start or end date, it should be excluded from the results. The user attempted to write a query to achieve this but encountered issues.", "issue_sql": ["WITH RNG AS(SELECT date_num, product_id, sales_value FROM sales_data WHERE (date_num = 123 OR date_num=567) ORDER BY date_num) SELECT date_num, product_id, sales_value, SUM(sales_value) AS trend FROM RNG group by date_num, product_id, sales_value"], "preprocess_sql": ["CREATE TABLE sales_data (product_id VARCHAR(10), date_num INT, sales_value INT, product_category VARCHAR(50) DEFAULT 'Uncategorized', product_subcategory VARCHAR(50) DEFAULT 'General', region VARCHAR(100) DEFAULT 'Global', store_id UUID DEFAULT gen_random_uuid(), transaction_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_promotional BOOLEAN DEFAULT false, discount_percentage NUMERIC(5,2) DEFAULT 0.00, unit_cost NUMERIC(10,2) DEFAULT 0.00, profit_margin NUMERIC(5,2) DEFAULT 0.00, inventory_before INT DEFAULT 100, inventory_after INT DEFAULT 100, customer_segment VARCHAR(50) DEFAULT 'Regular', payment_method VARCHAR(30) DEFAULT 'Cash', sales_channel VARCHAR(30) DEFAULT 'In-store', campaign_id VARCHAR(50) DEFAULT NULL, metadata JSONB DEFAULT '{}'::jsonb, last_updated_by VARCHAR(100) DEFAULT 'system', last_updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);", "INSERT INTO sales_data (product_id, date_num, sales_value, product_category, product_subcategory, region, store_id, transaction_timestamp, is_promotional, discount_percentage, unit_cost, profit_margin, inventory_before, inventory_after, customer_segment, payment_method, sales_channel, campaign_id, metadata, last_updated_by, last_updated_at) VALUES ('A', 123, 5, 'Electronics', 'Smartphones', 'North America', '123e4567-e89b-12d3-a456-426614174000', '2023-01-03 08:30:00', true, 10.00, 300.00, 25.50, 120, 115, 'Premium', 'Credit Card', 'Online', 'SPRING2023', '{\"color\": \"black\", \"warranty\": \"2 years\"}'::jsonb, 'data_import', '2023-01-03 09:00:00'), ('B', 123, 3, 'Home Goods', 'Kitchen', 'Europe', '223e4567-e89b-12d3-a456-426614174001', '2023-01-03 09:15:00', false, 0.00, 150.00, 30.00, 85, 82, 'Regular', 'Debit Card', 'In-store', NULL, '{\"material\": \"stainless steel\"}'::jsonb, 'data_import', '2023-01-03 09:30:00'), ('C', 123, 1, 'Clothing', 'Accessories', 'Asia', '323e4567-e89b-12d3-a456-426614174002', '2023-01-03 10:00:00', false, 5.00, 25.00, 40.00, 200, 199, 'Budget', 'Mobile Payment', 'Online', NULL, '{\"size\": \"one-size\", \"color\": \"blue\"}'::jsonb, 'data_import', '2023-01-03 10:15:00'), ('A', 567, 9, 'Electronics', 'Smartphones', 'North America', '423e4567-e89b-12d3-a456-426614174003', '2023-02-16 14:20:00', true, 15.00, 290.00, 28.00, 95, 86, 'Premium', 'Credit Card', 'Online', 'WINTER2023', '{\"color\": \"silver\", \"warranty\": \"2 years\"}'::jsonb, 'data_import', '2023-02-16 15:00:00'), ('B', 567, 8, 'Home Goods', 'Kitchen', 'Europe', '523e4567-e89b-12d3-a456-426614174004', '2023-02-16 15:30:00', true, 20.00, 145.00, 32.00, 60, 52, 'Regular', 'Credit Card', 'In-store', 'WINTER2023', '{\"material\": \"ceramic\"}'::jsonb, 'data_import', '2023-02-16 16:00:00'), ('C', 567, 3, 'Clothing', 'Accessories', 'Asia', '623e4567-e89b-12d3-a456-426614174005', '2023-02-16 16:45:00', true, 25.00, 22.00, 45.00, 150, 147, 'Budget', 'Mobile Payment', 'Online', 'WINTER2023', '{\"size\": \"one-size\", \"color\": \"red\"}'::jsonb, 'data_import', '2023-02-16 17:00:00');"], "clean_up_sql": ["DROP TABLE IF EXISTS sales_data;"], "category": "Query", "efficiency": false, "sol_sql": ["select driverid, time, rank, (CASE WHEN prno=1 THEN points::varchar ELSE '' END )AS points from(select DISTINCT driverid, time, rank, points, prno from (select driverid, 1, null, null, null, points::varchar, 1 as prno from results union all select driverid, 2, driverid::varchar, time, rank, points::varchar, 2 as prno from results) temp1 (xid, xord, driverid, time, rank,points,prno) order by points, prno) as temp2;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_211", "db_id": "superhero", "query": "A superhero database administrator wants to insert a new superhero into the 'superhero' table and immediately see the inserted data along with the existing superheroes in the same query. The administrator attempts to use a function to insert the data and then perform a cross-join with the 'superhero' table to see the results, but the inserted data does not appear in the result set.", "issue_sql": ["DROP TABLE IF EXISTS temp_superhero;", "CREATE TABLE temp_superhero (id int);", "CREATE OR REPLACE FUNCTION insert_and_return(int) RETURNS int AS $$ BEGIN INSERT INTO temp_superhero VALUES ($1); RETURN $1; END; $$ LANGUAGE plpgsql;", "SELECT * FROM insert_and_return(10), temp_superhero AS y;"], "preprocess_sql": ["DROP TABLE IF EXISTS temp_superhero;", "CREATE TABLE temp_superhero (id int, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, is_active BOOLEAN DEFAULT TRUE, status VARCHAR(50) DEFAULT 'pending', version_number INTEGER DEFAULT 1, metadata JSONB DEFAULT '{}'::jsonb, notes TEXT DEFAULT NULL, created_by VARCHAR(100) DEFAULT 'system', last_accessed_at TIMESTAMP WITH TIME ZONE DEFAULT NULL, access_count INTEGER DEFAULT 0, uuid UUID DEFAULT gen_random_uuid(), source_system VARCHAR(50) DEFAULT 'manual', batch_id VARCHAR(100) DEFAULT NULL, priority INTEGER DEFAULT 5, tags TEXT[] DEFAULT '{}'::TEXT[])"], "clean_up_sql": ["DROP TABLE IF EXISTS temp_superhero;"], "category": "Query", "efficiency": false, "sol_sql": ["select * from results r inner join drivers d on r.driverid = d.driverid where r.grid = 21 order by r.points desc limit 10;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_212", "db_id": "toxicology", "query": "We need to display the count of molecules that do not have a specific bond type (example: '-') in a Grafana dashboard with Postgres as the data source. For instance, if we have 10,000 molecules and in 400 molecules the bond type '-' is not present, then Grafana should display the count of molecules where no version of bond type '-' is present. The user attempted to write a query but did not get the expected output.", "issue_sql": ["SELECT count(*) FROM (SELECT DISTINCT molecule_id FROM bond GROUP BY molecule_id HAVING COUNT(CASE WHEN bond_type = '-' THEN 1 END) = 0) AS molecule_without_bond_type;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["INSERT INTO customer_orders(name, title) SELECT COALESCE(uo.name, co.name), COALESCE(uo.title, co.title) FROM customer_orders co LEFT OUTER JOIN updated_orders uo ON uo.id = co.id UNION ALL SELECT COALESCE(co.name, uo.name), COALESCE(uo.title, co.title) FROM customer_orders co LEFT OUTER JOIN updated_orders uo ON uo.id = co.id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM customer_orders WHERE id = 2;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'new_test', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_1 = execute_queries([\"SELECT name FROM customer_orders WHERE id=3;\"], db_name,conn)[0]\n    assert test_pred_query_result_1[0][0] == 'test', f'Expected name to match, but found {test_pred_query_result_1[0][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_213", "db_id": "card_games", "query": "I am working on setting up a vector store in my PostgreSQL database to manage card game strategies. For each new strategy table I create the table, and defines a function to search for strategies based on vector similarity. The script always creates a table named 'strategies'. I want to create a function that takes the table name as an input and executes the script, allowing me to create tables with different names dynamically. This function will be called using remote RPC calls from my Python SDK. Here is the function I wrote to achieve this:", "issue_sql": ["create or replace function setup_vector_store(table_name text) returns void language plpgsql as $$ begin execute 'drop function if exists match_strategies(int, jsonb)'; execute format('create table %I ( id bigint primary key generated always as identity, description text, metadata jsonb )', table_name); execute format('create function match_strategies ( match_count int default null, filter jsonb default \"{}\"::jsonb ) returns table ( id bigint, description text, metadata jsonb, similarity float ) language plpgsql as $$ begin return query select id, description, metadata, 1 as similarity from %I where metadata @> filter order by ''%I''.embedding <=> query_embedding limit match_count; end;$$;', table_name, table_name, table_name); end; $$;"], "preprocess_sql": [], "clean_up_sql": ["DROP IF EXISTS FUNCTION "], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM crosstab('SELECT superhero_name || ''-'' || performance_date AS category, attribute_name, MAX(result) FROM superhero_performance GROUP BY superhero_name, performance_date, attribute_name ORDER BY superhero_name, performance_date', 'SELECT DISTINCT attribute_name FROM superhero_performance ORDER BY attribute_name') AS ct(heroName_date TEXT, Intelligence text, Speed text, Strength text);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_214", "db_id": "erolp", "query": "In the context of our sales analytics database, we need to generate a report that aggregates sales data across different dimensions: time, space, and product attributes. Specifically, we want to calculate the total sales for each combination of year, country, product type, language, and genre. The product attributes (type, language, genre) are stored in a many-to-many relationship with the sales data. We need to ensure that the result set includes all possible combinations of these dimensions, even if there are no sales for a particular combination. Additionally, each product attribute should have its own column in the result set.", "issue_sql": ["WITH variables_array AS (SELECT datapoint_id, ARRAY_AGG(variablevalue_id) AS varvalues FROM datapoint_variablevalue GROUP BY datapoint_id) SELECT COALESCE(SUM(dp.value),0), sd.name AS sp_name, v.varvalues AS varvalues, td.years AS years FROM variables_array v CROSS JOIN spatial_dimension sd CROSS JOIN time_dimension td LEFT JOIN datapoints dp ON dp.id = v.datapoint_id AND dp.spatial_dimension_id = sd.id AND dp.time_dimension_id = td.id GROUP BY years, sp_name, varvalues ORDER BY years DESC"], "preprocess_sql": ["CREATE TABLE time_dimension (id SERIAL PRIMARY KEY, years INT);", "CREATE TABLE spatial_dimension (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL );", "CREATE TABLE variable (id SERIAL PRIMARY KEY,  name VARCHAR(255) NOT NULL );", "CREATE TABLE variablevalue (id SERIAL PRIMARY KEY,  name VARCHAR(255), variable_id INTEGER REFERENCES variable(id));", "CREATE TABLE datapoints (id SERIAL PRIMARY KEY, value INTEGER, time_dimension_id INTEGER REFERENCES time_dimension(id),spatial_dimension_id INTEGER REFERENCES spatial_dimension(id));", "CREATE TABLE datapoint_variablevalue (datapoint_id INTEGER REFERENCES datapoints(id), variablevalue_id INTEGER REFERENCES variablevalue(id), PRIMARY KEY (datapoint_id, variablevalue_id));", "INSERT INTO time_dimension (years) VALUES (2019), (2020);", "INSERT INTO spatial_dimension (name) VALUES ('Belgium'), ('Netherlands');", "INSERT INTO variable (name) VALUES ('ProductType'), ('publishing_language'), ('genre');", "INSERT INTO variablevalue (name, variable_id) VALUES ('hardcover', 1), ('paperback', 1), ('FR', 2), ('NL', 2), ('prose', 3), ('poetry', 3);", "INSERT INTO datapoints (value, time_dimension_id, spatial_dimension_id) VALUES (182, 1, 1), (57, 1, 2), (127, 2, 1), (202, 2, 2);", "INSERT INTO datapoint_variablevalue (datapoint_id, variablevalue_id) VALUES (1, 2), (1, 3), (1, 6), (2, 2), (2, 3), (2, 6), (3, 2), (3, 4), (3, 6), (4, 2), (4, 3), (4, 5);"], "clean_up_sql": ["DROP TABLE time_dimension", "DROP TABLE spatial_dimension", "DROP TABLE variable", "DROP TABLE variablevalue", "DROP TABLE datapoints", "DROP TABLE datapoint_variablevalue"], "category": "Query", "efficiency": false, "sol_sql": ["WITH set_date AS (SELECT MIN(date) AS mindt FROM laboratory), month_days AS (SELECT generate_series(date_trunc('month', mindt::date), date_trunc('month', mindt::date) + INTERVAL '1 month' - INTERVAL '1 day', INTERVAL '1 day') AS dt FROM set_date), admin_weeks AS (SELECT dt, (EXTRACT(DOW FROM dt) = 1 OR dt = date_trunc('month', dt)) AS week_start, SUM((EXTRACT(DOW FROM dt) = 1 OR dt = date_trunc('month', dt))::int) OVER (ORDER BY dt ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS week_number FROM month_days) SELECT * FROM admin_weeks ORDER BY dt;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_215", "db_id": "european_football_2", "query": "In the 'european_football_2' database, I need to find the the top 3 largest tables in terms of storage. The goal is to list the table name and table size for all tables. Initially, I attempted to use a simple count(*) query for each table to compare the siza, but I need a more efficient method to achieve this in a single SQL command, which selects all table names with their sizes.", "issue_sql": ["SELECT count(*) AS exact_count FROM match;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["select '2010-10-31' reporting_date, count(case when OpenDate<'2010-10-31' and ClosedDate>='2010-10-31' then 1 end) from schools;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_216", "db_id": "european_football_2", "query": "In the 'european_football_2' database, I need to find the the top 3 largest tables in terms of storage. The goal is to list the table name and table size for all tables. Initially, I attempted to use a simple count(*) query for each table to compare the siza, but I need a more efficient method to achieve this in a single SQL command, which selects all table names with their sizes.", "issue_sql": ["WITH ranges_with_whole_days AS (SELECT booking_id, stadium_id, start_at, date_trunc('day', start_at) + interval '1 d' as start_at_next_whole_day, date_trunc('day', end_at) as end_at_whole_day, end_at FROM stadium_bookings), ranges AS (SELECT booking_id, stadium_id, start_at, CASE WHEN start_at_next_whole_day <= end_at_whole_day THEN start_at_next_whole_day ELSE NULL END as start_at_next_day, CASE WHEN end_at_whole_day >= start_at_next_whole_day THEN end_at_whole_day ELSE NULL END as end_at_prev_day, end_at FROM ranges_with_whole_days), ranges_bucketed AS (SELECT booking_id, stadium_id, start_at, start_at_next_day as end_at FROM ranges WHERE start_at_next_day IS NOT NULL UNION SELECT booking_id, stadium_id, start_at_next_day as start_at, end_at_prev_day as end_at FROM ranges WHERE start_at_next_day IS NOT NULL AND end_at_prev_day IS NOT NULL AND start_at_next_day != end_at_prev_day UNION SELECT booking_id, stadium_id, end_at_prev_day as start_at, end_at FROM ranges WHERE end_at_prev_day IS NOT NULL UNION SELECT booking_id, stadium_id, start_at, end_at FROM ranges WHERE start_at_next_day IS NULL AND end_at_prev_day IS NULL) SELECT * FROM ranges_bucketed ORDER BY booking_id, stadium_id, start_at;"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS stadium_bookings (\n  booking_id text NOT NULL,\n  stadium_id text NOT NULL,\n  start_at timestamp with time zone NOT NULL,\n  end_at timestamp with time zone NOT NULL,\n  created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,\n  updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,\n  booking_status varchar(50) DEFAULT 'confirmed',\n  booking_type varchar(100) DEFAULT 'standard',\n  customer_id uuid DEFAULT gen_random_uuid(),\n  event_name text DEFAULT 'Unnamed Event',\n  attendees_count integer DEFAULT 0,\n  total_price numeric(12, 2) DEFAULT 0.00,\n  payment_status varchar(50) DEFAULT 'pending',\n  notes text DEFAULT NULL,\n  is_recurring boolean DEFAULT false,\n  recurrence_pattern jsonb DEFAULT '{}'::jsonb,\n  cancellation_policy text DEFAULT 'Standard 48-hour cancellation policy applies',\n  special_requirements text DEFAULT NULL,\n  contact_person varchar(255) DEFAULT NULL,\n  contact_email varchar(255) DEFAULT NULL,\n  contact_phone varchar(50) DEFAULT NULL,\n  internal_reference_code varchar(100) DEFAULT NULL,\n  last_modified_by varchar(100) DEFAULT 'system',\n  version_number integer DEFAULT 1\n);", "INSERT INTO stadium_bookings(booking_id, stadium_id, start_at, end_at, created_at, updated_at, booking_status, booking_type, customer_id, event_name, attendees_count, total_price, payment_status, notes, is_recurring, recurrence_pattern, cancellation_policy, special_requirements, contact_person, contact_email, contact_phone, internal_reference_code, last_modified_by, version_number) VALUES \n('booking1', 'stadium1', '2023-06-01 14:00:00', '2023-06-03 18:00:00', '2023-05-15 09:23:45+08:00', '2023-05-15 09:23:45+08:00', 'confirmed', 'tournament', 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', 'Summer Football Championship', 1500, 5000.00, 'paid', 'Annual football tournament with 16 teams', false, '{\"frequency\": \"annual\", \"day\": \"first Saturday of June\"}'::jsonb, 'No refunds within 14 days of event', 'Extra seating required in north stand', 'John Smith', 'john.smith@example.com', '+1-555-123-4567', 'SFC-2023-06', 'admin', 1),\n('booking2', 'stadium1', '2023-06-04 14:00:00', '2023-06-04 18:00:00', '2023-05-20 14:30:12+08:00', '2023-05-25 11:15:30+08:00', 'confirmed', 'friendly match', 'b2c3d4e5-f6a7-8901-bcde-f23456789012', 'Charity Exhibition Match', 800, 1200.50, 'paid', 'Charity match between local celebrities and retired professionals', false, '{}'::jsonb, 'Standard 48-hour cancellation policy applies', 'VIP area setup required', 'Mary Johnson', 'mary.j@charity.org', '+1-555-987-6543', 'CEM-2023-06', 'booking_manager', 2),\n('booking3', 'stadium1', '2023-06-06 10:30:00', '2023-07-02 16:30:00', '2023-04-10 08:45:22+08:00', '2023-05-30 16:20:18+08:00', 'confirmed', 'training camp', 'c3d4e5f6-a7b8-9012-cdef-345678901234', 'National Team Training Camp', 120, 15000.00, 'partially_paid', 'Extended booking for national team preparation before international tournament', true, '{\"frequency\": \"weekly\", \"days\": [\"Monday\", \"Wednesday\", \"Friday\"]}'::jsonb, 'Cancellation fee of 50% applies to all cancellations', 'Private access only, media area required, enhanced security measures', 'Coach Thompson', 'coach.thompson@nationalteam.org', '+1-555-789-0123', 'NTC-2023-06', 'director', 3);"], "clean_up_sql": ["DROP TABLE IF EXISTS stadium_bookings;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["WITH cte AS (SELECT category, amount, sum(amount)  OVER w AS cum_amount, row_number() OVER w AS count FROM budget WINDOW w AS (PARTITION BY category ORDER BY amount, budget_id)), foo AS (SELECT category, MAX(count) as count, MAX(cum_amount) as cum_amount FROM cte WHERE category = 'Food' AND cum_amount <= 500 GROUP BY category), adv AS (SELECT category, MAX(count) as count, MAX(cum_amount) as cum_amount FROM cte WHERE category = 'Advertisement' AND cum_amount <= (SELECT 500 - cum_amount FROM foo)GROUP BY category)SELECT category, count FROM foo UNION ALL SELECT category, count FROM adv"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result_1) == 2, f'Expected 2 rows, but found {len(pred_query_result_1)} rows'\n    assert pred_query_result_1[0][0] == 'Food', 'The first row category should be Food.'\n    assert pred_query_result_1[1][0] == 'Advertisement', 'The second row category should be Advertisement.'\n    assert pred_query_result_1[0][1] == 9, f'Expected count to be 9, but found {pred_query_result_1[0][1]}'\n    assert pred_query_result_1[1][1] == 1, f'Expected count to be 1, but found {pred_query_result_1[1][1]}'\n\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_217", "db_id": "european_football_2", "query": "In the database 'european_football_2', there is a table that stores match event data for various football matches. Each row in the table represents a specific event during a match, and the 'event_description' column contains a string of event details separated by '#'. For example, an event description might be 'Goal#Player1#10#2023-10-01#StadiumA'. The task is to find the longest common prefix of the 'event_description' values across all rows, considering only entire tokens separated by '#'. The current approach using a custom aggregate function is not yielding the correct result. The expected result should be the longest common prefix of the entire tokens, not partial content within tokens.", "issue_sql": ["CREATE OR REPLACE FUNCTION lcp_iterate(_state TEXT, value TEXT) RETURNS TEXT AS $$ SELECT SUBSTRING($2, 1, s - 1) FROM generate_series(1, LEAST(LENGTH($1), LENGTH($2))) s WHERE SUBSTRING($1, 1, s) <> SUBSTRING($2, 1, s) UNION ALL SELECT LEAST($1, $2) LIMIT 1; $$ LANGUAGE 'sql';DO $$ BEGIN CREATE AGGREGATE lcp(TEXT) (SFUNC = lcp_iterate, STYPE = TEXT); EXCEPTION WHEN sqlstate '42723' THEN null; END $$;", "SELECT lcp(event_description) AS common_prefix FROM match_events;"], "preprocess_sql": ["CREATE TABLE match_events ( id SERIAL PRIMARY KEY, event_description TEXT NOT NULL );", "INSERT INTO match_events (event_description) VALUES ('Goal#Player1#10#2023-10-01#StadiumA'), ('Goal#Player1#15#2023-10-01#StadiumA'), ('Goal#Player1#18#2023-10-01#StadiumA');"], "clean_up_sql": ["DROP TABLE match_events;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH non_1 AS (SELECT * FROM client WHERE district_id <> 1 LIMIT 900), district_1 AS (SELECT * FROM client WHERE district_id = 1 LIMIT 100) SELECT * FROM non_1 UNION ALL SELECT * FROM district_1 LIMIT 1000;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(pred_query_result_1) == 1000, f'Expected 1000 rows, but found {len(pred_query_result_1)} rows'\n    assert sum(1 for row in pred_query_result_1 if row[3] == 1) <= 100, f'Expected maximum 100 district_id=1, but found {sum(1 for row in pred_query_result_1 if row[3]==1)}'\n    test_pred_query_result_1 = execute_queries([\"SELECT COUNT(*) FROM client WHERE district_id <> 1\"], db_name, conn)[0]\n    assert len([row for row in pred_query_result_1 if row[3] != 1]) == min(900, test_pred_query_result_1[0][0]), f'Expected 900 non-1 district_id, but found {len([row for row in pred_query_result_1 if row[3]==1])}'\n    test_pred_query_result_2 = execute_queries([\"SELECT COUNT(*) FROM client WHERE district_id = 1\"], db_name, conn)[0]\n    assert len([row for row in pred_query_result_1 if row[3] == 1]) == min(100, test_pred_query_result_2[0][0]), f'Expected 100 1-district_id, but found {len([row for row in pred_query_result_1 if row[3]]==1)}'\n    assert all(isinstance(row[0], int) and isinstance(row[3], int) for row in pred_query_result_1), 'All rows should have a integer client_id and a integer district_id'\n\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_218", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, we need to identify the player with the highest player ID number whose name starts with 'Ale' and player_fifa_api_id > 220000. The user attempted to use MAX instead of ORDER BY to find this player but encountered issues with their query. Can you modify the error sql to make it work with 'MAX'.", "issue_sql": ["SELECT player_api_id, player_name FROM player WHERE player_name LIKE 'Ale%' AND player_fifa_api_id > 220000 AND id = (SELECT MAX(id) FROM player);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["UPDATE card c SET type = (SELECT type FROM disp d WHERE d.disp_id = c.disp_id ORDER BY client_id LIMIT 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries([\"SELECT type FROM card WHERE card_id = 345;\"], db_name, conn)[0]\n    assert test_pred_query_result_1[0][0] == 'OWNER' or pred_query_result_1[0][0] == 'DISPONENT', f'The updated type of card_id 345 should be OWNER or DISPONENT, but found {test_pred_query_result_1[0][0]}'\n    test_pred_query_result_3 = execute_queries([\"SELECT type FROM card;\"], db_name, conn)[0]\n    assert sum(1 for row in test_pred_query_result_3 if row[0] == \"OWNER\") == 892, f'Expected 892 OWNER, but found {sum(1 for row in test_pred_query_result_3 if row[0] == \"OWNER\")}'\n\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_219", "db_id": "european_football_2", "query": "In the database 'european_football_2', there is a table named 'detail' that stores detailed information about football matches, including a JSONB column 'match_details' which contains various statistics and metadata about each match. One of the fields within this JSONB column is 'player_stats', which is an array of objects containing statistics for each player involved in the match. Each player object includes properties such as 'player_id', 'goals', 'assists', and 'team'. A user wants to query this table to find all matches where a specific player (identified by 'player_id' = 103) has scored at least one goal. The user attempts to use a parameter within a Path expression but encounters issues with binding the parameter correctly.", "issue_sql": ["SELECT match_id, match_date FROM detail WHERE match_details @@ '$.player_stats[*] ? (@.player_id == :player_id).goals > 0';"], "preprocess_sql": ["CREATE TABLE detail (match_id INT PRIMARY KEY, match_date DATE, home_team VARCHAR(255), away_team VARCHAR(255), match_details JSONB, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, match_status VARCHAR(50) DEFAULT 'completed', attendance INTEGER DEFAULT 0, weather_conditions TEXT DEFAULT 'unknown', broadcast_channel VARCHAR(100) DEFAULT 'not specified', match_duration_minutes INTEGER DEFAULT 90, extra_time_minutes INTEGER DEFAULT 0, referee_name VARCHAR(255) DEFAULT 'unassigned', var_decisions JSONB DEFAULT '{}'::jsonb, match_highlights_url TEXT DEFAULT NULL, match_importance_rating NUMERIC(3,1) DEFAULT 5.0, is_derby BOOLEAN DEFAULT FALSE, season_phase VARCHAR(50) DEFAULT 'regular', venue_capacity INTEGER DEFAULT 0)", "INSERT INTO detail (match_id, match_date, home_team, away_team, match_details, created_at, updated_at, match_status, attendance, weather_conditions, broadcast_channel, match_duration_minutes, extra_time_minutes, referee_name, var_decisions, match_highlights_url, match_importance_rating, is_derby, season_phase, venue_capacity) VALUES (1, '2024-01-15', 'Real Madrid', 'Barcelona', '{\"season\": \"2023-2024\", \"stadium\": \"Santiago Bernabeu\", \"player_stats\": [{\"player_id\": 101, \"goals\": 2, \"assists\": 1, \"team\": \"Real Madrid\"}, {\"player_id\": 102, \"goals\": 0, \"assists\": 2, \"team\": \"Barcelona\"}, {\"player_id\": 103, \"goals\": 1, \"assists\": 0, \"team\": \"Real Madrid\"}]}', '2024-01-15 22:45:00+00', '2024-01-16 01:15:00+00', 'completed', 81254, 'clear', 'ESPN', 94, 4, 'Michael Oliver', '{\"decisions\": [{\"time\": 67, \"type\": \"goal_review\", \"outcome\": \"confirmed\"}]}'::jsonb, 'https://highlights.example.com/match1', 9.5, TRUE, 'regular', 81044), (2, '2024-01-22', 'Manchester United', 'Liverpool', '{\"season\": \"2023-2024\", \"stadium\": \"Old Trafford\", \"player_stats\": [{\"player_id\": 201, \"goals\": 0, \"assists\": 1, \"team\": \"Manchester United\"}, {\"player_id\": 202, \"goals\": 1, \"assists\": 0, \"team\": \"Liverpool\"}, {\"player_id\": 203, \"goals\": 0, \"assists\": 0, \"team\": \"Manchester United\"}]}', '2024-01-22 20:30:00+00', '2024-01-22 22:25:00+00', 'completed', 74140, 'rainy', 'Sky Sports', 92, 2, 'Anthony Taylor', '{\"decisions\": [{\"time\": 34, \"type\": \"penalty_review\", \"outcome\": \"overturned\"}]}'::jsonb, 'https://highlights.example.com/match2', 8.7, TRUE, 'regular', 74994), (3, '2024-01-29', 'Bayern Munich', 'Borussia Dortmund', '{\"season\": \"2023-2024\", \"stadium\": \"Allianz Arena\", \"player_stats\": [{\"player_id\": 301, \"goals\": 1, \"assists\": 1, \"team\": \"Bayern Munich\"}, {\"player_id\": 302, \"goals\": 2, \"assists\": 0, \"team\": \"Borussia Dortmund\"}, {\"player_id\": 301, \"goals\": 0, \"assists\": 1, \"team\": \"Bayern Munich\"}]}', '2024-01-29 19:30:00+00', '2024-01-29 21:20:00+00', 'completed', 75000, 'cold', 'DAZN', 90, 0, 'Felix Brych', '{\"decisions\": []}'::jsonb, 'https://highlights.example.com/match3', 9.2, TRUE, 'regular', 75024), (4, '2024-02-05', 'Juventus', 'AC Milan', '{\"season\": \"2023-2024\", \"stadium\": \"Allianz Stadium\", \"player_stats\": [{\"player_id\": 401, \"goals\": 0, \"assists\": 1, \"team\": \"Juventus\"}, {\"player_id\": 103, \"goals\": 1, \"assists\": 0, \"team\": \"Real Madrid\"}]}', '2024-02-05 20:45:00+00', '2024-02-05 22:40:00+00', 'completed', 41000, 'mild', 'Serie A Pass', 93, 3, 'Daniele Orsato', '{\"decisions\": [{\"time\": 78, \"type\": \"red_card_review\", \"outcome\": \"confirmed\"}]}'::jsonb, 'https://highlights.example.com/match4', 7.8, FALSE, 'regular', 41507), (5, '2024-02-12', 'Paris Saint-Germain', 'Olympique Marseille', '{\"season\": \"2023-2024\", \"stadium\": \"Parc des Princes\", \"player_stats\": null}', '2024-02-12 21:00:00+00', '2024-02-12 22:55:00+00', 'postponed', 0, 'stormy', 'Canal+', 0, 0, 'Clement Turpin', '{}'::jsonb, NULL, 8.5, TRUE, 'regular', 47929)"], "clean_up_sql": ["DROP TABLE detail;"], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE TABLE loan (loan_id SERIAL PRIMARY KEY, account_id INT, date DATE, amount INT, duration INT, payment INT, status CHARACTER);CREATE TABLE card (card_id SERIAL PRIMARY KEY, loan_id INT UNIQUE, type TEXT NOT NULL, issued DATE NOT NULL, CONSTRAINT fk_loan_id FOREIGN KEY (loan_id) REFERENCES loan(loan_id) ON DELETE CASCADE);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    set_up_1 = execute_queries([\"INSERT INTO card (card_id, type, issued) VALUES (1, 'gold', '2000-09-03'), (2, 'classic', '1997-09-03'), (3, 'platinum', '1995-09-03') RETURNING *;\"], db_name, conn)[0]\n    set_up_2 = execute_queries([\"INSERT INTO loan (loan_id, account_id, amount, duration, status, payments) VALUES (1, 1, 1000, 12, 'A', 100), (2, 1, 2000, 12, 'A', 200), (3, 1, 3000, 12, 'A', 300) RETURNING *;\"], db_name, conn)[0]\n    test_cases = [\n            {\n                \"query\": \"INSERT INTO card (loan_id, type, issued) VALUES (1, 'GOLD', '2024-01-01')\",\n                \"should_fail\": True,\n                \"error_message\": \"it should fail because the loan_id is already in the card table\"\n            },\n            \n            {\n                \"query\": \"INSERT INTO card (loan_id, type, issued) VALUES (999, 'GOLD', '2024-01-01')\",\n                \"should_fail\": True,\n                \"error_message\": \"it should fail because the loan_id is not in the loan table\"\n            },\n            \n            {\n                \"query\": \"DELETE FROM loan WHERE loan_id = 1\",\n                \"should_fail\": False,\n                \"verification_query\": \"SELECT COUNT(*) FROM card WHERE loan_id = 1\",\n                \"expected_count\": 0,\n                \"error_message\": \"it should be 0 because the loan_id was deleted\"\n            },\n            \n            {\n                \"query\": \"DELETE FROM card WHERE loan_id = 2\",\n                \"should_fail\": False,\n                \"verification_query\": \"SELECT loan_id FROM loan WHERE loan_id = 2\",\n                \"expected_result\": None,\n                \"error_message\": \"it should be none because the card is deleted\"\n            }\n        ]\n    \n    for test_case in test_cases:\n            try:\n                execute_queries([test_case[\"query\"]], db_name, conn)\n                \n                if test_case[\"should_fail\"]:\n                    assert False, f\"{test_case['error_message']}\"\n                \n                if \"verification_query\" in test_case:\n                    result = execute_queries([test_case[\"verification_query\"]], db_name, conn)[0]\n                    \n                if \"expected_count\" in test_case:\n                    assert result[0][0] == test_case[\"expected_count\"], (\n                        f\"{test_case['error_message']}\"\n                    )    \n                    \n                if \"expected_result\" in test_case:\n                    assert result == [], (\n                        f\"{test_case['error_message']}\",\n                        f\"but the result is {result}\"\n                    )\n                \n            except Exception as e:\n                if test_case[\"should_fail\"]:\n                    assert str(e).find(test_case[\"error_message\"]) != -1, (\n                        f\"{test_case['error_message']}\"\n                    )\n                else:\n                    raise\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_220", "db_id": "formula_1", "query": "We have a table in the formula_1 database that contains data detail categorized by country, metric code, and demographic groups (male, female, pensioners, teenagers). The table structure and data are as follows:\\n| country  | metric_code | male        | female      | pensioners  | teenagers   |\\n| -------- | ----------- | ----------- | ----------- | ----------- | ----------- |\\n| us       | metric_1    | 10          | 14          | 22          | 30          |\\n| us       | metric_2    | 105         | 142         | 222         | 309         |\\n| uk       | metric_1    | 15          | 13          | 9           | 21          |\\n| uk       | metric_2    | 212         | 264         | 440         | 165         |\\nWe need to transform this table to have the following structure:\\n| country  | predicate_code | metric_1    | metric_2    |\\n| -------- | -----------    | ----------- | ----------- |\\n| us       | male           | 10          | 105         |\\n| us       | female         | 14          | 142         |\\n| us       | pensioners     | 22          | 222         |\\n| us       | teenagers      | 30          | 309         |\\n| uk       | male           | 15          | 212         |\\n| uk       | female         | 13          | 264         |\\n| uk       | pensioners     | 9           | 440         |\\n| uk       | teenagers      | 21          | 165         |\\nThe user achieved this transformation using the following SQL query. Can you provide other ways that achieves the same goal and also improves query performance?", "issue_sql": ["select country, predicate_code, max(case when metric_code = 'metric_1' then value end) as metric_1, max(case when metric_code = 'metric_2' then value end) as metric_2 from data_detail t cross join lateral (values ('male', male), ('female', female), ('pensioners', pensioners), ('teenagers', teenagers)) as v(predicate_code, value) group by country, predicate_code order by 1, 2;"], "preprocess_sql": ["create table data_detail (country text, metric_code text, male int, female int, pensioners int, teenagers int);", "insert into data_detail(country, metric_code, male, female, pensioners, teenagers) values ('us', 'metric_1', 10, 14, 22, 30), ('us', 'metric_2', 105, 142, 222, 309), ('uk', 'metric_1', 15, 13, 9, 21), ('uk', 'metric_2', 212, 264, 440, 165);"], "clean_up_sql": ["DROP TABLE data_detail;"], "category": "Efficiency", "efficiency": true, "sol_sql": ["DO $do$\nDECLARE\n    var RECORD;\nBEGIN\n    var := ROW(\n        ARRAY[NULL]::transactions_1k[],\n        ARRAY[NULL]::customers[]\n    );\n    SELECT ARRAY(SELECT t FROM transactions_1k t LIMIT 1) INTO var.f1;\n    SELECT ARRAY(SELECT c FROM customers c LIMIT 1) INTO var.f2;\n    RAISE NOTICE 'Transaction: %', var.f1[1];\n    RAISE NOTICE 'Customer: %', var.f2[1];\nEND $do$;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query = \"\"\"\n    DO $do$\n    DECLARE\n        var RECORD;\n    BEGIN \n        var := ROW(\n            ARRAY[NULL]::transactions_1k[],\n            ARRAY[NULL]::customers[]\n        );\n        \n        SELECT ARRAY(SELECT t FROM transactions_1k t LIMIT 1) INTO var.f1;\n        SELECT ARRAY(SELECT c FROM customers c LIMIT 1) INTO var.f2;\n        \n        IF array_length(var.f1, 1) IS NULL THEN\n            RAISE EXCEPTION 'Transactions array is empty';\n        END IF;\n        \n        IF array_length(var.f2, 1) IS NULL THEN\n            RAISE EXCEPTION 'Customers array is empty';\n        END IF;\n        RAISE NOTICE 'Validation passed: Arrays initialized and populated correctly';\n\n        IF var.f1[1].transactionid <> 1 THEN\n            RAISE EXCEPTION 'Transaction information is wrong';\n        END IF;\n\n        IF var.f2[1].customerid <> 3 THEN\n            RAISE EXCEPTION 'Customer information is wrong';\n        END IF;\n    END $do$;\n    \"\"\"\n    try:\n        execute_queries([test_query], db_name, conn)\n        return True\n    except Exception as e:\n        print(f\"Failed test: {str(e)}\")\n        raise\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_221", "db_id": "toxicology", "query": "We need to analyze the 'bond' table in the toxicology database, which contains information about the bonds between atoms in molecules. Each bond has a 'bond_id' and bond_stat_. We want to query the 'bond' table, sum all the bond times (which are stored in a JSONB column named 'bond_stat_' in a hypothetical table 'bond_details'), and then find any bond that has a 'type' of 'Unknown' and a 'time' that is greater than 10% of the previously calculated sum for each molecule. The 'bond_details' table does not exist in the current schema, so we will simulate it by adding a JSONB column to the 'bond' table for this exercise. The user attempted to write a query to achieve this but encountered issues with accessing the nested JSONB fields correctly.", "issue_sql": ["SELECT b.bond_id, jsonb_build_object('time', sum((b.bond_stat_->'time')::numeric)) FROM bond b GROUP BY bond_id;"], "preprocess_sql": ["ALTER TABLE bond ADD COLUMN bond_stat_ JSONB;", "UPDATE bond SET bond_stat_ = '{\"Type A\": {\"time\": 500, \"complete\": 100.0, \"type\": \"Unknown\"}, \"Type B\": {\"time\": 35, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type C\": {\"time\": 50, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_1_2';", "UPDATE bond SET bond_stat_ = '{\"Type A\": {\"time\": 55, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type C\": {\"time\": 20, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_2_3';", "UPDATE bond SET bond_stat_ = '{\"Type C\": {\"time\": 100, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type A\": {\"time\": 55, \"complete\": 100.0, \"type\": \"Unknown\"}, \"Type D\": {\"time\": 70, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_2_4';"], "clean_up_sql": ["ALTER TABLE bond DROP COLUMN bond_stat_;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH upd AS (\n   UPDATE loan l\n   SET  status = 'A',\n        date = '2010-12-23',\n        amount = '10000'\n   WHERE  l.loan_id = 4959\n   AND l.status = 'A'\n   RETURNING 1\n)\nSELECT COALESCE(\n   (SELECT 'UPDATE_APPLIED' FROM upd),\n   (SELECT 'VERSION_CONFLICT' FROM loan WHERE loan_id = 4959),\n   'ENTITY_NOT_FOUND'\n) AS result;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_cases = [\n        {\n            \"loan_id\": 4959,\n            \"current_status\": \"A\",\n            \"expected_result\": \"UPDATE_APPLIED\"\n        },\n        {\n            \"loan_id\": 4961,\n            \"current_status\": \"A\",\n            \"expected_result\": \"VERSION_CONFLICT\"\n        },\n        {\n            \"loan_id\": 9999,\n            \"current_status\": \"A\",\n            \"expected_result\": \"ENTITY_NOT_FOUND\"\n        }\n    ]\n\n    for test_case in test_cases:\n        update_query = f\"\"\"\n        WITH upd AS (\n            UPDATE loan l\n            SET status = 'A',\n                date = '2010-12-23',\n                amount = '10000'\n            WHERE l.loan_id = {test_case['loan_id']}\n            AND l.status = '{test_case['current_status']}'\n            RETURNING 1\n        )\n        SELECT COALESCE(\n            (SELECT 'UPDATE_APPLIED' FROM upd),\n            (SELECT 'VERSION_CONFLICT' FROM loan \n            WHERE loan_id = {test_case['loan_id']}),\n            'ENTITY_NOT_FOUND'\n        ) AS result;\n        \"\"\"\n        result = execute_queries([update_query], db_name, conn)[0]\n        if result is None:\n            assert test_case['loan_id'] == 9999, (\n                f\"Failed test: loan_id={test_case['loan_id']}, \"\n                f\"Expected result = {test_case['expected_result']}, \"\n                f\"But found = None\"\n            )\n        else:\n            assert result[0][0] == test_case['expected_result'], (\n                f\"Failed test: loan_id={test_case['loan_id']}, \"\n                f\"Expected result = {test_case['expected_result']}, \"\n                f\"But found = {result[0][0]}\"\n            )\n        if test_case['expected_result'] == 'UPDATE_APPLIED':\n            verify_query = f\"\"\"\n            SELECT status, date, amount \n            FROM loan \n            WHERE loan_id = {test_case['loan_id']}\n            \"\"\"\n            verify_result = execute_queries([verify_query], db_name, conn)[0]\n            UPDATE_VALUES = {\n                'status': 'A',\n                'date': '2010-12-23',\n                'amount': '10000'\n            }\n            assert verify_result[0][0] == UPDATE_VALUES['status'], \"The status is not updated\"\n            assert str(verify_result[0][1]) == str(UPDATE_VALUES['date']), \"The date is not updated\"\n            assert str(verify_result[0][2]) == UPDATE_VALUES['amount'], \"The amount is not updated\"\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_222", "db_id": "toxicology", "query": "I have a PostgreSQL function that is intended to filter rows from the bond table based on the status of a bond. Specifically, I want to find all bond_ids where the bond_stat_ (a JSONB column) contains a 'type' with the value 'Unknown'. The function is defined as follows:\\nCREATE OR REPLACE FUNCTION public.new_function(type text DEFAULT 'Unknown'::text) RETURNS SETOF bond LANGUAGE sql STABLE AS $function$ select * from bond where bond_stat_ @? '$.** ? (@ == $1)'; $function$. However, when I try to execute the function, it returns no results, even though I expect some bonds to match the given condition. The problematic part of the query is:\\nselect * from bond where bond_stat_ @? '$.** ? (@ == $1)'; How can I correctly select the bond_id I want?", "issue_sql": ["CREATE OR REPLACE FUNCTION public.new_function(type text DEFAULT 'Unknown'::text) RETURNS SETOF bond LANGUAGE sql STABLE AS $function$ select * from bond where bond_stat_ @? '$.** ? (@ == $1)'; $function$", "SELECT bond_id FROM new_function();"], "preprocess_sql": ["ALTER TABLE bond ADD COLUMN bond_stat_ JSONB;", "UPDATE bond SET bond_stat_ = '{\"Type A\": {\"time\": 500, \"complete\": 100.0, \"type\": \"Unknown\"}, \"Type B\": {\"time\": 35, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type C\": {\"time\": 50, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_1_2';", "UPDATE bond SET bond_stat_ = '{\"Type A\": {\"time\": 55, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type C\": {\"time\": 20, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_2_3';", "UPDATE bond SET bond_stat_ = '{\"Type C\": {\"time\": 100, \"complete\": 100.0, \"type\": \"Parallel\"}, \"Type A\": {\"time\": 55, \"complete\": 100.0, \"type\": \"Unknown\"}, \"Type D\": {\"time\": 70, \"complete\": 100.0, \"type\": \"Serial\"}}'::jsonb WHERE bond_id = 'TR000_2_4';"], "clean_up_sql": ["ALTER TABLE bond DROP COLUMN bond_stat_;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT\n  (jsonb_agg(patients)) as result\nFROM\n  (SELECT\n    *\n   FROM\n    patients\n  ) as patients\n\nUNION\n\nSELECT\n  (jsonb_agg(doctors)) as doctors\nFROM\n   (\n     SELECT\n       *\n     FROM\n       doctors\n   ) AS doctors\n\nUNION\n\nSELECT\n  (jsonb_agg(appointments)) as appointments\nFROM\n   (\n    SELECT\n      *\n    FROM\n      appointments\n   ) AS appointments;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    assert len(pred_query_result) == 3, f'Expected 3 rows, but found {len(pred_query_result)} rows'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT coalesce(json_agg(doctors), '[]'::json) as doctors FROM (SELECT * FROM doctors) as doctors\", db_name)[0][0]\n    assert test_pred_query_result_1 in pred_query_result[:3], f'Expected to find the doctors information, but found {test_pred_query_result_1} and {pred_query_result[1]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_223", "db_id": "european_football_2", "query": "In the context of the 'european_football_2' database, a user is trying to enforce a conditional unique constraint on a table named 'match_results'. The table stores the results of football matches, including the match ID, team IDs, and the score. The requirement is that if multiple rows have the same match ID and team IDs, the scores must be the same. Additionally, if the match ID and team IDs are unique, the score must also be unique across different matches. The user attempted to create a conditional unique index but encountered an error. The user also implemented a trigger to handle the first condition but is facing issues with the second condition.", "issue_sql": ["CREATE UNIQUE INDEX conditional_unique_index ON match_results (match_id, team_id) WHERE (SELECT COUNT(*) FROM match_results t2 WHERE t2.match_id = match_results.match_id AND t2.team_id = match_results.team_id) = 1;"], "preprocess_sql": ["CREATE TABLE match_results ( match_id integer, team_id integer, score integer, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, match_date DATE DEFAULT CURRENT_DATE, is_final BOOLEAN DEFAULT true, match_period VARCHAR(20) DEFAULT 'full-time', venue_id INTEGER DEFAULT 1, venue_name VARCHAR(100) DEFAULT 'Unknown Stadium', attendance INTEGER DEFAULT 0, weather_conditions VARCHAR(50) DEFAULT 'Clear', temperature_celsius NUMERIC(4,1) DEFAULT 20.0, referee_id INTEGER DEFAULT NULL, referee_name VARCHAR(100) DEFAULT NULL, match_stats JSONB DEFAULT '{}'::jsonb, notes TEXT DEFAULT NULL, validation_status VARCHAR(20) DEFAULT 'verified', data_source VARCHAR(50) DEFAULT 'official', last_modified_by VARCHAR(50) DEFAULT 'system' );", "INSERT INTO match_results (match_id, team_id, score, created_at, updated_at, match_date, is_final, match_period, venue_id, venue_name, attendance, weather_conditions, temperature_celsius, referee_id, referee_name, match_stats, notes, validation_status, data_source, last_modified_by) VALUES (1, 101, 2, '2023-01-01 12:00:00+00', '2023-01-01 15:30:00+00', '2023-01-01', true, 'full-time', 101, 'Emirates Stadium', 45000, 'Rainy', 12.5, 201, 'Michael Oliver', '{\"possession\": 55, \"shots\": 12, \"shots_on_target\": 5, \"corners\": 7}'::jsonb, 'Competitive match with high intensity', 'verified', 'official', 'admin'), (1, 101, 2, '2023-01-01 12:05:00+00', '2023-01-01 15:35:00+00', '2023-01-01', true, 'full-time', 101, 'Emirates Stadium', 45000, 'Rainy', 12.5, 201, 'Michael Oliver', '{\"possession\": 55, \"shots\": 12, \"shots_on_target\": 5, \"corners\": 7}'::jsonb, 'Duplicate entry for verification', 'verified', 'official', 'admin'), (1, 102, 1, '2023-01-01 12:10:00+00', '2023-01-01 15:40:00+00', '2023-01-01', true, 'full-time', 101, 'Emirates Stadium', 45000, 'Rainy', 12.5, 201, 'Michael Oliver', '{\"possession\": 45, \"shots\": 8, \"shots_on_target\": 3, \"corners\": 4}'::jsonb, 'Away team performance below expectations', 'verified', 'official', 'admin'), (2, 102, 3, '2023-01-08 14:00:00+00', '2023-01-08 16:15:00+00', '2023-01-08', true, 'full-time', 102, 'Anfield', 52000, 'Cloudy', 8.0, 202, 'Anthony Taylor', '{\"possession\": 62, \"shots\": 15, \"shots_on_target\": 8, \"corners\": 9}'::jsonb, 'Dominant performance by home team', 'verified', 'official', 'admin'), (3, 103, 5, '2023-01-15 16:30:00+00', '2023-01-15 18:45:00+00', '2023-01-15', true, 'full-time', 103, 'Old Trafford', 74000, 'Clear', 5.5, 203, 'Martin Atkinson', '{\"possession\": 68, \"shots\": 22, \"shots_on_target\": 12, \"corners\": 11}'::jsonb, 'Record-breaking offensive performance', 'verified', 'official', 'admin');"], "clean_up_sql": ["DROP TABLE match_results;"], "category": "Management", "efficiency": false, "sol_sql": ["UPDATE patients_info SET general_info = jsonb_set(general_info, '{accept_appointments}', 'false') WHERE NOT EXISTS(SELECT 1 FROM appointments WHERE patients_info.id = appointments.patient_id AND appointments.hide_in_online_scheduling = false)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT a.patient_id FROM appointments a GROUP BY a.patient_id HAVING COUNT(*) = COUNT(CASE WHEN a.hide_in_online_scheduling = TRUE THEN 1 END);\", db_name)[0]\n                                                                                                              \n    for i in range(len(test_pred_query_result_1)):\n        query = f\"SELECT general_info FROM patients_info WHERE id = '{test_pred_query_result_1[i][0]}';\"\n        test_pred_query_result_2 = perform_query_on_postgresql_databases(query, db_name)[0][0]\n                                        \n        assert test_pred_query_result_2[0].get('accept_appointments') is False, f'Expected to find accept_appointments, but found {test_pred_query_result_2[0]}'\n    ", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_3 = perform_query_on_postgresql_databases(\"SELECT a.patient_id FROM appointments a GROUP BY a.patient_id HAVING COUNT(*) > COUNT(CASE WHEN a.hide_in_online_scheduling = TRUE THEN 1 END);\", db_name)[0]\n    \n    for i in range(len(test_pred_query_result_3)):\n        query = f\"SELECT general_info FROM patients_info WHERE id = '{test_pred_query_result_3[i][0]}';\"\n        test_pred_query_result_4 = perform_query_on_postgresql_databases(query, db_name)[0][0]\n                                        \n        assert test_pred_query_result_4[0].get('accept_appointments') is True, f'Expected to find accept_appointments, but found {test_pred_query_result_4[0]}'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_224", "db_id": "california_schools", "query": "Given a table called 'budgets' containing a column 'rate' and a column 'time_span'. I want to generate a monthly daily rate for each day. The time_span must have a start date but can be open ended. For example: rate: $10 and time_span: [2024-12-13 00:00:00+00,). The expected results: For 2024-12-13 -> 2025-01-13, rate $10 should be divided by 31 days for a daily rate of $0.32. For 2025-01-13 -> 2025-01-23, rate of $10 should be divided by 11 days (The results only contain the date without time and the corresponding daily rate). Can you provide the right sql to achieve this goal?", "issue_sql": ["SELECT CAST(time_bucket AS DATE) AS time_bucket, rate / DATE_PART('days', time_bucket + INTERVAL '1 month - 1 day') AS daily_rate FROM (SELECT DATE(generate_series(LOWER(time_span)::TIMESTAMP, COALESCE(UPPER(time_span),NOW())::TIMESTAMP, '1 day')) AS time_bucket, rate FROM budgets) AS daily_rates;"], "preprocess_sql": ["CREATE TABLE budgets (id SERIAL PRIMARY KEY, rate INTEGER, time_span TSTZRANGE, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, description TEXT DEFAULT 'Standard budget allocation', status VARCHAR(50) DEFAULT 'active', version INTEGER DEFAULT 1, is_approved BOOLEAN DEFAULT false, approval_date TIMESTAMP WITH TIME ZONE, approved_by VARCHAR(100), notes TEXT, metadata JSONB DEFAULT '{}'::jsonb, department_id INTEGER DEFAULT 1, priority INTEGER DEFAULT 5, currency VARCHAR(3) DEFAULT 'USD', annual_adjustment_pct NUMERIC(5,2) DEFAULT 0.00, tags TEXT[] DEFAULT '{}'::TEXT[], external_reference_id UUID DEFAULT gen_random_uuid(), last_reviewed_date DATE);", "INSERT INTO budgets (rate, time_span, description, status, is_approved, approval_date, approved_by, notes, metadata, department_id, priority, currency, annual_adjustment_pct, tags, external_reference_id, last_reviewed_date) VALUES (10, '[2024-12-13 00:00:00+00,)', 'Annual operational budget', 'active', true, '2024-12-01 09:30:00+00', 'Finance Director', 'Approved in quarterly budget meeting', '{\"category\": \"operational\", \"fiscal_year\": \"2024-2025\"}'::jsonb, 3, 2, 'USD', 2.50, '{\"annual\", \"operational\", \"approved\"}', 'a1b2c3d4-e5f6-4a5b-9c8d-7e6f5a4b3c2d', '2024-11-30');"], "clean_up_sql": ["DROP TABLE budgets;"], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH atomic_operation AS (SELECT *, usd_total / molecules::DECIMAL(10,2) AS usd, COUNT(*) OVER (PARTITION BY molecule_id, sell ORDER BY date, n) AS nth_operation FROM transaction CROSS JOIN LATERAL generate_series(1, molecules) AS g(n)) SELECT purchase.molecule_id, purchase.date AS buy_date, sale.date AS sell_date, COUNT(*) AS molecules, SUM(purchase.usd)::DECIMAL(10,2) AS buy_usd_total, SUM(sale.usd)::DECIMAL(10,2) AS sell_usd_total FROM atomic_operation AS purchase JOIN atomic_operation AS sale USING(nth_operation, molecule_id) WHERE purchase.sell IS FALSE AND sale.sell IS TRUE GROUP BY 1,2,3 ORDER BY 1,2,3;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_225", "db_id": "superhero", "query": "I was trying to process a column in the superhero database that contains both numeric and non-numeric values. Specifically, I was working with the height_cm column in the superhero table, which should ideally contain numeric values representing the height in centimeters. However, due to data entry errors, some entries in this column contain non-numeric values. When I attempted to convert these values to numeric using the TO_NUMBER function, I encountered an error. I found a solution in Oracle SQL that uses the TO_NUMBER function with a default value on conversion error. Is there a way to handle the same thing in PostgreSQL SQL?", "issue_sql": ["SELECT attribute_name, to_number(attribute_name) FROM attribute;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE dates AS (SELECT CURRENT_DATE::date AS date UNION ALL SELECT (date + INTERVAL '1 day')::date FROM dates WHERE date < CURRENT_DATE + INTERVAL '59 days'), schedule_blocks_with_dates AS (SELECT sb.block_id, sb.user_id, d.date AS block_date, sb.start_time, sb.end_time FROM schedule_blocks sb JOIN dates d ON TRIM(sb.day_of_week) = TRIM(to_char(d.date, 'Day')) WHERE sb.is_available = TRUE AND d.date >= CURRENT_DATE AND d.date <= CURRENT_DATE + INTERVAL '2 months') SELECT block_id, user_id, block_date AS date, start_time, end_time FROM schedule_blocks_with_dates ORDER BY date, user_id, start_time;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_226", "db_id": "toxicology", "query": "In the context of a toxicology database, a user is attempting to retrieve information about molecules and the total bonds that are formed by them. The user's initial query attempts to use aggregate functions within a FILTER clause, which is not allowed in PostgreSQL, leading to an error. The user then tries to replace FILTER with HAVING, which also results in a syntax error.", "issue_sql": ["SELECT molecule_id, COUNT(*) FILTER (WHERE COUNT(*) > 5) AS total_bonds FROM bond GROUP BY molecule_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT id, sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as a, sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as b FROM team_attributes limit 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_227", "db_id": "thrombosis_prediction", "query": "I am trying to analyze the laboratory test data for patients over time. Specifically, I want to generate a weekly report that sums up the total number of laboratory tests (`id`) performed each week. I have successfully created a monthly report, but when I attempt to create a weekly report, the sums are not being calculated correctly. Below is the SQL query I used for the monthly report, which works as expected, and the problematic weekly report query.", "issue_sql": ["WITH range_values AS ( SELECT date_trunc('week', min(date)) as minval, date_trunc('week', max(date)) as maxval FROM laboratory ), week_range AS ( SELECT generate_series('1991-01-01', now(), '1 week') as week FROM range_values ), grouped_labs AS ( SELECT date_trunc('week', date) as week, count(id) as total_tests FROM laboratory WHERE date >= '1991-01-01' GROUP BY 1 ) SELECT week_range.week, COALESCE(sum(total_tests)::integer, 0) AS total_labs FROM week_range LEFT OUTER JOIN grouped_labs on week_range.week = grouped_labs.week GROUP BY 1 ORDER BY 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["CREATE VIEW overview AS\n    SELECT\n        (SELECT COUNT(*) FROM learners) AS learners_count,\n        (SELECT COUNT(*) FROM institutions) AS institutions_count,\n        (SELECT COUNT(*) FROM curricula) AS curricula_count;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_query = execute_queries([\"SELECT * FROM overview\"], db_name, conn)[0]\n    assert len(test_query) == 1, f'Expected 1 row, but found {len(test_query)} rows'\n    assert test_query[0][0] == 42681, f'Expected learners_count to be 42681, but found {test_query[0][0]}'\n    assert test_query[0][1] == 42681, f'Expected institutions_count to be 42681, but found {test_query[0][1]}'\n    assert test_query[0][2] == 42681, f'Expected curricula_count to be 42681, but found {test_query[0][2]}'\n    assert all(isinstance(value, int) for value in test_query[0]), f'All values in the result should be integers: {test_query[0]}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_228", "db_id": "california_schools", "query": "In the context of the 'california_schools' database, we have two tables: 'school_supplies' and 'school_inventory'. The 'school_supplies' table records the supply history of various school supplies, including the quantity of supplies received. The 'school_inventory' table keeps track of the current inventory of school supplies, including the quantity of each supply. We want to create a trigger that updates the 'school_inventory' table whenever a new supply is recorded in the 'school_supplies' table. Specifically, after an insertion into the 'school_supplies' table, the trigger should update the 'quantity' field in the 'school_inventory' table by adding the quantity from the 'school_supplies' table to the existing quantity in the 'school_inventory' table for the corresponding supply. The trigger provided does not work as expected and needs to be corrected.", "issue_sql": ["DROP FUNCTION IF EXISTS update_school_inventory_after_supply() CASCADE;CREATE OR REPLACE FUNCTION update_school_inventory_after_supply() RETURNS TRIGGER LANGUAGE plpgsql AS $trigger$ BEGIN UPDATE school_inventory AS i SET NEW.quantity = school_supplies.quantity + OLD.quantity FROM school_supplies WHERE i.cdscode = school_supplies.cdscode; RETURN NEW; END; $trigger$;DROP TRIGGER IF EXISTS trigger_insert_supply ON school_supplies;CREATE TRIGGER trigger_insert_supply AFTER INSERT ON school_supplies FOR EACH ROW EXECUTE FUNCTION update_school_inventory_after_supply();"], "preprocess_sql": ["CREATE TABLE IF NOT EXISTS school_supplies ( id_supply int GENERATED ALWAYS AS IDENTITY, cdscode text NOT NULL, supply_name varchar(150) DEFAULT('None'), quantity int NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, supplier_name VARCHAR(200) DEFAULT 'Unknown Supplier', unit_cost NUMERIC(10, 2) DEFAULT 0.00, total_cost NUMERIC(12, 2) DEFAULT 0.00, order_date DATE DEFAULT CURRENT_DATE, expected_delivery_date DATE, actual_delivery_date DATE, delivery_status VARCHAR(50) DEFAULT 'pending', invoice_number VARCHAR(100), payment_status VARCHAR(50) DEFAULT 'unpaid', payment_date DATE, quality_rating INTEGER DEFAULT 3 CHECK (quality_rating BETWEEN 1 AND 5), notes TEXT DEFAULT '', is_emergency_order BOOLEAN DEFAULT FALSE, metadata JSONB DEFAULT '{}'::jsonb, supply_category VARCHAR(100) DEFAULT 'Uncategorized', PRIMARY KEY (id_supply), CONSTRAINT fk_cdscode FOREIGN KEY (cdscode) REFERENCES schools(cdscode) )", "CREATE TABLE IF NOT EXISTS school_inventory ( id_inventory int GENERATED ALWAYS AS IDENTITY, cdscode text NOT NULL, supply_name varchar(150) DEFAULT('None'), quantity int NOT NULL, last_updated TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, minimum_stock_level INTEGER DEFAULT 10, maximum_stock_level INTEGER DEFAULT 100, reorder_point INTEGER DEFAULT 20, location_code VARCHAR(50) DEFAULT 'MAIN-STORAGE', shelf_position VARCHAR(50), expiration_date DATE, last_inventory_check DATE DEFAULT CURRENT_DATE, inventory_status VARCHAR(50) DEFAULT 'in-stock', responsible_staff VARCHAR(200), unit_value NUMERIC(10, 2) DEFAULT 0.00, total_value NUMERIC(12, 2) GENERATED ALWAYS AS (quantity * unit_value) STORED, is_perishable BOOLEAN DEFAULT FALSE, barcode VARCHAR(100), supplier_id VARCHAR(100), metadata JSONB DEFAULT '{}'::jsonb, PRIMARY KEY (id_inventory), CONSTRAINT fk_cdscode FOREIGN KEY (cdscode) REFERENCES schools(cdscode) )"], "clean_up_sql": ["DROP TABLE IF EXISTS school_supplies; DROP TABLE IF EXISTS school_inventory;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT\n    patients.patient_id,\n    demographics.height,\n    treatment_and_followup.primary_pathology_karnofsky_performance_score,\n    MIN(primary_pathology_karnofsky_performance_score) AS min_performance_score\n    FROM patients\n    JOIN treatment_and_followup ON patients.patient_id = treatment_and_followup.patient_id\n    JOIN demographics ON patients.patient_id = demographics.patient_id\n    WHERE informed_consent_verified = TRUE AND treatment_and_followup.primary_pathology_karnofsky_performance_score IS NOT NULL\n    GROUP BY patients.patient_id, demographics.height, treatment_and_followup.primary_pathology_karnofsky_performance_score\n    ORDER BY patients.patient_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty when there are patients with informed consent verified.'\n    first_row = test_result[0]\n    assert isinstance(first_row[0], int), f'Expected patient_id to be an integer, but found {type(first_row[0])}'\n    assert all(isinstance(row[2], int) for row in test_result), 'Karnofsky Performance Score must be not null.'\n    test_min_scores = execute_queries([\"SELECT patients.patient_id, MIN(primary_pathology_karnofsky_performance_score) FROM treatment_and_followup JOIN patients ON treatment_and_followup.patient_id = patients.patient_id WHERE informed_consent_verified = TRUE  AND treatment_and_followup.primary_pathology_karnofsky_performance_score IS NOT NULL GROUP BY patients.patient_id ORDER BY patients.patient_id\"], db_name, conn)[0]\n    assert sorted((row[0], row[2]) for row in test_result) == sorted((row[0], row[1]) for row in test_min_scores), 'The minimum Karnofsky scores should match with the expected result from the database.'\n    assert len(set(row[0] for row in test_result)) == len(test_result), 'Each patient_id should appear only once in the results.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_229", "db_id": "california_schools", "query": "I am analyzing the performance of schools in terms of their SAT scores across different counties. I want to identify the top 5 counties with the highest average SAT scores and then look at the average SAT scores by school within those top 5 counties. I can do this in two steps but I want to automate it into one step. First, I find the top 5 counties by average SAT scores:", "issue_sql": ["SELECT county, AVG(avgscrread + avgscrmath + avgscrwrite) / 3 AS avg_total_sat FROM satscores GROUP BY county ORDER BY avg_total_sat DESC LIMIT 5;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE A(GroupNum, n, RollingSum, id) AS (\n     SELECT 1,\n     P.\"Performance_Prediction\",\n  \t CAST(P.\"Performance_Prediction\" AS NUMERIC(5,2)), P.prediction_code\n    FROM (\n        SELECT * FROM performance_predictions ORDER BY prediction_code ASC LIMIT 1\n    ) AS P\n    UNION ALL\n    SELECT\n        CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200\n            THEN GroupNum + 1\n            ELSE GroupNum\n        END,\n        P.\"Performance_Prediction\",\n        CAST(\n            CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200\n                THEN P.\"Performance_Prediction\"\n                ELSE RollingSum + P.\"Performance_Prediction\"\n            END\n        AS NUMERIC(5,2)),\n        P.prediction_code\n    FROM A\n    JOIN performance_predictions AS P ON A.id+1 = P.prediction_code\n)\n    SELECT GroupNum, n, SUM(n) OVER (PARTITION BY GroupNum) AS group_sum\n    FROM A\n    ORDER BY GroupNum, n;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    groups_num = execute_queries(['''\n        WITH RECURSIVE A(GroupNum, n, RollingSum, id) AS (\n            SELECT 1, \n            P.\"Performance_Prediction\",\n            CAST(P.\"Performance_Prediction\" AS NUMERIC(5,2)), P.prediction_code\n            FROM (\n                SELECT * FROM performance_predictions ORDER BY prediction_code ASC LIMIT 1\n            ) AS P\n            UNION ALL\n            SELECT \n                CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200 \n                    THEN GroupNum + 1 \n                    ELSE GroupNum \n                END,\n                P.\"Performance_Prediction\",\n                CAST(\n                    CASE WHEN RollingSum + P.\"Performance_Prediction\" > 200\n                        THEN P.\"Performance_Prediction\"\n                        ELSE RollingSum + P.\"Performance_Prediction\"\n                    END \n                AS NUMERIC(5,2)), \n                P.prediction_code\n            FROM A\n            JOIN performance_predictions AS P ON A.id+1 = P.prediction_code\n        )\n        SELECT COUNT(DISTINCT GroupNum) \n        FROM A;\n    '''], db_name, conn)[0]\n    \n    assert groups_num[0][0] == 19871, f\"Expected 19871 groups, but found {groups_num} groups.\"\n    \n    group_sums = {}\n    for row in test_result:\n        group_num = row[0]\n        group_sum = row[2] \n        if group_num not in group_sums:\n            group_sums[group_num] = group_sum\n        assert group_sum <= 200, f\"Sum of group {group_num} = {group_sum} exceeds 200\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_230", "db_id": "thrombosis_prediction", "query": "I am trying to analyze the laboratory data for patients in our thrombosis_prediction database. Specifically, I want to find the latest laboratory date and then use this date to filter records in the laboratory table where the patient check date matches this date.", "issue_sql": ["WITH vars AS ((select count(*) from laboratory) AS vars_id) select * from laboratory where id=vars.vars_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT DISTINCT A.client_id AS child FROM client A JOIN client B\nON A.district_id = B.district_id WHERE A.birth_date + INTERVAL '16 years' < B.birth_date ORDER BY A.client_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected rows, but found {len(test_pred_query_result_1)}'\n    assert test_pred_query_result_1[0][0] == 2, f'Expect to be 2, but found {test_pred_query_result_1[0][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expected rows, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 2, f'Expect to be 2, but found {test_sol_query_result[0][0]}'\n    excluded_client_ids = [1, 37]\n    for row in test_sol_query_result:\n        client_id = row[0] \n        assert client_id not in excluded_client_ids, f'client_id {client_id} should not be in the result'\n    sorted_client_ids = sorted(row[0] for row in test_sol_query_result)\n    assert sorted_client_ids == [row[0] for row in test_sol_query_result], 'Results are not sorted by client_id'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_231", "db_id": "european_football_2", "query": "\nI have a table named \"match_location\" in my PostgreSQL database that contains geographical data of football matches, including the latitude and longitude of each match location. I need to find all matches that occurred within a 2-mile radius of a given latitude and longitude. I tried using the following query, but it didn't work as expected:\n\nsql\nSELECT * FROM Match WHERE ST_INTERSECTS(geom, CIRCLE(POINT(40.730610, -73.935242), 2));\n\n\nI realized that I might have switched the latitude and longitude in the query, so I adjusted it to:\n\nsql\nSELECT * FROM Match WHERE ST_INTERSECTS(geom::geometry, ST_SETSRID(ST_POINT(-73.935242, 40.730610), 4269)::geometry);\n\n\nThis query returned some results, but I'm not sure how to incorporate the 2-mile radius into the query. How can I modify the query to find matches within a 2-mile radius of the given latitude and longitude?\n", "issue_sql": ["SELECT * FROM match_location WHERE ST_INTERSECTS(location, CIRCLE(POINT(-73.935242, 40.730610), 2));"], "preprocess_sql": ["\nCREATE EXTENSION postgis;\nCREATE TABLE match_location (\n    id SERIAL PRIMARY KEY,\n    location GEOGRAPHY(POINT, 4326)\n);\nINSERT INTO match_location (location)\nVALUES\n    (ST_SetSRID(ST_MakePoint(-73.935242, 40.730610), 4326)),  \n    (ST_SetSRID(ST_MakePoint(-73.937642, 40.735910), 4326)), \n    (ST_SetSRID(ST_MakePoint(-73.985428, 40.748817), 4326)),\n    (ST_SetSRID(ST_MakePoint(-73.985130, 40.758896), 4326)),  \n    (ST_SetSRID(ST_MakePoint(-74.005974, 40.712776), 4326));  \n"], "clean_up_sql": ["drop table match_location;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT DISTINCT g.GasStationID\nFROM transactions_1k t\nJOIN gasstations g ON t.GasStationID = g.GasStationID\nGROUP BY g.GasStationID, t.CustomerID\nHAVING SUM(t.Amount * t.Price) >= 0.7 * (\n    SELECT SUM(t2.Amount * t2.Price)\n    FROM transactions_1k t2\n    WHERE t2.CustomerID = t.CustomerID\n) LIMIT 100"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result_1) > 0, 'Expected rows, but found {len(test_pred_query_result_1)}'\n    assert test_pred_query_result_1[0][0] == 48, f'Expect to be 48, but found {test_pred_query_result_1[0][0]}'\n    assert test_pred_query_result_1[1][0] == 64, f'Expect to be 64, but found {test_pred_query_result_1[1][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expected rows, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 48, f'Expect to be 48, but found {test_sol_query_result[0][0]}'\n    assert test_sol_query_result[1][0] == 64, f'Expect to be 64, but found {test_sol_query_result[1][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_232", "db_id": "erolp", "query": "In the context of managing educational data, a user attempted to insert a new record into the 'learners' table, which includes detailed information about learners such as their age, gender, geographic location, and more. The table has many columns, making it challenging to identify which specific column caused an error during the insertion process. The user encountered a PostgreSQL error indicating that a value was too long for a character varying type with a specified length. The user seeks a method to identify the problematic column without manually inspecting each column's constraints.", "issue_sql": ["INSERT INTO learners\n  (\"Age\", \"Gender\", \"Geographic_Location\", \"Socioeconomic_Background\",\n   \"Education_Level\", \"Previous_Academic_Performance\", \"Language_Proficiency\",\n   \"Preferred_Learning_Medium\", \"Learning_Pace\", \"Engagement_History\")\nVALUES\n  (18,\n   'Male',\n   'Urban',\n   'Low',\n   'UndergraduateUndergraduateUndergraduate',\n   88.55,\n   'Intermediate',\n   'Video',\n   'Moderate',\n   6);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT CASE WHEN c.type = 'gold' THEN 'Gold' ELSE 'Non-Gold'\nEND AS card_type_group, COUNT(l.loan_id) AS loan_count FROM loan l JOIN disp d\nON l.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id GROUP BY card_type_group"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 2, f'Expect to be 2, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == 154, f'Expect to be 154, but found {test_pred_query_result[0][1]}'\n    assert test_pred_query_result[1][1] == 16, f'Expect to be 16, but found {test_pred_query_result[1][1]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 2, f'Expect to be 2, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == 154, f'Expect to be 154, but found {test_sol_query_result[0][1]}'\n    assert test_sol_query_result[1][1] == 16, f'Expect to be 16, but found {test_sol_query_result[1][1]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_233", "db_id": "erolp", "query": "In the context of an educational database, a user is attempting to combine multiple array columns from different tables into one with distinct elements and then get a count of distinct elements. Specifically, they are working with the 'educational_resources' and 'curriculum_resources' tables, aiming to merge the 'Content_Type' and 'Platform_Used' columns from 'educational_resources' with the 'recommended' column from 'curriculum_resources' into a single array for each 'curriculum_id', and then count the distinct elements in this combined array. The user has encountered issues with their SQL query, which fails to correctly combine and count these distinct elements.", "issue_sql": ["SELECT\n    x.curriculum_id,\n    ARRAY_LENGTH(x.combined_array, 1) AS distinct_count\nFROM\n(\n\nSELECT\n        c.curriculum_id,\n        ARRAY[e.\"Content_Type\", e.\"Platform_Used\"] AS combined_array\n    FROM curriculum_resources cr\n    JOIN educational_resources e\n      ON cr.resource_key = e.resource_key\n    JOIN curricula c\n      ON c.curriculum_id = cr.curriculum_id\n\n    UNION\nSELECT\n        c2.curriculum_id,\n        ARRAY[cr2.recommended] AS combined_array\n    FROM curriculum_resources cr2\n    JOIN curricula c2\n      ON c2.curriculum_id = cr2.curriculum_id\n) AS x\nGROUP BY x.curriculum_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH member_events AS (\n    SELECT\n        link_to_member,\n        link_to_event,\n        COUNT(1) AS total,\n        ROW_NUMBER() OVER (PARTITION BY link_to_member ORDER BY COUNT(1) DESC) AS rank,\n        'Member Top 2' AS result_type\n    FROM attendance\n    GROUP BY link_to_member, link_to_event\n),\nevent_members AS (\n    SELECT\n        link_to_member,\n        link_to_event,\n        COUNT(1) AS total,\n        ROW_NUMBER() OVER (PARTITION BY link_to_event ORDER BY COUNT(1) DESC) AS rank,\n        'Event Top 1' AS result_type\n    FROM attendance\n    GROUP BY link_to_member, link_to_event\n)\nSELECT\n    link_to_member,\n    link_to_event,\n    total,\n    result_type\nFROM member_events\nWHERE rank <= 2\n\nUNION ALL\n\nSELECT\n    link_to_member,\n    link_to_event,\n    total,\n    result_type\nFROM event_members\nWHERE rank = 1\n\nORDER BY result_type, link_to_member, link_to_event"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[0][2] == 1, f'Expect to be 1, but found {test_pred_query_result[0][1]}'\n    assert test_pred_query_result[5][2] == 1, f'Expect to be 1, but found {test_pred_query_result[1][1]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[0][2] == 1, f'Expect to be 1, but found {test_sol_query_result[0][1]}'\n    assert test_sol_query_result[5][2] == 1, f'Expect to be 1, but found {test_sol_query_result[1][1]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_234", "db_id": "erolp", "query": "I have two tables in my database:\n\n1. curricula, which lists various curricula in the system.\n    In addition to columns like \"Modules\", \"Sequence\", etc., it has a status column that can be one of:\n        'installed'\n        'uninstalled'\n        'to upgrade'\n    Its primary key is curriculum_id.\n2. curriculum_resources, which maps each curriculum (via curriculum_id) to one or more educational resources (via resource_key).\n    Conceptually, you can think of each resource as depending on the curriculum. Some resources may appear in multiple curricula, creating potential chains of dependencies.\n\nI want to pick one particular curriculumsay, Introduction to Programmingand update its status to 'to upgrade'. But I also need to recursively update any resources or other curricula that depend on it (directly or indirectly) to the same 'to upgrade' status. Essentially, if Curriculum A depends on Curriculum B, and Curriculum B depends on Curriculum C, updating Curriculum A should cascade an update to Curriculum B and Curriculum C. The same logic applies if certain resources transitively depend on that curriculum.\n\nHowever, Im running into an issue trying to write a single recursive CTE (WITH RECURSIVE) to find all curricula/resources that need updating. My queries either pull in everything (infinite loop) or fail to capture all dependencies. Here is a sketch of the query Ive tried:\n```sql\nWITH RECURSIVE curricula_to_upgrade AS (\n  SELECT curriculum_id\n  FROM curricula\n  WHERE curriculum_id = 123  -- e.g. \"Introduction to Programming\"\n    AND status = 'installed'\n\n  UNION ALL\n\n  SELECT cr.curriculum_id\n  FROM curriculum_resources cr\n  JOIN curricula_to_upgrade ctu \n         ON cr.resource_key = ???  -- Attempting to chain dependencies\n)\nSELECT *\nFROM curricula_to_upgrade;\n```\nAfter retrieving this list of IDs in the CTE, I planned to do an UPDATE:\n```sql\nUPDATE curricula\nSET status = 'to upgrade'\nWHERE curriculum_id IN (SELECT curriculum_id FROM curricula_to_upgrade);\n```\nBut so far, I havent been able to make the recursion terminate correctly, nor ensure that all truly dependent curricula/resources get updated. How can I structure this recursive query (and the related schema references) so that I can reliably update Introduction to Programming and all of its transitive dependencies status to 'to upgrade' without running into an infinite loop or missing certain dependencies?", "issue_sql": ["ALTER TABLE curricula\n  ADD COLUMN status TEXT DEFAULT 'installed';\n\n\nWITH RECURSIVE curricula_to_upgrade AS (\n\nSELECT c.curriculum_id\n    FROM curricula c\n    WHERE c.status = 'installed'\n      AND c.curriculum_id = 1\n\nUNION ALL\n\n\nSELECT c2.curriculum_id\n    FROM curricula c2\n    JOIN curricula_to_upgrade ctu\n         ON c2.curriculum_id = ctu.curriculum_id\n)\nUPDATE curricula\nSET status = 'to upgrade'\nWHERE curriculum_id IN (\n    SELECT curriculum_id\n    FROM curricula_to_upgrade\n);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT DISTINCT ON (CustomerID) CustomerID, Date, Time\nFROM transactions_1k\nORDER BY CustomerID, Date DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[0][0] == 96, f'Expect to be 96, but found {test_pred_query_result[0][0]}'\n    assert test_pred_query_result[6][0] == 2183, f'Expect to be 2183, but found {test_pred_query_result[6][0]}'\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[0][0] == 96, f'Expect to be 96, but found {test_sol_query_result[0][0]}'\n    assert test_sol_query_result[6][0] == 2183, f'Expect to be 2183, but found {test_sol_query_result[6][0]}'\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_235", "db_id": "erolp", "query": "In an educational database, we have a table event_usage that stores data about learners' usage of educational resources. The table contains the following columns: learner_code, resource_key, start_timestamp, end_timestamp, and duration (in seconds).\nThe challenge is to calculate the total time spent by learners on resources during working hours (9:00 - 18:00, Monday to Friday), while excluding time spent outside these hours, including weekends. This means we need to calculate the duration between start_timestamp and end_timestamp, but only include time that falls within the working hours and working days, excluding weekends. Some events may span multiple days and include non-working hours, which should be excluded. Can you write a SQL query to compute this correctly?", "issue_sql": ["SELECT learner_code, resource_key, SUM(duration) AS total_time_spent\nFROM event_usage\nWHERE start_timestamp BETWEEN '2024-10-01' AND '2024-10-09'\nGROUP BY learner_code, resource_key;"], "preprocess_sql": ["DROP TABLE IF EXISTS event_usage CASCADE;\n\nCREATE TABLE event_usage (\n    id SERIAL PRIMARY KEY,\n    learner_code INT NOT NULL,\n    resource_key INT NOT NULL,\n    start_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,\n    end_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,\n    duration BIGINT NOT NULL\n);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (1, 101, '2024-10-01 03:00:00+00', '2024-10-01 15:00:00+00', 43200);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (2, 102, '2024-10-02 05:00:00+00', '2024-10-03 17:00:00+00', 129600);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (3, 103, '2024-10-04 12:00:00+00', '2024-10-07 09:45:00+00', 251100);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (4, 104, '2024-10-05 02:00:00+00', '2024-10-05 19:00:00+00', 61200);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (5, 105, '2024-10-06 08:00:00+00', '2024-10-07 15:00:00+00', 25200);\n\nINSERT INTO event_usage (learner_code, resource_key, start_timestamp, end_timestamp, duration)\nVALUES\n    (6, 106, '2024-10-08 21:00:00+00', '2024-10-09 02:00:00+00', 25200);\n"], "clean_up_sql": ["DROP TABLE public.event_usage;"], "category": "Query", "efficiency": false, "sol_sql": ["DELETE FROM treatment_and_followup_latest b USING treatment_and_followup_backup a WHERE NOT EXISTS (\n    SELECT 1\n    FROM treatment_and_followup_backup a\n    WHERE a.patient_id = b.patient_id\n);\n    DELETE FROM treatment_and_followup_backup b USING treatment_and_followup_latest a WHERE b.patient_id = a.patient_id;\n    INSERT INTO treatment_and_followup_backup (SELECT * FROM treatment_and_followup_latest);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries([\"SELECT * FROM treatment_and_followup_backup;\"], db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least one row, but found none. The query did not return any rows.'\n    expected_len = execute_queries(['SELECT COUNT(*) FROM treatment_and_followup;'], db_name, conn)[0]\n    assert expected_len[0][0] == len(test_result), 'The number of rows in the result should match the number of rows in the treatment_and_followup table.'\n    details_query_result = execute_queries(['SELECT patient_id FROM treatment_and_followup'], db_name, conn)[0];\n    expected_details = {(row[0]) for row in details_query_result};\n    actual_details = {(row[1]) for row in test_result};\n    assert expected_details == actual_details, f'Details do not match. Expected {expected_details}, but got {actual_details}.'\n    updated_result = execute_queries(['SELECT * FROM treatment_and_followup_backup WHERE patient_id = 1'], db_name, conn)[0];\n    assert updated_result[0][2] == 0, f'Expected followup_no to be 0, but got {updated_result[0][2]}.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_236", "db_id": "erolp", "query": "In the context of an educational database, we have a table named resource_usage_2 that tracks the usage of educational resources by learners. The table includes the following fields:\n\nlearner_code (ID of the learner)\nresource_key (ID of the resource)\nrating (learner's rating for the resource)\nusage_date (the date when the resource was used)\nSome records in the rating column are null, and we want to fill these null rating values with the most recent non-null rating for the same learner_code and resource_key, ordered by usage_date.\n\nThe task is to efficiently fill these null values using the most recent non-null rating in the same partition, while keeping in mind that the dataset is large.\n\nIve tried the following SQL query but am encountering issues with some rows not getting filled correctly, while others are. The query uses window functions to partition the data by learner_code and resource_key, and order it by usage_date. This query works for some records but fails for others. After analyzing it, I believe the issue could be related to how the window function is applied across partitions and how null values are handled.\n\nEdit:\nI need the rating column to be forward-filled with the most recent non-null value for each learner_code and resource_key, ordered by usage_date. How can I fix the query to achieve this result efficiently?", "issue_sql": ["SELECT\n  first_value(rating) OVER (\n    PARTITION BY learner_code, resource_key\n    ORDER BY usage_date\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS filled_rating,\n  learner_code,\n  resource_key\nFROM\n  resource_usage_2\nORDER BY\n  learner_code, usage_date;"], "preprocess_sql": ["CREATE TABLE resource_usage_2 (\n    learner_code INT,\n    resource_key INT,\n    rating INT,\n    usage_date DATE\n);\n", "INSERT INTO resource_usage_2 (learner_code, resource_key, rating, usage_date) \nVALUES\n(1001, 101, 5, '2023-01-01'),\n(1001, 101, NULL, '2023-01-02'),\n(1001, 101, NULL, '2023-01-03'),\n(1001, 101, 3, '2023-01-04'),\n(1001, 101, NULL, '2023-01-05'),\n(1001, 101, NULL, '2023-01-06'),\n(1001, 101, 4, '2023-01-07'),\n(1002, 102, 3, '2023-01-01'),\n(1002, 102, NULL, '2023-01-02'),\n(1002, 102, 2, '2023-01-03'),\n(1002, 102, NULL, '2023-01-04'),\n(1002, 102, 1, '2023-01-05');\n"], "clean_up_sql": ["DROP TABLE public.resource_usage_2;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT learner_code, unnest(engagement_history) AS engagement\n    FROM learners_array\n    WHERE engagement_history IS NOT NULL"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == 10, f'Expected 10 rows, but found {len(test_result)} rows'\n    assert test_result[0] == (1, 5), f'Expected first row to be (1, 5), but found {test_result[0]}'\n    assert test_result[-1] == (4, 30), f'Expected last row to be (4, 30), but found {test_result[-1]}'\n    expected_results = [(1, 5), (1, 10), (1, 15), (2, 3), (2, 6), (3, 8), (4, 12), (4, 18), (4, 25), (4, 30)]\n    assert all(row in test_result for row in expected_results), f'Expected all rows {expected_results} to be in result, but found {test_result}'\n    assert len(set(test_result)) == len(test_result), 'Found duplicate rows in result'    \n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_237", "db_id": "formula_1", "query": "We have a table of race incidents with the start and end times of each incident. We need to transform this data into a table that shows the total minutes each race incident was active for each day. For example, if an incident started on January 1, 2022, at 1:05 AM and ended on January 1, 2022, at 3:00 AM, it should show 115 minutes for January 1, 2022. The user attempted to create a date series and then calculate the incident minutes for each day but encountered issues with the SQL query.", "issue_sql": ["SELECT dd::date AS day_start, SUM(CASE WHEN T.incident_start <= dd AND T.incident_end >= dd THEN 1440 ELSE 0 END) AS incident_minutes FROM generate_series('2022-01-01'::timestamp, '2022-01-31'::timestamp, '1 day'::interval) dd LEFT JOIN race_incidents T ON dd::date BETWEEN T.incident_start AND T.incident_end GROUP BY dd::date ORDER BY dd::date"], "preprocess_sql": ["CREATE TABLE race_incidents (incident_start timestamp, incident_end timestamp); INSERT INTO race_incidents (incident_start, incident_end) VALUES ('2022-01-01 01:05:00', '2022-01-01 03:00:00'), ('2022-01-02 05:00:00', '2022-01-05 12:34:00'), ('2022-02-05 13:00:00', '2022-02-06 16:22:00');"], "clean_up_sql": ["DROP TABLE IF EXISTS race_incidents;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT t.\"Engagement_Level\",\n\t    NUMRANGE(min(r.rating), max(r.rating), '[]')\n    FROM resource_usage as r\n    JOIN target_labels as t\n    ON r.learner_code = t.learner_code\n    GROUP BY t.\"Engagement_Level\"\n    ORDER BY t.\"Engagement_Level\" ASC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty.'\n    assert all(row[0] in ['High', 'Low', 'Medium'] for row in test_result), 'Engagement levels should be among High, Low, or Medium.'\n    assert test_result[0][1].lower <= test_result[0][1].upper, 'Minimum rating should be less than or equal to maximum rating for each engagement level.'\n    assert test_result[1][1].lower == 1.0, 'Minimum rating should be equal to 1.0 for each engagement level.'\n    assert test_result[1][1].upper == 5.0, 'Maximum rating should be equal to 5.0 for each engagement level.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_238", "db_id": "thrombosis_prediction", "query": "I am trying to generate a SQL query to be used in a view to create an Excel-like format for a parent-child relationship in our thrombosis_prediction database. Specifically, I want to display patient information along with their laboratory results in a tabular format where each patient can have multiple laboratories records. The desired output should include the patient's id along with the details of up to three examination records, including the LDH and ALP from the examination. If a patient has fewer than three examination records, the remaining columns should be filled with nulls. Additionally, I want to include patients who have no examination records at all. I attempted to use a crosstab query but encountered errors when trying to include additional patient information and handle patients with no examination records.", "issue_sql": ["SELECT * FROM CROSSTAB ('SELECT p.id, l.ldh, l.ldh, l.ldh FROM patient p JOIN laboratory l ON p.id = l.id ORDER BY 1,2;') AS (id INT, ldh_1 INT, ldh_2 INT, ldh_3 INT);"], "preprocess_sql": ["CREATE EXTENSION IF NOT EXISTS tablefunc;"], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT learner_code, rating, usage_date\n    FROM resource_usage\n    WHERE (learner_code, usage_date)\n    IN (SELECT learner_code,\n        max(usage_date) as latest_usage_date\n        FROM resource_usage\n        GROUP BY learner_code)\n    ORDER BY learner_code, usage_date DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The result should not be empty.'\n    assert all(test_result[i][0] <= test_result[i + 1][0] for i in range(len(test_result) - 1)), \"learner_code should be ordered in ascending order.\"\n    expected_latest_dates = ['2025-04-01', '2025-05-01']\n    expected_ratings = [3.0, 4.0]\n    assert str(test_result[0][2]) == expected_latest_dates[0], f'For learner_code {test_result[0][0]}, expected latest date: 2025-04-01, but found: {test_result[0][2]}.'\n    assert str(test_result[1][2]) == expected_latest_dates[1], f'For learner_code {test_result[1][0]}, expected latest date: 2025-05-01, but found: {test_result[1][2]}.'\n    assert test_result[0][1] == expected_ratings[0], f'For learner_code {test_result[0][0]}, expected latest rating: {expected_ratings[0]}, but found: {test_result[0][1]}.'\n    assert test_result[1][1] == expected_ratings[1], f'For learner_code {test_result[1][0]}, expected latest rating: {expected_ratings[1]}, but found: {test_result[1][1]}.'\n    learner_ids = [row[0] for row in test_result]  \n    unique_learner_ids = set(learner_ids)  \n    assert len(learner_ids) == len(unique_learner_ids), f\"Expected all learner_codes to be unique, but found duplicates. Total: {len(learner_ids)}, Unique: {len(unique_learner_ids)}.\"\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_239", "db_id": "formula_1", "query": "In the context of a Formula 1 racing database, a user wants to group rows with the same values in a specific column without disturbing the order after applying an ORDER BY clause. The user is working with a table that contains information about results, including race IDs, years, rounds, circuit IDs, names, dates, times, points, and the time taken. The user attempted to use a complex query involving DISTINCT, ROW_NUMBER(), and CASE statements to achieve this but encountered issues with the output format and grouping logic.", "issue_sql": ["SELECT DISTINCT tempId, pemId, time, rank, (CASE pointsno WHEN 1 THEN points ELSE points END ) AS points FROM (SELECT ROW_NUMBER() OVER(PARTITION BY points) AS pointsno, tempId, pemId, time, rank, points FROM (SELECT driverid AS tempId, driverid AS pemId, time, rank, points FROM results GROUP BY GROUPING SETS ((tempId, points), (tempId, pemId, time, rank))) AS b) AS s ORDER BY tempId, points ASC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT learners.learner_code,\n    CASE WHEN \"Language_Proficiency\" = 'Basic'\n        THEN '0'\n        WHEN \"Language_Proficiency\" = 'Intermediate'\n        THEN '1'\n        ELSE '2' END as language_proficiency_level,\n    AVG(\"Pre_Test_Score\") AS average_pre_test_score\n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female'\n        AND \"Language_Proficiency\" = CASE\n        WHEN \"Geographic_Location\" = 'Urban' THEN 'Advanced'\n        WHEN \"Geographic_Location\" = 'Rural' THEN 'Basic'\n        ELSE 'Intermediate' END\n    GROUP BY \"Language_Proficiency\", learners.learner_code\n    ORDER BY \"Language_Proficiency\" DESC, learners.learner_code"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least 1 row, but found no rows'\n    valid_proficiency_levels = {'0', '1', '2'}\n    assert all(str(row[1]) in valid_proficiency_levels for row in test_result), f\"All of the proficiency levels should be in {valid_proficiency_levels}\"\n    test_rural = execute_queries([\"\"\"\n    SELECT learners.learner_code,\n    0 as language_proficiency_level,\n    AVG(\"Pre_Test_Score\") AS average_pre_test_score \n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Rural' AND \"Language_Proficiency\" ='Basic'\n    GROUP BY learners.learner_code\n    ORDER BY learners.learner_code\"\"\"], db_name, conn)[0]\n    result_codes = set(row[0] for row in test_result)\n    rural_average_pre_test_scores = set(r[2] for r in test_rural)\n    result_average_pre_test_scores = set(row[2] for row in test_result)\n    assert rural_average_pre_test_scores.issubset(result_average_pre_test_scores), f'All of the average pre-test scores in test_rural should be in test_result'\n    all_in_result = execute_queries([\"\"\"\n    SELECT learners.learner_code\n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Rural' AND \"Language_Proficiency\" ='Basic'\n    GROUP BY learners.learner_code\n    UNION\n    SELECT learners.learner_code\n    FROM learners JOIN outcomes ON learners.learner_code = outcomes.learner_code\n    WHERE \"Engagement_History\" > 5 AND \"Gender\" = 'Female' AND \"Geographic_Location\" = 'Urban' AND \"Language_Proficiency\" ='Advanced'\n    GROUP BY learners.learner_code;\n    \"\"\"], db_name, conn)[0]\n    all_codes = set(row[0] for row in all_in_result)\n    assert all_codes == result_codes, 'All of the learner codes in test_rural should be in test_result'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_240", "db_id": "formula_1", "query": "I am developing a Formula 1 race results aggregator website, which includes:\n\n- Race results attached to drivers\n- Race results have points scores\n- A front page displaying popular race results\n\nThe issue is that sometimes the front page only shows results from very skillful drivers.\n\nI need a way to **limit** the number of drivers joined per fetch, to something small, so that the front page will have results from many drivers.\n\nFor simplicity's sake (disregarding my more complicated result ranking logic), the SQL is currently:\n\nsql\nselect * from results r\ninner join drivers c on r.driverid = c.driverid WHERE r.grid = XX \norder by r.points desc;\n\n\n. Note that XX represent a particular grid where we want to filter the result. Is there any way to limit the number of drivers results this fetch returns?", "issue_sql": ["select * from results r inner join drivers d on r.driverid = d.driverid where r.grid = 21 order by r.points desc;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH src(id,geom) as (values (1, 'linestring(0 0, 0 10)'::geometry), (2, 'linestring(0 10, 0 11)'::geometry), (3, 'linestring(1 1, 0 5)'::geometry), (4, 'linestring(1 1, 2 2)'::geometry)) SELECT a.id, st_asText(st_intersection(a.geom, b.geom)) FROM src AS a JOIN src AS b on st_intersects(a.geom, b.geom) WHERE a.id != b.id AND st_contains(a.geom, st_intersection(a.geom, b.geom));"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_241", "db_id": "erolp", "query": "In the context of the erolp database, we have two tables: customer_orders and updated_orders. The customer_orders table contains the initial orders placed by customers, while the updated_orders table contains modifications or new details for these orders. The task is to insert a new order into the customer_orders table with an ID of 1, where the name and title fields are populated with values from the updated_orders table if available, otherwise from the customer_orders table. The user attempted to use a LEFT OUTER JOIN to achieve this but only one row was inserted instead of two as expected.", "issue_sql": ["INSERT INTO customer_orders(name, title) SELECT COALESCE(uo.name, co.name), COALESCE(uo.title, co.title) FROM customer_orders co LEFT OUTER JOIN updated_orders uo ON uo.id = co.id"], "preprocess_sql": ["CREATE TABLE customer_orders (ID SERIAL NOT NULL, NAME TEXT NOT NULL, TITLE TEXT NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, order_status VARCHAR(50) DEFAULT 'pending', priority INTEGER DEFAULT 0, customer_email VARCHAR(255), total_amount NUMERIC(12, 2) DEFAULT 0.00, payment_method VARCHAR(100), shipping_address JSONB DEFAULT '{}'::jsonb, notes TEXT, is_expedited BOOLEAN DEFAULT FALSE, tracking_number VARCHAR(100), order_source VARCHAR(50) DEFAULT 'website');", "CREATE TABLE updated_orders (ID SERIAL NOT NULL, NAME TEXT NULL, TITLE TEXT NULL, modified_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, modification_reason TEXT, modified_by VARCHAR(100) DEFAULT 'system', version_number INTEGER DEFAULT 1, is_final BOOLEAN DEFAULT FALSE, approval_status VARCHAR(50) DEFAULT 'pending', change_summary JSONB DEFAULT '{}'::jsonb, previous_status VARCHAR(50), new_priority INTEGER, notification_sent BOOLEAN DEFAULT FALSE, approval_date DATE, metadata JSONB DEFAULT '{}'::jsonb);", "INSERT INTO customer_orders(NAME, TITLE, order_status, priority, customer_email, total_amount, payment_method, shipping_address, notes, is_expedited, tracking_number, order_source) VALUES ('test', 'test', 'confirmed', 1, 'customer@example.com', 99.99, 'credit_card', '{\"street\": \"123 Main St\", \"city\": \"Anytown\", \"zip\": \"12345\"}'::jsonb, 'Original test order', FALSE, 'TRK123456789', 'mobile_app');", "INSERT INTO updated_orders(NAME, TITLE, modification_reason, modified_by, version_number, is_final, approval_status, change_summary, previous_status, new_priority, notification_sent, approval_date, metadata) VALUES ('new_test', NULL, 'Customer requested name change', 'admin_user', 2, TRUE, 'approved', '{\"changed_fields\": [\"name\"], \"timestamp\": \"2023-05-15T14:30:00Z\"}'::jsonb, 'pending', 2, TRUE, '2023-05-16', '{\"ip_address\": \"192.168.1.1\", \"user_agent\": \"Mozilla/5.0\"}'::jsonb);"], "clean_up_sql": ["DROP TABLE IF EXISTS customer_orders; DROP TABLE IF EXISTS updated_orders;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT device_info::json ->> 'SerialNumber' AS \"SerialNumber\", (cto ->> 'ChannelId')::INT AS \"ChannelId\", cto ->> 'Name' AS \"ChannelName\" FROM device_details, json_array_elements(device_info::json ->'ChannelListDto') AS \"Channels\"(cto);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_242", "db_id": "superhero", "query": "We have a table that logs the performance of superheroes across different attributes on specific dates. The table includes the superhero's name, the date of the performance, the attribute tested, and the result of the test (PASS or FAIL). We want to transform this data into a format where each superhero's performance on different attributes for a specific date is shown in separate columns. Additionally, we want to see another format where the attributes are listed in alphabetical order with their results concatenated.", "issue_sql": ["SELECT superhero_name, performance_date, attribute_name, result FROM superhero_performance PIVOT(result FOR attribute_name IN (Strength, Speed, Intelligence))"], "preprocess_sql": ["CREATE EXTENSION IF NOT EXISTS tablefunc; CREATE TABLE superhero_performance (superhero_name text, performance_date date, attribute_name text, result text); INSERT INTO superhero_performance (superhero_name, performance_date, attribute_name, result) VALUES ('Superman', '2023-07-01', 'Strength', 'PASS'), ('Superman', '2023-07-01', 'Speed', 'PASS'), ('Superman', '2023-07-01', 'Intelligence', 'PASS'), ('Superman', '2023-07-02', 'Strength', 'FAIL'), ('Superman', '2023-07-02', 'Speed', 'FAIL'), ('Superman', '2023-07-02', 'Intelligence', 'FAIL'), ('Batman', '2023-07-01', 'Strength', 'PASS'), ('Batman', '2023-07-01', 'Speed', 'FAIL'), ('Batman', '2023-07-02', 'Strength', 'PASS'), ('Batman', '2023-07-02', 'Speed', 'PASS'); "], "clean_up_sql": ["DROP TABLE if EXISTS superhero_performance;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH start_ts AS (SELECT TIMESTAMP '2023-01-01 10:34:36' AS ts), end_ts AS (SELECT TIMESTAMP '2023-01-10 15:12:24' AS ts), weekends AS (SELECT ts.day, GREATEST(start_ts.ts, ts.day) AS overlap_start, LEAST(end_ts.ts, ts.day + interval '1 day') AS overlap_end FROM start_ts, end_ts, generate_series(date_trunc('day', start_ts.ts), date_trunc('day', end_ts.ts), interval '1 day') AS ts(day) WHERE EXTRACT(ISODOW FROM ts.day) IN (6, 7)), weekend_time AS (SELECT SUM(overlap_end - overlap_start) AS total_weekend FROM weekends WHERE overlap_start < overlap_end), work_duration AS (SELECT (end_ts.ts - start_ts.ts) - COALESCE((SELECT total_weekend FROM weekend_time), interval '0') AS duration FROM start_ts, end_ts) SELECT EXTRACT(DAY FROM duration) || ' days ' || EXTRACT(HOUR FROM duration) || ' hours ' || EXTRACT(MINUTE FROM duration) || ' minutes ' || ROUND(EXTRACT(SECOND FROM duration)) || ' seconds' AS time_diff FROM work_duration;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_243", "db_id": "thrombosis_prediction", "query": "I need to retrieve the data for each 'administrative' week of the current month from the laboratory table. An 'administrative' week is defined as a week starting from the first day of the month and ending on the next Sunday. For example, if the month starts on a Wednesday, the first week would be from that Wednesday to the following Sunday. I want to get the count of records for each of these weeks.", "issue_sql": ["SELECT COUNT(*) FROM laboratory WHERE date_part('year', date) = date_part('year', CURRENT_DATE) AND date_part('month', date) = date_part('month', CURRENT_DATE) AND date [I don't know what to put here];"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["WITH links AS (SELECT GREATEST(link.source_cluster, link.target_cluster) AS big, LEAST(link.source_cluster, link.target_cluster) AS smol, link.type AS type FROM link) SELECT l.cluster AS left_id, l.cluster_type AS left_type, l.cluster_label AS left_label, r.cluster AS right_id, r.cluster_type AS right_type, r.cluster_label AS right_label, COUNT(DISTINCT l.article) AS articles, COALESCE(ARRAY_AGG(DISTINCT links.type) FILTER (WHERE links.type IS NOT NULL), '{}') AS link_types FROM tag AS l JOIN tag AS r ON l.article = r.article AND l.cluster > r.cluster LEFT JOIN links ON l.cluster = links.big AND r.cluster = links.smol GROUP BY l.cluster, l.cluster_label, l.cluster_type, r.cluster, r.cluster_label, r.cluster_type ORDER BY COUNT(DISTINCT l.article) DESC, left_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_244", "db_id": "california_schools", "query": "I need to generate a report that shows the total number of schools that were active during each reporting date. The dataset includes the open and closed dates for each school. I want to see the total number of schools that were open on each reporting date. Here is how I need the data to look like:\n\n[Expected Output Table]\n\nMy original dataset looks like this (please see query): To calculate the number of schools active on a reporting date, I need to use the open and closed dates: if OpenDate <= reporting_date and ClosedDate > reporting_date then count as an active school.\n\nI was able to develop a script, but it only gives me the total number of schools for only one reporting date.\n\nsql\nselect '2022-10-31' reporting_date, count(case when OpenDate <= '2022-10-31' and ClosedDate > '2022-10-31' then cdscode end)\nfrom schools\n\n\nIs there a way to amend the code with cross-join or other workarounds to get the total schools per reporting date without doing many unions?", "issue_sql": ["WITH reporting_dates AS (SELECT generate_series('2000-01-01'::date, '2017-01-01'::date, '1 year'::interval) AS reporting_date) SELECT reporting_date, COUNT(CASE WHEN OpenDate > reporting_date AND (ClosedDate IS NULL OR ClosedDate <=reporting_date) THEN cdscode END) AS active_schools FROM reporting_dates LEFT JOIN schools ON true GROUP BY reporting_date ORDER BY reporting_date;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT i.country, o.name, o.city, o.established FROM public.ismember i INNER JOIN\npublic.organization o ON o.abbreviation = i.organization WHERE i.type = 'member'\nAND i.country = 'CI' AND i.organization IN (SELECT organization FROM public.ismember\nWHERE country = 'CI' AND type = 'member' ORDER BY organization DESC LIMIT 1)\nORDER BY o.established DESC LIMIT 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == 'World Trade Organization', f\"Expect to be 'World Trade Organization', but found {test_pred_query_result[0][1]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == 'World Trade Organization', f\"Expect to be 'World Trade Organization', but found {test_sol_query_result[0][1]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_245", "db_id": "student_club", "query": "In the student_club database, there is a table named `budget` which contains columns `budget_id`, `category`, `spent`, `remaining`, `amount`, `event_status`, and `link_to_event`. The table stores budget details for various events, including the amount spent, remaining budget, and the total amount allocated. The goal is to allocate a total budget of 500 to purchase as many food as possible, and with the remaining money, buy as many advertisement as possible. The user attempted to write a query to calculate the cumulative sum of the budget for these, but the query produced incorrect results. The user needs a corrected query using CTE and Window Function in PostgreSQL 9.6 to achieve the desired output for larger datasets.", "issue_sql": ["SELECT budget_id, category, amount, SUM(amount) OVER (PARTITION BY category ORDER BY amount) AS cum_amount FROM budget ORDER BY category DESC, amount;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH CTE_PUBLIC AS (SELECT \"Pre_Test_Score\", dense_rank() OVER (ORDER BY \"Pre_Test_Score\" DESC)\nas score_rank FROM outcomes AS outcm JOIN enrollment AS enrl ON outcm.learner_code = enrl.learner_code\nJOIN institutions AS inst ON enrl.institution_key = inst.institution_key WHERE inst.\"Institution_Type\" = 'Public'),\nCTE_PRIVATE AS (SELECT \"Pre_Test_Score\", dense_rank() OVER (ORDER BY \"Pre_Test_Score\" DESC) as score_rank\nFROM outcomes AS outcm JOIN enrollment AS enrl ON outcm.learner_code = enrl.learner_code JOIN institutions\nAS inst ON enrl.institution_key = inst.institution_key WHERE inst.\"Institution_Type\" = 'Private')\nSELECT AVG(public_score) - AVG(private_score) AS score_diff FROM (SELECT \"Pre_Test_Score\" AS public_score\nFROM CTE_PUBLIC WHERE score_rank = 1) AS public_top, (SELECT \"Pre_Test_Score\" AS private_score\nFROM CTE_PRIVATE WHERE score_rank = 1) AS private_top"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 0.0000000000000000, f\"Expect to be 0.0000000000000000, but found {test_pred_query_result[0][1]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 0.0000000000000000, f\"Expect to be 0.0000000000000000, but found {test_sol_query_result[0][1]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_246", "db_id": "financial", "query": "In the 'financial' database, there is a table named 'client' with a column district_id. The goal is to select 1000 clients where a maximum of 100 district_id=1. The user initially tried to achieve this by creating two separate queries and merging them, but encountered issues with the results. The user's approach was to first select 900 clients with district_id not being 1, and then select 100 clients with district_id being 1. However, this method did not ensure that the total number of selected clients would always be 1000, especially if there were fewer than 100 district_id=1 in the database. The user is seeking a single query solution to accurately select 1000 clients with the specified constraints.", "issue_sql": ["SELECT district_id FROM client WHERE district_id = 1 LIMIT 100;SELECT district_id FROM client WHERE district_id <> 1 LIMIT 900;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT regexp_replace(\"Content_Type\", '(?i)' || substr(\"Content_Type\", 1, 1), '', 'g')\nFROM educational_resources"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert test_pred_query_result[1][0] == 'ex', f\"Expect to be 'ex', but found {test_pred_query_result[1][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert test_sol_query_result[1][0] == 'ex', f\"Expect to be 'ex', but found {test_sol_query_result[1][0]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_247", "db_id": "financial", "query": "In the financial database, there is a need to update the 'type' column in the 'card' table using a SELECT statement that can return more than one value. If multiple values are returned, a second condition should be applied to determine which of those values is to be chosen. The scenario involves updating the 'type' of credit cards based on the 'disp_id' and 'client_id' from the 'disp' table, ensuring that if multiple 'disp_id' values match, the one associated with the smallest 'client_id' in the disp table is prioritized. The user needs a simple solution to update the table instead of using many SELECT statements.", "issue_sql": ["UPDATE card SET type = ( SELECT type, client_id FROM disp WHERE card.disp_id = disp.disp_id );"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT regexp_replace(regexp_replace(primary_pathology_histological_type, 'NOS$',\n'Not Otherwise Specified'), 'Adenocarcinoma', 'Adenoma Carcinoma') AS transformed_histological_type\nFROM pathology_and_surgery;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) > 0, f'Expect to have answer, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', f\"Expect to be 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', but found {test_pred_query_result[0][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expect to have answer, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', f\"Expect to be 'Esophagus Adenoma Carcinoma, Not Otherwise Specified', but found {test_sol_query_result[0][0]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_248", "db_id": "financial", "query": "In the financial database, we have two tables: `loan` and `card`. A loan might have an attached card on it, and vice versa. However, there is a restriction: if a loan is deleted, its attached card should also be deleted, but if a card is deleted, the loan should remain unaffected. The user attempted to implement this behavior using SQL constraints like `ON DELETE CASCADE` and `ON DELETE SET NULL`, but encountered issues. Below is the problematic SQL statement the user tried:", "issue_sql": ["CREATE TABLE card (card_id SERIAL PRIMARY KEY,loan_id INT UNIQUE,type TEXT NOT NULL,issued DATE NOT NULL,CONSTRAINT fk_loan_id FOREIGN KEY (loan_id) REFERENCES loan(loan_id) ON DELETE SET NULL);ALTER TABLE loan ADD CONSTRAINT fk_card_loan FOREIGN KEY (loan_id) REFERENCES card(loan_id) ON DELETE CASCADE;"], "preprocess_sql": ["DROP TABLE IF EXISTS card, loan;"], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT ROUND((SELECT COUNT(*) FROM sp_artists WHERE pop > 50)::decimal / NULLIF((SELECT COUNT(*) FROM sp_artists), 0), 3)::float;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) == 1, f'Expect to be 1, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][0] == 0.036, f\"Expect to be 0.036, but found {test_pred_query_result[0][0]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) == 1, f'Expect to be 1, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][0] == 0.036, f\"Expect to be 0.036, but found {test_sol_query_result[0][0]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_249", "db_id": "debit_card_specializing", "query": "In the context of managing transactions in the debit_card_specializing database, a user attempted to declare a local variable `value` with `RECORD[]` type within a DO statement to handle complex data operations involving multiple tables. The user's intention was to use this variable to store and manipulate records fetched from various tables such as `transactions_1k`, `customers`, `gasstations`, and `products`. However, the user encountered an error when trying to declare the variable as `RECORD[]`, which is not supported directly in PostgreSQL. The user's attempt is shown below:\n\nsql\nDO $$\nDECLARE\n  value RECORD[];\nBEGIN\nEND\n$$;\n\n\nThe error message received was:\n\n> ERROR:  variable \"value\" has pseudo-type record[]\n\nThe user successfully declared the variable with `RECORD` or `INT[]` type without error, as shown below:\n\nsql\nDO $$\nDECLARE\n  value RECORD;\nBEGIN\nEND\n$$;\n\n\nsql\nDO $$\nDECLARE\n  value INT[];\nBEGIN\nEND\n$$;\n\n\nThe user's question is: How can they declare `value` with `RECORD[]` type in this context?", "issue_sql": ["DO $$ DECLARE value RECORD[]; BEGIN SELECT t FROM transactions_1k t LIMIT 1 INTO value[1]; SELECT c FROM customers c LIMIT 1 INTO value[2]; RAISE NOTICE 'Transaction: %', value[1]; RAISE NOTICE 'Customer: %', value[2]; END $$;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT CASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:'\nTHEN NULL ELSE primary_pathology_neoplasm_histologic_grade END AS histologic_grade,\nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:'\nTHEN NULL ELSE primary_pathology_days_to_initial_pathologic_diagnosis END AS days_to_initial_diagnosis,\nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:'\nTHEN NULL ELSE primary_pathology_age_at_initial_pathologic_diagnosis END AS\nage_at_initial_diagnosis FROM pathology_and_surgery;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_pred_query_result) > 0, f'Expect to have answer, but found {len(test_pred_query_result)}'\n    assert test_pred_query_result[0][1] == None, f\"Expect to be None, but found {test_pred_query_result[0][1]}\"\n    assert test_pred_query_result[12][2] == 59, f\"Expect to be 59, but found {test_pred_query_result[12][2]}\"\n", "\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_sol_query_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert len(test_sol_query_result) > 0, f'Expect to have answer, but found {len(test_sol_query_result)}'\n    assert test_sol_query_result[0][1] == None, f\"Expect to be None, but found {test_sol_query_result[0][1]}\"\n    assert test_sol_query_result[12][2] == 59, f\"Expect to be 59, but found {test_sol_query_result[12][2]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_250", "db_id": "financial", "query": "I need to update the status of a loan in the financial database and determine the outcome of the update operation. The possible outcomes are: successful update, version conflict, or loan not found. The update should be performed in a single query. The loan table has columns loan_id, account_id, date, amount, duration, payments, and status. The update query should set the status to 'updated_status', update the date to 'new_date', and the amount to 'new_amount'. The update should only occur if the current status matches 'current_status'. Here is the problematic SQL query I tried:\n\nsql\nUPDATE loan l\nSET status = 'updated_status',\n    date = 'new_date',\n    amount = 'new_amount'\nWHERE l.loan_id = 'loan_id_value'\nAND l.status = 'current_status';\n\n\nThe issue is that I cannot determine the outcome of the update operation (successful, version conflict, or loan not found) in a single query.", "issue_sql": ["UPDATE loan l SET status = 'updated_status', date = 'new_date', amount = 'new_amount' WHERE l.loan_id = 'loan_id_value' AND l.status = 'current_status';"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["SELECT DISTINCT ON (alb, art, feat_arts)\n    alb,\n    art,\n    feat_arts,\n    FIRST_VALUE(start_date) OVER (PARTITION BY alb, art, feat_arts ORDER BY start_date) AS start_date,\n    LAST_VALUE(end_date) OVER (PARTITION BY alb, art, feat_arts ORDER BY start_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS end_date\n    FROM sp_album\n    ORDER BY alb, art, feat_arts, start_date DESC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    import json\n    from datetime import date\n    expected_result = [\n        (1, 100, json.loads('[]'), date(2023, 1, 1), date(2023, 1, 20)),\n        (1, 100, json.loads('[100]'), date(2023, 1, 21), None),\n        (2, 101, json.loads('[300]'), date(2023, 1, 1), date(2023, 1, 20)),\n        (3, 202, json.loads('[]'), date(2023, 1, 21), None)\n    ]\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == len(expected_result), f\"Expected {len(expected_result)} rows, but got {len(result)} rows\"\n    for res_row, exp_row in zip(test_result, expected_result):\n        assert res_row == exp_row, f\"Expected row {exp_row}, but got {res_row}\"\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_251", "db_id": "esophageal", "query": "\nIn the context of the 'esophageal' database, I have three different PostgreSQL queries: `getPatients`, `getDoctors`, and `getAppointments` for the homepage. I want to create a single query that combines these into a single object. My three simplified queries are as follows:\n\ngetPatients = SELECT * FROM patients;\ngetDoctors = SELECT * FROM doctors;\ngetAppointments = SELECT * FROM appointments;\n\nI attempted to combine these into a single query as follows:\n", "issue_sql": ["SELECT coalesce(_agg(patients), '[]'::) as patients, coalesce(_agg(doctors), '[]'::) as doctors, coalesce(_agg(appointments), '[]'::) as appointments FROM (SELECT * FROM patients) AS patients, (SELECT * FROM doctors) AS doctors, (SELECT * FROM appointments) AS appointments;"], "preprocess_sql": ["\nCREATE TABLE doctors (\n    doctor_id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    age INT,\n    gender VARCHAR(10),\n    department VARCHAR(50)\n);\n\nINSERT INTO doctors (name, age, gender, department) VALUES\n('Dr. Smith', 45, 'Male', 'Cardiology'),\n('Dr. Johnson', 38, 'Female', 'Neurology'),\n('Dr. Lee', 50, 'Male', 'Orthopedics'),\n('Dr. Davis', 42, 'Female', 'Pediatrics');\n                   \nCREATE TABLE appointments (\n    appointment_id SERIAL PRIMARY KEY,\n    doctor_id INT REFERENCES doctors(doctor_id),\n    appointment_date DATE,\n    location VARCHAR(100)\n);\n\nINSERT INTO appointments (doctor_id, appointment_date, location) VALUES\n(1, '2025-02-10', 'Room 101, Hospital A'),\n(2, '2025-02-12', 'Room 102, Hospital B'),\n(3, '2025-02-14', 'Room 103, Hospital C'),\n(4, '2025-02-16', 'Room 104, Hospital D');\n"], "clean_up_sql": ["DROP TABLE IF EXISTS doctors; DROP TABLE IF EXISTS appointments;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT p.patient_id, p.patient_barcode, a.address_id, a.country_of_procurement, a.state_province_of_procurement\n    FROM patients p\n    JOIN patient_addresses a USING (patient_id)\n    WHERE p.patient_id = 1\n    ORDER BY a.address_id DESC\n    LIMIT 1;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) == 1, f'Expected exactly 1 row, but found {len(test_result)} rows'\n    assert test_result[0][0] == 1, f'Expected patient_id to be 1, but found {test_result[0][0]}'\n    assert isinstance(test_result[0][1], str) and test_result[0][1].startswith('TCGA-2H-A9'), f'Expected patient_barcode to start with \"TCGA-2H-A9\", but found {test_result[0][1]}'\n    assert test_result[0][2] > 1, f'Expected address_id to be present and greater than 1, but found {test_result[0][2]}'\n    test_pred_query_result = execute_queries([\"SELECT country_of_procurement FROM (SELECT * FROM patient_addresses WHERE patient_id = 1 ORDER BY address_id DESC LIMIT 1) AS subquery;\"], db_name, conn)[0]; \n    assert test_result[0][3] == test_pred_query_result[0][0], f'Expected city_of_procurement to be {test_pred_query_result[0][0]}, but found {test_result[0][3]}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_252", "db_id": "esophageal", "query": "\nIn the esophageal database, there is a table named `patients_info` and another table named `appointments`. The `patients_info` table contains a column `general_info` of type `jsonb` which includes a field `accept_appointments`. The `appointments` table contains a column `patient_id` linking to the `patients_info` table and a column `hide_in_online_scheduling` of type `boolean`. Each patient can have multiple appointments. The task is to update the `accept_appointments` field in the `general_info` column of the `patients_info` table to `FALSE` for those patients who only have appointments where `hide_in_online_scheduling` is `TRUE`.\n", "issue_sql": ["UPDATE patients_info\nSET general_info = jsonb_set(general_info, '{accept_appointments}', '\"false\"');"], "preprocess_sql": ["\nCREATE TABLE patients_info (id uuid PRIMARY KEY, general_info jsonb); CREATE TABLE appointments (id uuid PRIMARY KEY, patient_id uuid REFERENCES patients_info(id), hide_in_online_scheduling boolean);\n\nINSERT INTO patients_info (id, general_info) VALUES\n('a8a7f85e-6d45-4a53-8e38-3156c3f1a8f1', '{\"name\": \"John Doe\", \"age\": 30, \"gender\": \"Male\", \"medical_history\": \"None\", \"accept_appointments\": true}'),\n('b09a2dbf-943b-48de-b7cf-507f67f1d8f5', '{\"name\": \"Jane Smith\", \"age\": 25, \"gender\": \"Female\", \"medical_history\": \"Asthma\", \"accept_appointments\": true}'),\n('c57e1f8b-0f60-475b-b1fa-8c4e2ab9e2db', '{\"name\": \"Alice Johnson\", \"age\": 40, \"gender\": \"Female\", \"medical_history\": \"Hypertension\", \"accept_appointments\": true}');\n\nINSERT INTO appointments (id, patient_id, hide_in_online_scheduling) VALUES\n('f7a4c72d-dc80-4a27-a7c4-3e755ecf4fa1', 'a8a7f85e-6d45-4a53-8e38-3156c3f1a8f1', TRUE),\n('b68a99fb-e1b8-457a-824b-cbb7de4b5f49', 'a8a7f85e-6d45-4a53-8e38-3156c3f1a8f1', TRUE),\n('f830ad12-9fa0-4647-bc9e-94cfb1cc7d50', 'b09a2dbf-943b-48de-b7cf-507f67f1d8f5', FALSE),\n('dc0b8b59-c7f1-4e8b-9330-f9c3a29ab271', 'b09a2dbf-943b-48de-b7cf-507f67f1d8f5', TRUE),\n('fb8e4f76-b875-4623-a3e1-1bc3ed73694e', 'c57e1f8b-0f60-475b-b1fa-8c4e2ab9e2db', TRUE);\n"], "clean_up_sql": ["DROP TABLE appointments; DROP TABLE patients_info; "], "category": "Management", "efficiency": false, "sol_sql": ["WITH union_table as(\n    SELECT l.learner_code, l.\"Gender\", r.resource_key, 'Regular Feedback' as FeedbackType, r.feedback as UserFeedback\n    FROM learners l\n    INNER JOIN resource_usage r ON l.learner_code = r.learner_code\n    UNION ALL\n    SELECT l.learner_code, l.\"Gender\", 0 as resource_key, 'Synthetic Feedback' as FeedbackType,\n    CASE WHEN o.\"Learner_Satisfaction_Score\" < 3\n    THEN 'Negative' ELSE 'Positive' END as UserFeedback\n    FROM learners l\n    INNER JOIN outcomes o ON l.learner_code = o.learner_code\n    )\n    SELECT *\n    FROM union_table\n    WHERE UserFeedback = ANY(ARRAY['Negative']);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'The query result should have at least one row.'\n    assert all(len(row) == 5 for row in test_result), 'Each row in the query result should have 5 columns.'\n    assert all(row[3] in ('Regular Feedback', 'Synthetic Feedback') for row in test_result), 'FeedbackType should be either Regular Feedback or Synthetic Feedback in every row.'\n    Learner_Satisfaction = execute_queries(['SELECT learner_code FROM outcomes WHERE \"Learner_Satisfaction_Score\" < 3;'], db_name, conn)[0]\n    learner_satisfaction_array = [item[0] for i, item in enumerate(Learner_Satisfaction) if i < 5661]    \n    synthetic_case_code = [row[0] for row in test_result if row[3] == 'Synthetic Feedback'] \n    Learner_Satisfaction_set = set(learner_satisfaction_array)\n    synthetic_case_code_set = set(synthetic_case_code)\n    assert synthetic_case_code_set.issubset(Learner_Satisfaction_set), 'Some synthetic case codes are not in Learner Satisfaction'\n    assert Learner_Satisfaction_set.issubset(synthetic_case_code_set), 'Some learner satisfaction codes are not in synthetic case codes'\n    feedback_filter = ('Negative')\n    filtered_result = [row for row in test_result if row[4] in feedback_filter]\n    assert len(filtered_result) == len(test_result), 'All rows should match the feedback filter condition.'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_253", "db_id": "toxicology", "query": "We have a transaction history table that records the buying and selling of molecules in our toxicology research lab. Each transaction is recorded with a unique transaction ID, the molecule ID, the date of the transaction, whether it was a buy or sell, the number of molecules, and the total USD value of the transaction. For tax reporting purposes, we need to match each sell transaction with the corresponding buy transactions, allocating the shares sold from the earliest buy transactions first. The result should include the molecule ID, the buy date, the sell date, the number of molecules sold, the total USD value of the molecules bought, and the total USD value of the molecules sold. For example, if we have the following transactions:\n\n|transaction_id | molecule_id | date       | sell | molecules | usd_total|\n|-|-|-|-|-|-|\n|       1 |        1 | 2021-01-01 |    0 |      2 |    100.00|\n|       2 |        1 | 2021-01-02 |    0 |      2 |    120.00|\n|       3 |        1 | 2021-01-03 |    1 |      3 |    300.00|\n|       4 |        1 | 2021-01-04 |    1 |      1 |    150.00|\n\nThe expected result should be:\n\n|molecule_id | buy_date  | sell_date | molecules | buy_usd_total | sell_usd_total|\n|-|-|-|-|-|-|\n|       1 | 2021-01-01 | 2021-01-03 |      2 |      100.00 |         200.00|\n|       1 | 2021-01-02 | 2021-01-03 |      1 |       60.00 |         100.00|\n|       1 | 2021-01-02 | 2021-01-04 |      1 |       60.00 |         150.00|\n\nIs it possible to achieve this with SQL? I've tried to wrap my head around it, but keeping track of the remaining molecules from the buy transactions is difficult. Should I push forward with SQL or go with an iterative approach in Python?", "issue_sql": ["SELECT b.molecule_id, b.date AS buy_date, s.date AS sell_date, s.molecules, b.usd_total AS buy_usd_total, s.usd_total AS sell_usd_total FROM transaction b JOIN transaction s ON b.molecule_id = s.molecule_id WHERE b.sell = 0 AND s.sell = 1 ORDER BY b.date, s.date"], "preprocess_sql": ["CREATE TABLE transaction ( transaction_id INT PRIMARY KEY, molecule_id INT NOT NULL, date DATE NOT NULL, sell BOOLEAN NOT NULL, molecules INT NOT NULL, usd_total DECIMAL(10, 2) NOT NULL );", "INSERT INTO transaction (transaction_id, molecule_id, date, sell, molecules, usd_total) VALUES (1, 1, '2021-01-01', FALSE, 2, 100.00), (2, 1, '2021-01-02', FALSE, 2, 120.00), (3, 1, '2021-01-03', TRUE, 3, 300.00), (4, 1, '2021-01-04', TRUE, 1, 150.00);"], "clean_up_sql": ["DROP TABLE transaction;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT *\n    FROM city\n    ORDER BY\n    CASE WHEN name ~ '^[A-Za-z]+' THEN 0 ELSE 1 END ASC,\n    name,\n    COALESCE(SUBSTRING(name FROM '^[A-Za-z]+'), ''),\n    COALESCE(SUBSTRING(name FROM '(?<=-)[0-9]+')::INTEGER, 0),\n    COALESCE(SUBSTRING(name FROM '(?<=\\()[0-9]+')::BIGINT, 0),\n    population;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    from decimal import Decimal\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    expected_result = [\n        ('Aachen', 'D', 'Nordrhein-Westfalen', Decimal('236420'), Decimal('50.78'), Decimal('6.08'), Decimal('173')),\n        ('Aachen-1', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-1(1)', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-1(2)', 'D', 'Nordrhein-Westfalen', None, None, None, None),\n        ('Aachen-2', 'D', 'Nordrhein-Westfalen', None, None, None, None)\n    ]\n    subset_result = test_result[0:5]\n    assert len(test_result) == execute_queries(['SELECT COUNT(*) FROM city;'], db_name, conn)[0][0][0], f'Expected number of rows to match city count, but found {len(test_result)} rows'\n    assert subset_result == expected_result, f'Expected {expected_result} but got {subset_result}'\n    first_letter = execute_queries([\"SELECT name FROM city ORDER BY CASE WHEN name ~ '^[A-Za-z]' THEN 0 ELSE 1 END ASC, name;\"], db_name, conn)[0]\n    first_letter_array = [item[0][0] for item in first_letter]\n    first_letter_result = [row[0][0] for row in test_result]\n    assert first_letter_array == first_letter_result, f'Expected {first_letter} but got {first_letter_result}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_254", "db_id": "superhero", "query": "I am new to SQL and want to execute a query with joins. I noticed that when I have 2 rows in my table hero_power then I get doubled the same rows. So I have 2 rows but I get 4. If I have 4 rows in hero_power table then I get 16 rows so it shows me the duplicated rows. What I am doing wrong?", "issue_sql": ["SELECT s.superhero_name, sp.power_name FROM superhero s INNER JOIN hero_power hp ON hp.hero_id = s.id INNER JOIN superpower sp ON sp.id = hp.power_id WHERE s.id = 1"], "preprocess_sql": ["ALTER TABLE hero_power ADD COLUMN power_on boolean default false;", "INSERT INTO hero_power (hero_id, power_id, power_on) VALUES (1, 1, TRUE);"], "clean_up_sql": ["ALTER TABLE hero_power DROP COLUMN power_on;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT c.name, c.code,\n    array_agg(cn.othername) filter (where cn.othername is not null) AS alternative_names\n    FROM country c\n    LEFT JOIN countryothername cn ON c.code = cn.country\n    GROUP BY c.name, c.code\n    ORDER BY c.name ASC"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    countries_with_alternative_names = execute_queries([\"SELECT DISTINCT country FROM countryothername;\"], db_name, conn)[0]\n    expected_countries = {row[0] for row in countries_with_alternative_names}\n    expected_countries_set = set(expected_countries)\n    alternative_countries = {row[1] for row in test_result if row[2] is not None}\n    alternative_countries_set = set(alternative_countries)\n    assert alternative_countries_set.issubset(expected_countries_set), f'Expected countries with alternative names: {expected_countries}, but found: {alternative_countries}'\n    countries_without_alternative_names = execute_queries([\"SELECT c.code FROM country c LEFT JOIN countryothername cn ON c.code = cn.country WHERE cn.country IS NULL;\"], db_name, conn)[0]\n    print(countries_without_alternative_names)\n    expected_null_countries = {row[0] for row in countries_without_alternative_names}\n    null_name_countries = {row[1] for row in test_result if row[2] is None}\n    expected_null_countries_set = set(expected_null_countries)\n    null_name_countries_set = set(null_name_countries)\n    assert null_name_countries_set.issubset(expected_null_countries_set), f'Expected countries without alternative names: {expected_countries}, but found: {null_name_countries}'\n    assert len(test_result) == execute_queries([\"SELECT COUNT(*) FROM country;\"], db_name, conn)[0][0][0], f'Expected number of rows to be equal to the number of countries'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_255", "db_id": "erolp", "query": "In the erolp database, we have a scheduling application for a local community center where each scheduling block is defined in two-hour increments. The schedule_blocks table contains entries for each user's availability throughout the week. Currently, when querying for a user's availability over the next two months, the query only returns the current day and seven-day increments, missing other days of the week.", "issue_sql": ["WITH RECURSIVE weekdays AS ( SELECT generate_series(0, 60) AS offset ), dates AS ( SELECT CURRENT_DATE + (w.offset || ' days')::interval AS date, EXTRACT(ISODOW FROM CURRENT_DATE + (w.offset || ' days')::interval) AS day_of_week FROM weekdays w WHERE EXTRACT(ISODOW FROM CURRENT_DATE + (w.offset || ' days')::interval) IN (1, 2, 3, 4, 5, 6, 7) ), schedule_blocks_with_dates AS ( SELECT sb.*, d.date AS block_date FROM schedule_blocks sb JOIN dates d ON sb.day_of_week ILIKE to_char(d.date, 'Day') WHERE sb.is_available = TRUE AND d.date >= CURRENT_DATE AND d.date <= CURRENT_DATE + INTERVAL '2 months' ) SELECT block_id, user_id, block_date AS date, start_time, end_time FROM schedule_blocks_with_dates ORDER BY date;"], "preprocess_sql": ["CREATE TABLE users (user_id SERIAL PRIMARY KEY);", "INSERT INTO users (user_id) VALUES (1), (2), (3), (4)", "CREATE TABLE IF NOT EXISTS schedule_blocks ( block_id SERIAL PRIMARY KEY, user_id INT NOT NULL, day_of_week VARCHAR(255) NOT NULL, start_time TIME NOT NULL, end_time TIME NOT NULL, is_available BOOLEAN NOT NULL DEFAULT TRUE, CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(user_id));", "INSERT INTO schedule_blocks (user_id, day_of_week, is_available, start_time, end_time) VALUES (1, 'Monday', TRUE, '08:00:00', '10:00:00'), (1, 'Tuesday', TRUE, '10:00:00', '12:00:00'), (1, 'Wednesday', TRUE, '12:00:00', '14:00:00'), (1, 'Thursday', TRUE, '14:00:00', '16:00:00'), (1, 'Friday', TRUE, '16:00:00', '18:00:00'), (1, 'Saturday', TRUE, '08:00:00', '10:00:00'), (1, 'Sunday', TRUE, '10:00:00', '12:00:00'), (2, 'Monday', TRUE, '10:00:00', '12:00:00'), (2, 'Tuesday', TRUE, '12:00:00', '14:00:00'), (2, 'Wednesday', TRUE, '14:00:00', '16:00:00'), (2, 'Thursday', TRUE, '08:00:00', '10:00:00'), (2, 'Friday', TRUE, '10:00:00', '12:00:00'), (2, 'Saturday', TRUE, '12:00:00', '14:00:00'), (2, 'Sunday', TRUE, '14:00:00', '16:00:00'), (3, 'Monday', TRUE, '12:00:00', '14:00:00'), (3, 'Tuesday', TRUE, '14:00:00', '16:00:00'), (3, 'Wednesday', TRUE, '08:00:00', '10:00:00'), (3, 'Thursday', TRUE, '10:00:00', '12:00:00'), (3, 'Friday', TRUE, '12:00:00', '14:00:00'), (3, 'Saturday', TRUE, '14:00:00', '16:00:00'), (3, 'Sunday', TRUE, '08:00:00', '10:00:00'), (4, 'Monday', TRUE, '14:00:00', '16:00:00'), (4, 'Tuesday', TRUE, '08:00:00', '10:00:00'), (4, 'Wednesday', TRUE, '10:00:00', '12:00:00'), (4, 'Thursday', TRUE, '12:00:00', '14:00:00'), (4, 'Friday', TRUE, '14:00:00', '16:00:00'), (4, 'Saturday', TRUE, '16:00:00', '18:00:00'), (4, 'Sunday', TRUE, '18:00:00', '20:00:00'); INSERT INTO schedule_blocks (user_id, day_of_week, is_available, start_time, end_time) VALUES (1, 'Monday', TRUE, '10:30:00', '12:30:00'), (1, 'Wednesday', TRUE, '16:00:00', '18:00:00'), (1, 'Friday', TRUE, '18:30:00', '20:30:00'), (2, 'Tuesday', TRUE, '16:00:00', '18:00:00'), (2, 'Thursday', TRUE, '10:30:00', '12:30:00'), (2, 'Sunday', TRUE, '16:30:00', '18:30:00'), (3, 'Monday', TRUE, '14:30:00', '16:30:00'), (3, 'Wednesday', TRUE, '10:30:00', '12:30:00'), (3, 'Friday', TRUE, '14:30:00', '16:30:00'), (4, 'Tuesday', TRUE, '10:30:00', '12:30:00'), (4, 'Thursday', TRUE, '14:30:00', '16:30:00'), (4, 'Saturday', TRUE, '10:00:00', '12:00:00');"], "clean_up_sql": ["DROP TABLE IF EXISTS schedule_blocks;", "DROP TABLE IF EXISTS users"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT ol.institution_name\nFROM institution_location ol\nJOIN learner_institution_location l ON ST_DWithin(ol.geom, l.geom, 1);"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_pred_query_result_1 = perform_query_on_postgresql_databases(\"SELECT COUNT(ol.institution_name) FROM institution_location ol JOIN learner_institution_location l ON ST_DWithin(ol.geom, l.geom, 1);\", db_name)[0][0]\n    assert len(pred_query_result) == test_pred_query_result_1[0], f'Expected {test_pred_query_result_1} neighboring institutions, but found {len(pred_query_result)}.'\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_256", "db_id": "european_football_2", "query": "A data analyst is tasked with analyzing the cumulative performance of teams over time based on their attributes. They need to calculate the cumulative sum of the 'buildupplayspeed' attribute for each team over the recorded dates. The analyst attempts to use a subquery in the SELECT clause to achieve this but encounters unexpected results. The analyst wants to understand why the subquery approach fails and how to correctly calculate the cumulative sum using window functions.", "issue_sql": ["select id, (select sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as a), sum(buildupplayspeed) over (ROWS UNBOUNDED PRECEDING) as b from team_attributes limit 10"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["select tissue_source_site,\n        count(*) cnt_total,\n        count(*) filter(where informed_consent_verified = TRUE) cnt_processed,\n        round(count(*) FILTER (WHERE informed_consent_verified = TRUE) * 100.0 / count(*), 2) AS percent\n    from patients\n    group by tissue_source_site\n    ORDER BY tissue_source_site;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    test_result = execute_queries(pred_sqls, db_name, conn)[0]\n    assert len(test_result) > 0, 'Expected at least one row in the result'\n    for row in test_result: assert type(row[0]) is str and type(row[1]) is int and type(row[2]) is int, 'Expected columns: str, int, int'\n    assert all(row[3] == 100.00 for row in test_result if row[1] == row[2]), 'For sites with eqaul total count and consent count, the percentage should be 100'\n    assert sum(1 for row in test_result if row[1] == row[2]) == len(test_result)-1, 'Expected all sites to have equal total and consent count except for the fisrt row'\n    first_row = test_result[0]\n    assert first_row[0] == '2H' and first_row[1] == 240 and first_row[2] == 230, 'Expected first row to be 2H, 240, 230'\n    assert str(first_row[3]) == '95.83', f'Expected first row percentage to be 95.83, but fount {first_row[3]}'\n\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_257", "db_id": "erolp", "query": "I'm trying to create a view in my `erolp` database schema, which will provide summary statistics across multiple categories. The idea is to give an 'overview' view that aggregates data from several tables. Specifically, I want to create a view named `overview` that contains the count of records from three different tables, such as the number of learners in the `learners` table, the number of institutions in the `institutions` table, and the number of curricula in the `curricula` table. Ideally, I want these statistics in one single result set. However, the current implementation using the query below doesn't work correctly, resulting in errors. I don't mind if they come in separate rows or columns, as long as all results are returned in one single view. Could you help me fix it?\n\nsql\nCREATE VIEW overview AS\n  SELECT count(*) AS learners_count FROM learners,\n  SELECT count(*) AS institutions_count FROM institutions,\n  SELECT count(*) AS curricula_count FROM curricula;\n", "issue_sql": ["CREATE VIEW overview AS SELECT count(*) AS learners_count FROM learners, SELECT count(*) AS institutions_count FROM institutions, SELECT count(*) AS curricula_count FROM curricula"], "preprocess_sql": [], "clean_up_sql": [], "category": "Management", "efficiency": false, "sol_sql": ["WITH sales AS ( SELECT \"gasstationid\" AS \"GasstationId\", \"customerid\" AS \"CustomerId\", \"date\" AS \"SaleDate\", \"amount\" AS \"Amount\" FROM \"transactions_1k\" ), initial_purchase AS ( SELECT \"CustomerId\", MIN(CAST(\"SaleDate\" AS date)) AS \"FirstPurchaseDate\" FROM sales GROUP BY \"CustomerId\" ), customer_wages AS ( SELECT i.\"CustomerId\", s.* FROM sales s JOIN initial_purchase i ON s.\"CustomerId\" = i.\"CustomerId\" WHERE s.\"SaleDate\" >= i.\"FirstPurchaseDate\" ORDER BY i.\"CustomerId\" DESC ) SELECT * FROM customer_wages"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_258", "db_id": "esophageal", "query": "In a healthcare analytics scenario, you are tasked with determining the lowest Karnofsky Performance Score recorded for each patient over follow-up visits, focusing on patients who have verified informed consent. Here's the SQL query attempted: [User Query: I have this data]: patient_id, primary_pathology_karnofsky_performance_score. I want to calculate the minimum performance score for patients where informed_consent_verified is 'True'. Here is the SQL I used to find the minimum Karnofsky Performance Score for each patient: sql SELECT patients.patient_id, demographics.height, treatment_and_followup.primary_pathology_karnofsky_performance_score, MIN(primary_pathology_karnofsky_performance_score) AS min_performance_score FROM patients JOIN treatment_and_followup ON patients.patient_id = treatment_and_followup.patient_id JOIN demographics ON patients.patient_id = demographics.patient_id WHERE informed_consent_verified = TRUE GROUP BY patients.patient_id;  What might be going wrong?", "issue_sql": ["SELECT patients.patient_id, demographics.height, treatment_and_followup.primary_pathology_karnofsky_performance_score, MIN(primary_pathology_karnofsky_performance_score) AS min_performance_score FROM patients JOIN treatment_and_followup ON patients.patient_id = treatment_and_followup.patient_id JOIN demographics ON patients.patient_id = demographics.patient_id WHERE informed_consent_verified = TRUE GROUP BY patients.patient_id;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["DO $$ DECLARE ddlsql TEXT; BEGIN FOR ddlsql IN (SELECT 'ALTER TABLE ' || quote_ident(c.table_schema) || '.' || quote_ident(c.table_name) || ' RENAME COLUMN \"' || c.column_name || '\" TO ' || quote_ident(lower(c.column_name)) || ';' FROM information_schema.columns As c WHERE c.table_schema = 'public' AND c.column_name <> lower(c.column_name)) LOOP EXECUTE ddlsql; END LOOP; END $$;"], "test_cases": ["def test_case(pred_sqls, sol_sqls, db_name, conn):\n    column_names = execute_queries([\"SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'frpm' ORDER BY ordinal_position;\"], db_name, conn)[0]\n    assert column_names[0][0] == 'cdscode', f\"Expected the first column is 'cdscode', but found {column_names[0][0]}\"\n    assert column_names[1][0] == 'academic year', f\"Expected the first column is 'academic year', but found {column_names[1][0]}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_259", "db_id": "erolp", "query": "There is a database named erolp, which contains a table called performance_predictions with columns prediction_code, date_recorded, and Performance_Prediction. The user wants to group the Performance_Prediction values by cumulative sum in sequential order, such that the total sum within each group does not exceed 200. The output should include the group number and the cumulative sum for each group.", "issue_sql": ["WITH RECURSIVE A(GroupNum, n, RollingSum, id) AS (\n    SELECT 1, Performance_Prediction, Performance_Prediction, prediction_code\n    FROM performance_predictions\n    ORDER BY prediction_code ASC\n    LIMIT 1\n    UNION ALL\n    SELECT\n        CASE\n            WHEN RollingSum + P.Performance_Prediction > 200\n            THEN GroupNum + 1\n            ELSE GroupNum\n        END,\n        P.Performance_Prediction,\n        CASE\n            WHEN RollingSum + P.Performance_Prediction > 200\n            THEN P.Performance_Prediction\n            ELSE RollingSum + P.Performance_Prediction\n        END,\n        P.prediction_code\n    FROM A\n    JOIN performance_predictions AS P ON A.id + 1 = P.prediction_code\n)\nSELECT\n    GroupNum,\n    n,\n    SUM(n) OVER (PARTITION BY GroupNum) AS group_sum\nFROM A\nORDER BY GroupNum, n;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT product_id FROM (SELECT product_id, MIN(is_searchable::INT) OVER() AS minIsSearchable FROM product WHERE product_id IN (101, 103)) AS cte WHERE minIsSearchable = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls_result = execute_queries(pred_sqls, db_name, conn)[0]\n    sol_sqls_result = execute_queries(sol_sqls, db_name, conn)[0]\n    assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}.\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_260", "db_id": "debit_card_specializing", "query": "In the debit_card_specializing database, there is a table named `transactions_1k` that records various transactions made by customers. Each transaction is uniquely identified by `TransactionID`, and includes details such as `Date`, `Time`, `CustomerID`, `CardID`, `GasStationID`, `ProductID`, `Amount`, and `Price`. The goal is to create a new table named `transaction_output` that includes all the columns from `transactions_1k`, plus an additional column `transaction_baseline` which should be set to 1 if the transaction's `Date` falls after '2012-08-25' and the `Amount` is greater than 0, and 0 otherwise. However, the user encountered a SQL syntax error.", "issue_sql": ["SELECT\n    TransactionID,\n    Date,\n    Time,\n    CustomerID,\n    CardID,\n    GasStationID,\n    ProductID,\n    Amount,\n    Price,\n    CASE\n        WHEN (Date >= '2012-08-25'::date) THEN 1\n        ELSE 0\n    WHERE Amount > 0\n    END AS transaction_baseline\nFROM transactions_1k"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT * FROM orders WHERE customer_id = 1 OR product_id = 'P202' ORDER BY RANK() OVER(ORDER BY CASE WHEN customer_id = 1 THEN 1 ELSE 2 END) FETCH FIRST ROW WITH TIES;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_261", "db_id": "financial", "query": "\nIn the financial database, we have a scenario where we need to fetch account details \nalong with their associated loans in a single query. The user initially tried to achieve this by \njoining the `account` and `loan` tables directly, but this approach didn't yield the desired -like \noutput structure. The user's goal is to get an output similar to the input , where each account is \naccompanied by its respective loans, efficiently in one query. The user is aware that storing loans \nas B in the `account` table could be a last resort, but they prefer a solution that allows for easier \nquerying and joins.\n", "issue_sql": ["SELECT a.*, l.* FROM account a JOIN loan l ON a.account_id = l.account_id WHERE a.account_id = 1;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH cte_dates AS (SELECT DISTINCT transaction_date AS \"date\" FROM sales_log), cte_names AS (SELECT DISTINCT salesperson_name AS \"name\" FROM sales_log) SELECT cte_dates.date, cte_names.name FROM cte_dates CROSS JOIN cte_names LEFT JOIN sales_log ON cte_dates.date = sales_log.transaction_date AND cte_names.name = sales_log.salesperson_name WHERE sales_log.amount IS NULL;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_262", "db_id": "financial", "query": "\nIn the financial database, we have a table named 'client' that stores information about \nclients, including their unique client_id, gender, birth_date, and district_id. Another table named \n'account' stores information about accounts, including account_id, district_id, frequency, and date. \nWe need to identify clients who are likely to be children based on their age difference with other \nclients in the same district, assuming a parent-child relationship requires at least a 16-year age \ndifference. The goal is to perform a self-join on the 'client' table but only within the same district \nto find potential children. The expected output should be the client_id of the children, ordered by client_id.\n", "issue_sql": ["SELECT DISTINCT A.client_id AS child FROM client A, client B\nWHERE A.birth_date + INTERVAL '16 years' < B.birth_date;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH ranked_items AS (SELECT m.*, ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY id DESC) AS rn, LAG(price,1) OVER (PARTITION BY product_id ORDER BY id ) as previous_price FROM ProductPrice AS m) SELECT p.product_id, p.product_name FROM Product p JOIN ranked_items r ON p.product_id = r.product_id WHERE r.rn = 1 AND price < previous_price"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_263", "db_id": "debit_card_specializing", "query": "\nIn the financial database, we have a table named 'client' that stores information about \nclients, including their unique client_id, gender, birth_date, and district_id. Another table named \n'account' stores information about accounts, including account_id, district_id, frequency, and date. \nWe need to identify clients who are likely to be children based on their age difference with other \nclients in the same district, assuming a parent-child relationship requires at least a 16-year age \ndifference. The goal is to perform a self-join on the 'client' table but only within the same district \nto find potential children. The expected output should be the client_id of the children, ordered by client_id.\n", "issue_sql": ["SELECT g.GasStationID FROM transactions_1k t JOIN gasstations g\nON t.GasStationID = g.GasStationID GROUP BY g.GasStationID\nHAVING SUM(t.Amount * t.Price) / SUM(t.Amount * t.Price) OVER (PARTITION BY t.CustomerID) >= 0.7"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT cd.customer_id, sal.sal_cnt as total_sales_ctr_id, sal.tot_amount as total_sales_amount, com.eml_cnt as total_email_ctr_id, fb.fb_cnt as total_fb_ctr_id, fb.pcnt as total_positive_fb, fb.ncnt as total_negative_fb FROM customer_details cd LEFT JOIN (SELECT customer_id, SUM(amount) as tot_amount, count(*) as sal_cnt FROM sales GROUP BY customer_id) sal ON cd.customer_id = sal.customer_id LEFT JOIN (SELECT customer_id, count(*) as eml_cnt from communications group by customer_id) com on cd.customer_id = com.customer_id LEFT JOIN (SELECT customer_id, COUNT(*) as fb_cnt, count(*) filter (where feedback_type = 'positive') as pcnt, count(*) filter (where feedback_type = 'negative') as ncnt from feedback group by customer_id) fb ON cd.customer_id = fb.customer_id;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_264", "db_id": "financial", "query": "\nIn the financial database, I am trying to analyze the distribution of loan amounts based on \nthe type of credit card issued to the clients. Specifically, I want to categorize the loans into \ntwo groups: those issued to clients with 'gold' credit cards and those with 'classic' or 'junior' \ncredit cards. I then want to count the number of loans in each category. My approach involves using \na CASE WHEN statement in the SELECT clause to create a new column 'card_type_group' that categorizes \nthe loans, and then grouping the results by this new column. However, the SQL statement cannot produce the \ncorrect answer as I expected. Here is the problematic SQL statement I used:\n", "issue_sql": ["SELECT CASE WHEN c.type = 'gold' THEN 'Gold' ELSE 'Non-Gold'\nEND AS card_type_group, COUNT(l.loan_id) AS loan_count\nFROM loan l\nJOIN disp d ON l.account_id = d.account_id\nJOIN card c ON d.disp_id = c.disp_id\nGROUP BY c.type"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["CREATE OR REPLACE FUNCTION fn_concat(first_name VARCHAR, last_name VARCHAR) RETURNS VARCHAR AS $$ BEGIN RETURN first_name || ' ' || last_name; END; $$ LANGUAGE plpgsql;", "SELECT *, fn_concat(f_name, l_name) AS full_name FROM cust;"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_265", "db_id": "student_club", "query": "\nIn the context of the student_club database, I have a table that records the attendance \nof members at various events. I want to analyze the attendance data to find out the top 2 events \nper member and the top 1 member per event, based on the count of attendances. Here's the SQL query \nI attempted, but it doesn't produce the expected results:\n", "issue_sql": ["SELECT link_to_member, link_to_event, count(1) AS total FROM attendance\nGROUP BY GROUPING SETS ((link_to_member), (link_to_member, link_to_event))\nORDER BY max(count(1)) over (partition by link_to_member) desc, max(count(1))\nover (partition by link_to_member,link_to_event) desc, count(1) desc;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT * FROM orders o CROSS JOIN LATERAL regexp_split_to_table (o.delivery_zones, ',') AS z WHERE CASE WHEN strpos (z, '-') > 0 THEN '10015' BETWEEN split_part (z, '-', 1) AND split_part (z, '-', 2) ELSE z = '10015' END"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_266", "db_id": "debit_card_specializing", "query": "\nIn the context of the student_club database, I have a table that records the attendance \nof members at various events. I want to analyze the attendance data to find out the top 2 events \nper member and the top 1 member per event, based on the count of attendances. Here's the SQL query \nI attempted, but it doesn't produce the expected results:\n", "issue_sql": ["SELECT DISTINCT ON (CustomerID) * FROM transactions_1k ORDER BY Date DESC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT e.event_id FROM event AS e LEFT JOIN attendance AS a ON e.event_id = a.link_to_event WHERE a.link_to_event IS NULL"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_267", "db_id": "esophageal", "query": "There is a dataset called esophageal, which contains the tables: treatment_and_followup, treatment_and_followup_backup, and treatment_and_followup_latest. The backup table is a backup of the source table, while the latest table is the most recently updated target table. The user wants to merge the source table with the target table while also removing rows that exist in the target table but are missing from the source table, and generate a new backup table. The user hopes to execute the merge and deletion steps simultaneously.", "issue_sql": ["MERGE INTO treatment_and_followup_backup b USING treatment_and_followup_latest a ON b.patient_id = a.patient_id WHEN MATCHED THEN UPDATE SET followup_no = a.followup_no, primary_pathology_karnofsky_performance_score = a.primary_pathology_karnofsky_performance_score, primary_pathology_eastern_cancer_oncology_group = a.primary_pathology_eastern_cancer_oncology_group WHEN NOT MATCHED THEN INSERT (patient_id, followup_no, primary_pathology_karnofsky_performance_score, primary_pathology_eastern_cancer_oncology_group) VALUES (a.patient_id, a.followup_no, a.primary_pathology_karnofsky_performance_score, a.primary_pathology_eastern_cancer_oncology_group);"], "preprocess_sql": ["\n    DROP TABLE IF EXISTS treatment_and_followup_backup;\n    DROP TABLE IF EXISTS treatment_and_followup_latest;\n    CREATE TABLE treatment_and_followup_backup AS SELECT * FROM treatment_and_followup LIMIT 0; \n    CREATE TABLE treatment_and_followup_latest AS SELECT * FROM treatment_and_followup LIMIT 0; \n    INSERT INTO treatment_and_followup_backup\n    SELECT * FROM treatment_and_followup; \n    INSERT INTO treatment_and_followup_latest \n    SELECT * FROM treatment_and_followup;\n    INSERT INTO treatment_and_followup_latest\n        VALUES (0, 0, 1, NULL, NULL, false, 'NO', false, false, false, 'tcga', 25, 2, 2014);\n    UPDATE treatment_and_followup_latest\n    SET followup_no = 0\n    WHERE patient_id = 1;\n    "], "clean_up_sql": ["DROP TABLE if EXISTS treatment_and_followup_backup, treatment_and_followup_latest;"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT * FROM transactions_1k LEFT JOIN customers ON transactions_1k.CustomerID = customers.CustomerID LIMIT 5"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_268", "db_id": "erolp", "query": "In the erolp database, we have a table named 'learners' in which each learner's engagement history is stored as an array. We want to split the engagement history into individual entries while maintaining their association with the corresponding learner. Upon querying the 'learners' table, the engagement history currently appears as follows when queried: SELECT learner_code, engagement_history FROM learners. The results show: | learner_code | engagement_history | 1 | {5, 10, 15} | 2 | {3, 6} | 3 | {8} |. We want to transform this so that each count of engagement history is shown on separate rows, like: | learner_code | engagement | 1 | 5 | 1 | 10 | 1 | 15 | 2 | 3 | 2 | 6 | 3 | 8 |. No entries should appear with null values in either column.", "issue_sql": ["SELECT learner_code, engagement_history FROM learners_array;"], "preprocess_sql": ["CREATE TABLE learners_array (\n    learner_code INT PRIMARY KEY,\n    engagement_history INT[],\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    last_login_date DATE DEFAULT CURRENT_DATE,\n    account_status VARCHAR(50) DEFAULT 'active',\n    engagement_metadata JSONB DEFAULT '{}'::jsonb,\n    total_login_count INTEGER DEFAULT 0,\n    profile_completion_percentage NUMERIC(5,2) DEFAULT 0.0,\n    is_verified BOOLEAN DEFAULT false,\n    user_preferences TEXT DEFAULT 'default settings',\n    session_uuid UUID DEFAULT gen_random_uuid(),\n    device_info VARCHAR(255) DEFAULT 'unknown',\n    last_ip_address VARCHAR(45) DEFAULT '0.0.0.0'\n);", "INSERT INTO learners_array (learner_code, engagement_history, created_at, updated_at, last_login_date, account_status, engagement_metadata, total_login_count, profile_completion_percentage, is_verified, user_preferences, session_uuid, device_info, last_ip_address) \nVALUES \n    (1, ARRAY[5, 10, 15], '2023-01-15 08:30:00+00', '2023-02-20 14:45:00+00', '2023-02-20', 'active', '{\"source\": \"mobile\", \"platform\": \"ios\"}'::jsonb, 27, 85.5, true, 'dark mode, notifications enabled', 'a1b2c3d4-e5f6-4a5b-9c8d-7e6f5a4b3c2d', 'iPhone 13', '192.168.1.101'),\n    (2, ARRAY[3, 6], '2023-01-20 10:15:00+00', '2023-02-18 09:30:00+00', '2023-02-18', 'active', '{\"source\": \"web\", \"browser\": \"chrome\"}'::jsonb, 15, 60.0, true, 'light mode, email digest weekly', 'b2c3d4e5-f6a7-5b6c-0d1e-2f3a4b5c6d7e', 'Windows PC', '192.168.1.102'),\n    (3, ARRAY[8], '2023-01-25 14:20:00+00', '2023-02-10 16:45:00+00', '2023-02-10', 'inactive', '{\"source\": \"tablet\", \"platform\": \"android\"}'::jsonb, 8, 30.0, false, 'default settings', 'c3d4e5f6-a7b8-6c7d-1e2f-3a4b5c6d7e8f', 'Samsung Galaxy Tab', '192.168.1.103'),\n    (4, ARRAY[12, 18, 25, 30], '2023-01-30 09:45:00+00', '2023-02-22 11:30:00+00', '2023-02-22', 'premium', '{\"source\": \"desktop\", \"browser\": \"firefox\"}'::jsonb, 42, 95.0, true, 'custom theme, all notifications', 'd4e5f6a7-b8c9-7d8e-2f3a-4b5c6d7e8f9a', 'MacBook Pro', '192.168.1.104'),\n    (5, NULL, '2023-02-05 11:30:00+00', '2023-02-05 11:30:00+00', '2023-02-05', 'pending', '{}'::jsonb, 1, 10.0, false, 'default settings', 'e5f6a7b8-c9d0-8e9f-3a4b-5c6d7e8f9a0b', 'unknown', '192.168.1.105');", "SELECT * FROM learners_array;"], "clean_up_sql": ["DROP TABLE IF EXISTS learners_array;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT bond_id FROM bond WHERE bond_id ~ '^TR[1-3].*[45]$'"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_269", "db_id": "erolp", "query": "In the educational database system, we want to analyze the usage duration of learning resources by learners across different learner engagement levels. Each learner's engagement level is documented in the 'target_labels' table, and each resource's rating by the learner is captured in the 'resource_usage' table. Our goal is to group the findings by each engagement level and identify the minimum and maximum resource rating within each group. Here's an example of how someone tried to approach the problem, but the SQL query lacks the necessary aggregate functions and grouping, leading to incorrect results: sql SELECT Engagement_Level, MAX(rating), MIN(rating) FROM resource_usage JOIN target_labels ON resource_usage.learner_code = target_labels.learner_code GROUP BY Engagement_Level", "issue_sql": ["SELECT Engagement_Level, MAX(rating), MIN(rating) FROM resource_usage JOIN target_labels ON resource_usage.learner_code = target_labels.learner_code GROUP BY Engagement_Level;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT SUM(cost) AS total_cost, link_to_member FROM expense GROUP BY link_to_member"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_270", "db_id": "erolp", "query": "In the context of my educational resource management system database, I have a table `resource_usage` containing the columns `learner_code`, `rating`, and `usage_date`. This table tracks the dates when each learner accessed a resource, along with their rating of that resource. I want to query this table to find the latest rating given by each learner (`learner_code`), ordered by `learner_code`. This will help in understanding the most recent feedback from learners. The original query I used involved a multi-step process, but I suspect it was inefficient or incorrect. Here is what I did: Step 1: Extract the latest usage date for each learner.", "issue_sql": ["SELECT learner_code, rating, usage_date FROM resource_usage WHERE (learner_code, usage_date) = (SELECT learner_code, MAX(usage_date) FROM resource_usage GROUP BY learner_code) ORDER BY learner_code, usage_date DESC;"], "preprocess_sql": ["\n    ALTER TABLE resource_usage DROP CONSTRAINT resource_usage_pkey;\n    INSERT INTO resource_usage\n    VALUES (1, 1, 1, 0, 3.0, 'Positive', '2025-04-01'),\n        (2, 2, 2, 0, 4.0, 'Negative', '2025-05-01');\n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT t.trans_id, a.district_id, t.amount FROM trans AS t JOIN account AS a ON t.account_id = a.account_id ORDER BY t.trans_id ASC NULLS FIRST LIMIT 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_271", "db_id": "erolp", "query": "The user wants to use CASE WHEN in the WHERE clause in PostgreSQL. They do not want to scan all the partitions of the table but instead target specific partitions. In the erolp database, they want to query people with specific gender, engagement history conditions, and language proficiency levels depending on whether they live in suburban or urban areas. However, using CASE WHEN directly in the WHERE clause results in an error.", "issue_sql": ["SELECT learner_code, CASE WHEN Geographic_Location = 'Urban' THEN 1 WHEN Geographic_Location = 'Rural' THEN 2 ELSE 0 END AS location_id, AVG(Pre_Test_Score) AS average_pre_test_score FROM learners WHERE Engagement_History > 5 AND Gender = 'Female' AND Language_Proficiency IN ('Basic', 'Intermediate') AND CASE WHEN ${socio_status} IN ('Low', 'Middle') THEN Geographic_Location = 'Urban' WHEN ${socio_status} = 'High' THEN Geographic_Location = 'Rural' END;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["(SELECT schools.CDSCode AS sch_CDSCode, frpm.CDSCode AS frpm_CDSCode FROM schools LEFT JOIN frpm ON schools.CDSCode = frpm.CDSCode) UNION ALL (SELECT schools.CDSCode AS sch_CDSCode, frpm.CDSCode AS frpm_CDSCode FROM schools RIGHT JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.CDSCode IS NULL)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_272", "db_id": "california_schools", "query": "I need a query that identifies line segments of school districts that do not break when found at the point of another line segment, examples below:\n\nHere in this case, the lines meet and break at the points:\n\nI need a select that finds cases when the line continues and does not break:\n\nOr like this:\n\nIt would be possible?\n\nI tried something like this but it didn't work.", "issue_sql": ["WITH src(id,geom) as (values (1, 'linestring(0 0, 0 10)'::geometry), (2, 'linestring(0 10, 0 11)'::geometry), (3, 'linestring(1 1, 0 5)'::geometry), (4, 'linestring(1 1, 2 2)'::geometry)) SELECT a.id, st_asText(st_intersection(a.geom, b.geom)) FROM src AS a WHERE NOT EXISTS (SELECT 1 FROM src as b WHERE a.id != b.id AND ST_Toches(a.geom, b.geom) AND ST_Equals(ST_EndPoint(b.geom), ST_Intersection(a.geom, b.geom)));"], "preprocess_sql": ["CREATE EXTENSION IF NOT EXISTS postgis;"], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT Player.player_api_id, Player.player_name, Player_Attributes.overall_rating FROM player LEFT JOIN player_attributes ON Player.player_api_id = Player_Attributes.player_api_id AND Player_Attributes.overall_rating = 68"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_273", "db_id": "erolp", "query": "In the erolp database, we have a table that stores detailed information about various devices, including their serial numbers, software versions, and channel configurations. Each device record contains a  field that includes a list of channels with their respective properties. We need to extract specific details from this  field, such as the serial number, channel ID, and channel name for each channel listed in the  array. The user attempted to write a query to achieve this but encountered an error.", "issue_sql": ["select device_info::json ->> 'SerialNumber' as SerialNumber, cto ->> 'ChannelId'::INT   AS channelid, cto ->> 'ChannelName' AS ChannelName from device_details CROSS JOIN LATERAL json_array_elements(device_info::json ->'ChannelListDto') Channels(cto);"], "preprocess_sql": ["DROP TABLE IF EXISTS device_details;", "CREATE TABLE device_details (device_info TEXT, created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, device_status VARCHAR(50) DEFAULT 'active', last_sync_date DATE DEFAULT CURRENT_DATE, sync_count INTEGER DEFAULT 0, is_deprecated BOOLEAN DEFAULT FALSE, firmware_history JSONB DEFAULT '{}'::jsonb, maintenance_notes TEXT DEFAULT '', device_uuid UUID DEFAULT gen_random_uuid(), manufacturer VARCHAR(100) DEFAULT 'Unknown', model_year INTEGER DEFAULT 2023, installation_location VARCHAR(255) DEFAULT 'Main Facility', responsible_technician VARCHAR(100) DEFAULT 'Unassigned', last_error_code VARCHAR(50) DEFAULT NULL, configuration_version NUMERIC(8,2) DEFAULT 1.0, tags TEXT[] DEFAULT '{}'::TEXT[]);", "INSERT INTO device_details (device_info, created_at, updated_at, device_status, last_sync_date, sync_count, is_deprecated, firmware_history, maintenance_notes, device_uuid, manufacturer, model_year, installation_location, responsible_technician, last_error_code, configuration_version, tags) VALUES ('{\r\n  \"SerialNumber\": \"907578\",\r\n  \"SoftwareVersion\": \"1.2.777\",\r\n  \"Build\": \"4829\",\r\n  \"ProductCode\": \"TR-3500-A\",\r\n  \"BuildDate\": null,\r\n  \"Description\": \"Study desk\",\r\n  \"ConnectionType\": 2,\r\n  \"Capabilities\": [\r\n    2,\r\n    3\r\n  ],\r\n  \"ChannelListDto\": [\r\n    {\r\n      \"ChannelId\": 0,\r\n      \"ConversionType\": 0,\r\n      \"DeviceSerialNumber\": null,\r\n      \"Dimension\": \"\",\r\n      \"FixedName\": null,\r\n      \"Name\": \"test2\",\r\n      \"InstrumentationChannel\": -1,\r\n      \"IsAlarmable\": false,\r\n      \"IsInternal\": true,\r\n      \"IsEnableable\": false,\r\n      \"IsEnabled\": false,\r\n      \"JournalledReadingBytes\": 0,\r\n      \"LowerLimit\": null,\r\n      \"Precision\": null,\r\n      \"Symbol\": \"\",\r\n      \"TypeId\": 5,\r\n      \"UpperLimit\": null\r\n    },\r\n    {\r\n      \"ChannelId\": 1,\r\n      \"ConversionType\": 0,\r\n      \"DeviceSerialNumber\": null,\r\n      \"Dimension\": \"\",\r\n      \"FixedName\": null,\r\n      \"Name\": null,\r\n      \"InstrumentationChannel\": -1,\r\n      \"IsAlarmable\": false,\r\n      \"IsInternal\": true,\r\n      \"IsEnableable\": false,\r\n      \"IsEnabled\": false,\r\n      \"JournalledReadingBytes\": 0,\r\n      \"LowerLimit\": null,\r\n      \"Precision\": null,\r\n      \"Symbol\": \"\",\r\n      \"TypeId\": 5,\r\n      \"UpperLimit\": null\r\n    },\r\n    {\r\n      \"ChannelId\": 2,\r\n      \"ConversionType\": 0,\r\n      \"DeviceSerialNumber\": null,\r\n      \"Dimension\": \"\",\r\n      \"FixedName\": null,\r\n      \"Name\": null,\r\n      \"InstrumentationChannel\": -1,\r\n      \"IsAlarmable\": false,\r\n      \"IsInternal\": true,\r\n      \"IsEnableable\": false,\r\n      \"IsEnabled\": false,\r\n      \"JournalledReadingBytes\": 0,\r\n      \"LowerLimit\": null,\r\n      \"Precision\": null,\r\n      \"Symbol\": \"\",\r\n      \"TypeId\": 5,\r\n      \"UpperLimit\": null\r\n    }\r\n  ]\r\n}', '2023-01-15 08:30:00+00', '2023-01-15 08:30:00+00', 'active', '2023-01-15', 5, FALSE, '{\"history\": [{\"version\": \"1.2.777\", \"date\": \"2023-01-01\"}]}'::jsonb, 'Initial installation completed successfully', 'f47ac10b-58cc-4372-a567-0e02b2c3d479', 'TechCorp', 2022, 'Research Lab A', 'John Smith', NULL, 1.5, '{\"educational\", \"research\", \"desktop\"}'::TEXT[]);"], "clean_up_sql": ["DROP TABLE IF EXISTS device_details;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT * FROM attribute JOIN hero_attribute ON hero_attribute.attribute_id = attribute.id WHERE NOT (attribute_name = 'Speed' AND attribute_value = 35)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_274", "db_id": "erolp", "query": "In the erolp database, we need to calculate the time difference between two timestamps while excluding weekends (Saturday and Sunday) from the calculation. For example, the difference between '2023-01-01 10:34:36' and '2023-01-10 15:12:24'. The query works correctly when the start date is a weekday but produces multiple incorrect results when the start date is a Saturday or Sunday. The format of the output is like ('2 days -3 hours -47 minutes -36 seconds')", "issue_sql": ["WITH test AS ( SELECT EXTRACT(DAY FROM diff) || ' days ' || EXTRACT(HOUR FROM diff) || ' hours ' || EXTRACT(MINUTE FROM diff) || ' minutes ' || EXTRACT(SECOND FROM diff) || ' seconds ' AS time_diff FROM ( SELECT TIMESTAMP '2023-01-10 15:12:24' - TIMESTAMP '2023-01-01 10:34:36' AS diff ) AS diff_query JOIN ( SELECT generate_series( timestamp '2023-01-01', timestamp '2023-01-10', interval '1 day' ) AS the_day ) AS dates ON dates.the_day BETWEEN TIMESTAMP '2023-01-01 10:34:36' AND TIMESTAMP '2023-01-10 15:12:24' WHERE EXTRACT('ISODOW' FROM dates.the_day) < 6 ) SELECT * FROM test"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT CDSCode, COUNT(CDSCODE) FROM schools WHERE District = 'Alameda County Office of Education' GROUP BY CDSCode LIMIT 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_275", "db_id": "erolp", "query": "In the context of our local database 'erolp', we are tasked with generating a set of pairs of named entities (tags) from articles, ordered by the number of articles they co-occur in. However, we need to check another table, 'link', to see if there's already an existing link between both tags. A link is a directed edge, meaning two tags could be connected either a->b or b->a. We want to filter out all links where a and b are already connected, but ideally, we would return unfiltered pairs along with the type of the link wherever a link exists.", "issue_sql": ["WITH links AS (SELECT greatest(link.source_cluster, link.target_cluster) AS big, least(link.source_cluster, link.target_cluster) AS smol, link.type AS type FROM link AS link) SELECT l.cluster AS left_id, l.cluster_type AS left_type, l.cluster_label AS left_label, r.cluster AS right_id, r.cluster_type AS right_type, r.cluster_label AS right_label, count(distinct(l.article)) AS articles, array_agg(distinct(links.type)) AS link_types FROM tag AS r, tag AS l JOIN links ON l.cluster = links.big WHERE l.cluster > r.cluster AND l.article = r.article AND r.cluster = links.smol GROUP BY l.cluster, l.cluster_label, l.cluster_type, r.cluster, r.cluster_label, r.cluster_type ORDER BY count(distinct(l.article)) DESC;"], "preprocess_sql": ["CREATE TABLE tag ( cluster character varying(40), article character varying(255), cluster_type character varying(10), cluster_label character varying );", "CREATE TABLE link ( source_cluster character varying(40), target_cluster character varying(40), type character varying(255) );", "INSERT INTO tag (cluster, cluster_type, cluster_label, article) VALUES ('fffcc580c020f689e206fddbc32777f0d0866f23', 'LOC', 'Russia', 'a'), ('fffcc580c020f689e206fddbc32777f0d0866f23', 'LOC', 'Russia', 'b'), ('fff03a54c98cf079d562998d511ef2823d1f1863', 'PER', 'Vladimir Putin', 'a'), ('fff03a54c98cf079d562998d511ef2823d1f1863', 'PER', 'Vladimir Putin', 'b'), ('fff03a54c98cf079d562998d511ef2823d1f1863', 'PER', 'Vladimir Putin', 'd'), ('ff9be8adf69cddee1b910e592b119478388e2194', 'LOC', 'Moscow', 'a'), ('ff9be8adf69cddee1b910e592b119478388e2194', 'LOC', 'Moscow', 'b'), ('ffeeb6ebcdc1fe87a3a2b84d707e17bd716dd20b', 'LOC', 'Latvia', 'a'), ('ffd364472a999c3d1001f5910398a53997ae0afe', 'ORG', 'OCCRP', 'a'), ('ffd364472a999c3d1001f5910398a53997ae0afe', 'ORG', 'OCCRP', 'd'), ('fef5381215b1dfded414f5e60469ce32f3334fdd', 'ORG', 'Moldindconbank', 'a'), ('fef5381215b1dfded414f5e60469ce32f3334fdd', 'ORG', 'Moldindconbank', 'c'), ('fe855a808f535efa417f6d082f5e5b6581fb6835', 'ORG', 'KGB', 'a'), ('fe855a808f535efa417f6d082f5e5b6581fb6835', 'ORG', 'KGB', 'b'), ('fe855a808f535efa417f6d082f5e5b6581fb6835', 'ORG', 'KGB', 'd'), ('fff14a3c6d8f6d04f4a7f224b043380bb45cb57a', 'ORG', 'Moldova', 'a'), ('fff14a3c6d8f6d04f4a7f224b043380bb45cb57a', 'ORG', 'Moldova', 'c');", "INSERT INTO link (source_cluster, target_cluster, type) VALUES ('fff03a54c98cf079d562998d511ef2823d1f1863', 'fffcc580c020f689e206fddbc32777f0d0866f23', 'LOCATED'), ('fe855a808f535efa417f6d082f5e5b6581fb6835', 'fff03a54c98cf079d562998d511ef2823d1f1863', 'EMPLOYER'), ('fff14a3c6d8f6d04f4a7f224b043380bb45cb57a', 'fef5381215b1dfded414f5e60469ce32f3334fdd', 'LOCATED');"], "clean_up_sql": ["DROP TABLE IF EXISTS tag;", "DROP TABLE IF EXISTS link;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT s.driverStandingsId, s.raceId, d.driverId FROM driverstandings AS s LEFT JOIN drivers AS d ON d.driverId = s.driverId WHERE s.raceId = 19"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_276", "db_id": "california_schools", "query": "I am trying to analyze the historical data of school openings in California. Specifically, I want to find the earliest opening date and the date of the fourth school that opened in each county. However, my current query is not giving me the correct results. Can you help me identify the issue and provide a corrected query?", "issue_sql": ["SELECT county, MIN(opendate) AS earliest_open_date, MAX(opendate) AS fourth_open_date FROM schools WHERE opendate <= (SELECT opendate FROM schools ORDER BY opendate LIMIT 1 OFFSET 3) GROUP BY county"], "preprocess_sql": [], "clean_up_sql": [], "category": "Query", "efficiency": false, "sol_sql": ["SELECT status, SUM(amount) AS total_amount, SUM(payments) AS total_payments, (SUM(amount) + SUM(payments)) AS s FROM loan GROUP BY status"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_277", "db_id": "global_atlas", "query": "\nImagine we have an international organization database tracking membership and participation \ndetails across different global entities. The database contains information about countries, \nincluding their economic statistics, political history, and their relationships with global organizations. \nA common task is to retrieve insights about countries with very specific membership criteria from \nenormous datasets. You are tasked with finding the latest membership entry of a country in small, \nspecialized organizations across a large number of records. The challenge is to do this efficiently \nas querying with a LIMIT 1 clause results in a timeout error due to the sheer volume of data and the \nquery execution plan unexpected behavior. Let's consider a situation where you're trying to retrieve \nthe latest entry for a specific country from the 'ismember' and 'organization' tables based on a \nselective membership type. Here is the problematic SQL statement the user encountered:\n", "issue_sql": ["SELECT i.country, o.name, o.city, o.established FROM public.ismember i INNER JOIN\npublic.organization o ON o.abbreviation = i.organization WHERE i.type = 'member'\nAND i.country = 'CI' ORDER BY o.established DESC LIMIT 1"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT p.ID, p.Diagnosis FROM patient AS p JOIN examination AS e ON (p.ID = e.ID) JOIN (SELECT p.Diagnosis, e.Thrombosis FROM patient AS p JOIN examination AS e ON (p.ID = e.ID) WHERE p.Diagnosis = 'PSS' AND e.Thrombosis = 0 GROUP BY p.Diagnosis, e.Thrombosis HAVING COUNT(*) > 1) AS j ON (p.Diagnosis = j.Diagnosis AND e.Thrombosis = j.Thrombosis)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_278", "db_id": "erolp", "query": "\nImagine a scenario where we have learners from various backgrounds enrolled in different institutions pursuing distinct curricula. We want to compare the average pre-test scores between institution types 'Public' and 'Private' within this educational framework. However, an error has occurred when using window functions for comparison. The attempt was to rank learners based on their pre-test scores from both institution types and then subtract the top-ranked scores. Here's the incorrect at tempt using dense_rank, resulting in a NULL due to logical issues.\n", "issue_sql": ["WITH CTE AS (select inst.\"Institution_Type\", outcm.\"Pre_Test_Score\", dense_rank()\nover (partition by \"Institution_Type\" order by \"Pre_Test_Score\" desc) as score_rank from outcomes as outcm\njoin enrollment as enrl on outcm.learner_code = enrl.learner_code join institutions as inst\non enrl.institution_key = inst.institution_key where inst.\"Institution_Type\" = 'Public' or\ninst.\"Institution_Type\" = 'Private') select (case when \"Institution_Type\" = 'Public' AND score_rank = 1\nTHEN \"Pre_Test_Score\" END) - (case when \"Institution_Type\" = 'Private' AND score_rank = 1 THEN \"Pre_Test_Score\" END)\nas score_diff FROM CTE"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT DISTINCT u.Id AS UserId, u.DisplayName, u.Reputation, b.Name AS BadgeName, b.Date AS BadgeDate FROM users AS u LEFT JOIN badges AS b ON b.UserId = u.Id AND b.Name = 'Teacher' WHERE u.Reputation >= 10000"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_279", "db_id": "erolp", "query": "\nIn our educational database, suppose we have a table 'educational_resources' where a column 'Content_Type' stores the name of platforms in string format. Now, I want to remove all characters that are the same as the first character (case-insensitive) from the 'Content_Type' strings. For example, if the string is 'LMS Communication', the result should be 'MS Communication' (removing both L and l). I experimented with the following query to achieve this result using regex replacement. However, it seems to only remove the first character, not subsequent occurrences. Here is the SQL I attempted to use: sql SELECT regexp_replace(Content_Type, '^(.)|\\1', '', 'ig') FROM educational_resources;  Could someone help me correct this query so that it removes all occurrences of the first character, regardless of case?\n", "issue_sql": ["SELECT regexp_replace(\"Content_Type\", '^(.)|\\1', '', 'ig') FROM educational_resources"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT SUM(expense.cost) AS total_expense, SUM(budget.amount) AS total_budget, budget.link_to_event FROM budget JOIN (SELECT expense.link_to_budget, SUM(expense.cost) AS cost FROM expense GROUP BY expense.link_to_budget) AS expense ON expense.link_to_budget = budget.budget_id GROUP BY budget.link_to_event"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_280", "db_id": "esophageal", "query": "\nI am managing a medical database for a research project focusing on esophageal cancer and \nrelated conditions. Our database contains various tables linked to the patient information, demographics, \nclinical status, treatment, and other relevant details. Now, I have encountered a situation where I need to \ntransform specific substrings in the 'primary_pathology_histological_type' column from the \n'pathology_and_surgery' table. Specifically, I need to replace 'NOS' with 'Not Otherwise Specified' \nand 'Adenocarcinoma' with 'Adenoma Carcinoma'. However, when I attempted to execute my query utilizing a \nsubquery method for these transformations, I encountered an error related to subquery returning \nmultiple rows, which hindered further progress. Here is the query I used that gave me the error:\n\n\nsql\nselect regexp_replace((select regexp_replace(primary_pathology_histological_type, 'NOS$', \n'Not Otherwise Specified') from pathology_and_surgery), 'Adenocarcinoma', 'Adenoma Carcinoma') \nas transformed_histological_type from pathology_and_surgery;\n\n\nThe query is supposed to \naccommodate the complex structure of the data where specific medical terminologies within a single field \nneed nuanced replacement. Unfortunately, the error derails this attempt, leaving the necessary \ntransformation unachieved.\n", "issue_sql": ["select regexp_replace((select regexp_replace(primary_pathology_histological_type, 'NOS$',\n'Not Otherwise Specified') from pathology_and_surgery), 'Adenocarcinoma', 'Adenoma Carcinoma')\nas transformed_histological_type from pathology_and_surgery;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["(SELECT full_name, LENGTH(full_name) FROM superhero WHERE NOT full_name IS NULL AND full_name <> '-' ORDER BY LENGTH(full_name) ASC NULLS FIRST, full_name ASC NULLS FIRST LIMIT 1) UNION (SELECT full_name, LENGTH(full_name) FROM superhero WHERE NOT full_name IS NULL AND full_name <> '-' ORDER BY LENGTH(full_name) DESC NULLS LAST, full_name ASC NULLS FIRST LIMIT 1)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_281", "db_id": "spotify", "query": "\nIn the esophageal database, patients can undergo different follow-ups over time, with each \nfollow-up potentially involving different treatments and interventions. Let's assume we want to track \nthe latest three follow-up entries for each patient and sum their \n'primary_pathology_karnofsky_performance_score'. Over time, these scores help clinicians understand the \ntrajectory of a patient's health related to their cancer treatment and recovery. The primary objective \nis to compute the total Karnofsky performance score for the latest 3 follow-ups for each patient, counted \nbackwards from the maximum completed date present in the 'treatment_and_followup' table for each patient. \nIn our initial attempt, we utilized a window function embedded in a sub-query to achieve this aggregation, \nbut encountered issues when trying to optimize the solution.\n", "issue_sql": ["(SELECT COUNT(*) FROM sp_artists WHERE pop > 50) / (SELECT COUNT(*) FROM sp_artists);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH RankedTransactions AS (SELECT tt.*, ROW_NUMBER() OVER (PARTITION BY tt.CustomerID) AS rn FROM transactions_1k AS tt INNER JOIN (SELECT CustomerID, MAX(Date) AS maxdate FROM transactions_1k GROUP BY CustomerID) AS groupedtt ON tt.CustomerID = groupedtt.CustomerID AND tt.Date = groupedtt.maxdate) SELECT * FROM rankedtransactions WHERE rn = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_282", "db_id": "esophageal", "query": "\nIn a patient-centric healthcare database, there is a need to filter and possibly redact certain \npatient information based on sensitive conditions. A specific requirement is to ensure that if a patient's \npathology diagnosis method lists as 'Other method, specify:', then certain fields should be left unpopulated \nto safeguard patient identity and privacy. The original approach involved using multiple CASE statements for \neach relevant column, causing redundancy. The user needs a streamlined way to implement this condition across \nseveral columns using the 'pathology_and_surgery' table. \n\nProblematic Query:\nThe user initially formulated \nthe query with redundant CASE statements to apply the condition for each column separately, leading to \nexcessive repetition and reduced maintainability.\nsql\nCASE WHEN \nCOALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_neoplasm_histologic_grade END AS histologic_grade,\n\nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_days_to_initial_pathologic_diagnosis END AS days_to_initial_diagnosis,\n\nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method, \nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:' \nTHEN NULL ELSE primary_pathology_age_at_initial_pathologic_diagnosis END AS age_at_initial_diagnosis\n\n\n\nThe query causes difficulty in maintaining the duplication logic, leading to errors if one \nforgets to update all segments.\n", "issue_sql": ["SELECT CASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:'\nTHEN NULL ELSE primary_pathology_neoplasm_histologic_grade END AS histologic_grade,\nCASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, \nspecify:' THEN NULL ELSE primary_pathology_days_to_initial_pathologic_diagnosis END AS\ndays_to_initial_diagnosis, CASE WHEN COALESCE(primary_pathology_initial_pathologic_diagnosis_method,\nprimary_pathology_init_pathology_dx_method_other) LIKE 'Other method, specify:'\nTHEN NULL ELSE primary_pathology_age_at_initial_pathologic_diagnosis END AS\nage_at_initial_diagnosis FROM pathology_and_surgery"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT id, (CASE WHEN (colors = 'W' AND power = '4') THEN COALESCE(watermark, '996') WHEN (colors = 'B' AND power = '3') THEN COALESCE(watermark, '997') WHEN (colors = 'U' AND power = '2') THEN COALESCE(watermark, '998') WHEN (colors = 'R' AND power = '0') THEN COALESCE(watermark, '999') END) AS watermark FROM cards"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_283", "db_id": "spotify", "query": "I have a table that captures the relationships between albums and artists, where multiple entries might exist for the same album-artist-feature combination over different periods. These unnecessary repeated entries should be consolidated into a single continuous record. For instance, consider a table that looks like this: sp_album_ctb (alb, art, feat_arts, start_date, end_date) and imagine input data as: (1, 100, [], '2023-01-01', '2023-01-10'), (1, 100, [], '2023-01-11', '2023-01-20'), (1, 100, [], '2023-01-21', NULL), (2, 101, [300], '2023-01-01', '2023-01-15'), (2, 101, [300], '2023-01-16', NULL). Notice how entries for album 1 with artist 100 can be combined. Ideally, a query is needed that will collapse redundant entries and update the final row to reflect the continuous period, i.e., producing an output like: (1, 100, [], '2023-01-01', NULL), (2, 101, [300], '2023-01-01', NULL). My best attempt so far only identifies redundant entries for potential deletion but fails to perform the merge and update correctly and looks like this: SELECT *, FROM sp_album_ctb WHERE (alb, art, feat_arts, start_date) IN (SELECT alb, art, feat_arts, end_date + INTERVAL '1 day' FROM sp_album_ctb);", "issue_sql": ["SELECT * FROM sp_album_ctb WHERE (alb, art, feat_arts, start_date) IN (SELECT alb, art, feat_arts, end_date + INTERVAL '1 day' FROM sp_album_ctb);"], "preprocess_sql": ["\n    DROP TABLE if EXISTS sp_album;\n    create table sp_album (\n        alb int not null,\n        art int not null,\n        feat_arts JSONB not null,\n        start_date date,\n        end_date date\n    );\n    INSERT INTO sp_album\n    VALUES \n        (1, 100, '[]'::jsonb, '2023-01-01', '2023-01-10'),\n        (1, 100, '[]'::jsonb, '2023-01-11', '2023-01-20'),\n        (1, 100, '[100]'::jsonb, '2023-01-21', NULL),\n        (2, 101, '[300]'::jsonb, '2023-01-01', '2023-01-10'),\n        (2, 101, '[300]'::jsonb, '2023-01-11', '2023-01-20'),\n        (3, 202, '[]'::jsonb, '2023-01-21', NULL);\n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT AVG(Score) AS AvgOfScore FROM (SELECT posts.OwnerUserId, posts.Tags, Score, CreaionDate, ROW_NUMBER() OVER (PARTITION BY OwnerUserId, Tags ORDER BY CreaionDate DESC NULLS LAST) AS row_num FROM posts WHERE OwnerUserId = 183 AND Tags LIKE '%distribution%') AS Scores WHERE row_num <= 5"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_284", "db_id": "esophageal", "query": "I am working with the 'esophageal' database and need to retrieve information for a specific patient from the 'patients' table together with one entry from the 'patient_addresses' table where the patient has multiple procurement addresses. I want the address with the latest entry, based on the primary key order. I've tried the following query, but I am concerned that when there are many addresses for a single patient, the intermediate dataset might be large and could impact performance negatively. Is there a more efficient way to structure this query to achieve the desired results without unnecessary data processing overhead? Here is my current solution:", "issue_sql": ["SELECT patients.patient_id, patients.patient_barcode, patient_addresses.address_id, patient_addresses.city_of_procurement FROM patients, patient_addresses WHERE patients.patient_id = 1 AND patient_addresses.patient_id = patients.patient_id ORDER BY patient_addresses.address_id DESC LIMIT 1;"], "preprocess_sql": ["\n    INSERT INTO patient_addresses\n    VALUES (0, 1, 'Procurement', 'Netherlands', 'ZH', ''),\n        (3986, 1, 'Procurement', 'China', 'Shenzhen', '') \n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT link_to_member, COUNT(DISTINCT CAST(event_date AS DATE)) AS total_attendance_days FROM attendance JOIN event ON attendance.link_to_event = event.event_id WHERE event_date BETWEEN '2019-01-01' AND '2023-12-31' GROUP BY link_to_member"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_285", "db_id": "erolp", "query": "\nIn the erolp database, there is a table named learners_info which contains records of all learners, including their learner_code, Age, and Previous_Academic_Performance. The task is to find, for each learner, another learner who is older and has a lower academic performance. The original query provided by the user is inefficient and takes a long time to execute, especially with a large dataset. The user is seeking an optimized solution to improve the performance of the query.\n", "issue_sql": ["SELECT current_rec.*, compare_rec.learner_code AS lower_performance_learner\nFROM public.learners_info current_rec\nLEFT JOIN public.learners_info compare_rec\n  ON current_rec.\"Age\" < compare_rec.\"Age\"\n  AND current_rec.\"Previous_Academic_Performance\" > compare_rec.\"Previous_Academic_Performance\"\nORDER BY current_rec.learner_code;"], "preprocess_sql": ["\nCREATE TABLE public.learners_info (\n  learner_code INT PRIMARY KEY,\n  \"Age\" INT,\n  \"Previous_Academic_Performance\" INT \n);\n\nINSERT INTO public.learners_info (learner_code, \"Age\", \"Previous_Academic_Performance\")\nVALUES\n  (1, 17, 80),\n  (2, 20, 85),\n  (3, 22, 90),\n  (4, 24, 70),\n  (5, 26, 95),\n  (6, 28, 88),\n  (7, 30, 60),\n  (8, 32, 78),\n  (9, 19, 82),\n  (10, 27, 76);\n"], "clean_up_sql": ["drop table learners_info"], "category": "Efficiency", "efficiency": true, "sol_sql": ["SELECT A.member_id, A.first_name, A.last_name FROM member AS A WHERE NOT A.member_id IN (SELECT link_to_member FROM attendance WHERE link_to_event = 'recEVTik3MlqbvLFi')"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_286", "db_id": "erolp", "query": "Consider a scenario where an educational platform needs to merge learning outcomes and resource usage data for enhanced analytical insights. Specifically, we want to combine data from the 'learners' table and the 'resource_usage' table to generate a comprehensive output that shows each learner's usage of educational resources marked by specific usage feedback. On one hand, the usage feedback is directly available for existing entries in the 'resource_usage' table, whereas for alumni learners, we need to generate synthetic feedback based on their satisfaction rating in the 'outcomes' table. Two queries are attempted to consolidate the data, with a union operation harmonizing the results while applying a filter criterion to pick out entries based on feedback. The problem emerges when aligning dynamically generated feedback with static descriptions. Here's a query aiming to effectuate this dual merging and filtering but encountering a technical error.", "issue_sql": ["SELECT l.learner_code, l.gender, r.resource_key, 'Regular Feedback' as FeedbackType, r.feedback as UserFeedback FROM learners l INNER JOIN resource_usage r ON l.learner_code = r.learner_code WHERE UserFeedback = ANY(ARRAY['Negative']) UNION ALL SELECT l.learner_code, l.gender, 0 as resource_key, 'Synthetic Feedback' as FeedbackType, CASE WHEN o.learner_satisfaction_score < 3 THEN 'Negative' ELSE 'Positive' END as UserFeedback FROM learners l INNER JOIN outcomes o ON l.learner_code = o.learner_code WHERE UserFeedback = ANY(ARRAY['Negative']);"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT r.CustomerID, r.Description, r.Date FROM (SELECT t.CustomerID, p.Description, t.Date, ROW_NUMBER() OVER (PARTITION BY t.CustomerID ORDER BY t.Date DESC NULLS LAST) AS RowNum FROM transactions_1k AS t INNER JOIN products AS p ON t.ProductID = p.ProductID) AS r WHERE r.RowNum = 1"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_287", "db_id": "global_atlas", "query": "Imagine a dataset representing a global atlas, containing detailed information about countries, cities, and other geographic entities. You are working with a PostgreSQL database to sort data concerning the population of various cities. When trying to organize city names based on a pattern, you encounter unexpected results due to null handling in the sorting process. You attempted to use complex substring functions to extract and sort based on certain city name patterns and followed this SQL statement, but encountered issues with null placements during sorting:\n\nsql\nORDER BY SUBSTRING(name FROM '[A-Z]+'), COALESCE(SUBSTRING(name FROM '(?<=-)[0-9]+')::INTEGER, 0), SUBSTRING(name FROM '(?<=\\()[0-9]+')::BIGINT\n\n\nThis led to incorrect ordering because you didn't account for null values properly in one of the sorting steps, resulting in nulls being placed in the wrong order.", "issue_sql": ["SELECT * FROM city ORDER BY COALESCE(SUBSTRING(name FROM '[A-Z]+'), ''), COALESCE(SUBSTRING(name FROM '(?<=-)[0-9]+')::INTEGER, 0), COALESCE(SUBSTRING(name FROM '(?<=\\()[0-9]+')::BIGINT, 0)"], "preprocess_sql": ["\n    INSERT INTO city\n    VALUES ('Aachen-1', 'D', 'Nordrhein-Westfalen'),\n        ('Aachen-1(2)', 'D', 'Nordrhein-Westfalen'),\n        ('Aachen-1(1)', 'D', 'Nordrhein-Westfalen'),\n        ('Aachen-2', 'D', 'Nordrhein-Westfalen')\n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT DISTINCT t1.CustomerID AS Customer1, t2.CustomerID AS Customer2, COUNT(*) AS Count FROM transactions_1k AS t1 JOIN transactions_1k AS t2 ON t1.Date = t2.Date AND t1.GasStationID = t2.GasStationID AND t1.CustomerID < t2.CustomerID GROUP BY Customer1, Customer2 ORDER BY Count DESC NULLS LAST"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_288", "db_id": "global_atlas", "query": "In the global_atlas database, I want a SQL statement that retrieves the names and codes of countries along with an array of alternative names for each country from the countryothername table. I ran the following query, but if a country has no alternative names, it returns an array containing NULL instead of returning just NULL for that column. Here's what I tried:\n\nsql\nSELECT c.name, c.code, array_agg(cn.othername) AS alternative_names FROM country c\nLEFT JOIN countryothername cn ON c.code = cn.country\nGROUP BY c.name, c.code\nORDER BY c.name ASC;\n\n\nThe issue is that `[NULL]` is returned for countries with no alternative names instead of `NULL`. How can I modify my query to show `NULL` instead of such an array?", "issue_sql": ["SELECT c.name, c.code, array_agg(cn.othername) AS alternative_names FROM country c LEFT JOIN countryothername cn ON c.code = cn.country GROUP BY c.name, c.code ORDER BY c.name ASC;"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH DAILY_REVENUE AS (SELECT Date, SUM(Amount) AS TotalAmount FROM transactions_1k GROUP BY Date ORDER BY Date ASC NULLS FIRST), MOVING_AVG AS (SELECT Date, CASE WHEN COUNT(*) OVER (ORDER BY Date ASC NULLS FIRST ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) = 3 THEN SUM(TotalAmount) OVER (ORDER BY Date ASC NULLS FIRST ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) ELSE NULL END AS TotalAmount, CASE WHEN COUNT(*) OVER (ORDER BY Date ASC NULLS FIRST ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) = 3 THEN CAST(AVG(TotalAmount) OVER (ORDER BY Date ASC NULLS FIRST ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS DECIMAL(10, 2)) ELSE NULL END AS AverageAmount FROM daily_revenue) SELECT * FROM moving_avg"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_289", "db_id": "erolp", "query": "\nIn the database `erolp`, there are two tables `learner_institution_location` which contains the location of the target learner`s institution and `institution_location` which contains locations of other institutions. Each institution has a unique identifier and a spatial geometry representing its location. We want to identify neighboring institutions that are in direct contact with the target learner`s institution. The goal is to find all institutions in the `institution_location` table that share a boundary (e.g., within the distance of 1) with `learner_institution_location`. I attempted to use the ST_Touches function but encountered issues with my query.\n", "issue_sql": ["SELECT ST_Touches(ol.geom, l.geom)\nFROM institution_location ol, learner_institution_location l\nWHERE ST_Touches(ol.geom, l.geom)"], "preprocess_sql": ["\nCREATE EXTENSION postgis;\nCREATE TABLE institution_location (\n    institution_id SERIAL PRIMARY KEY,\n    institution_name VARCHAR(255),\n    geom GEOMETRY\n);\n\nINSERT INTO institution_location (institution_name, geom) VALUES\n('Institution B', ST_SetSRID(ST_MakePoint(0, 2), 4326)),\n('Institution C', ST_SetSRID(ST_MakePoint(0, 1), 4326)),\n('Institution D', ST_SetSRID(ST_MakePoint(2, 1), 4326)),\n('Institution E', ST_SetSRID(ST_MakePoint(1, 2), 4326)),\n('Institution F', ST_SetSRID(ST_MakePoint(-1, 1), 4326)),\n('Institution G', ST_SetSRID(ST_MakePoint(1, 3), 4326));\n\nCREATE TABLE learner_institution_location (\n    learner_id SERIAL PRIMARY KEY,\n    institution_id INT,\n    FOREIGN KEY (institution_id) REFERENCES institution_location(institution_id),\n    geom GEOMETRY \n);\n\nINSERT INTO learner_institution_location (institution_id, geom) VALUES\n(1, ST_SetSRID(ST_MakePoint(1, 1), 4326));\n"], "clean_up_sql": ["drop table learner_institution_location; drop table institution_location;"], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT m.department, e.cost AS highest_cost, COUNT(e.expense_id) AS cost_count FROM expense AS e INNER JOIN member AS mem ON e.link_to_member = mem.member_id INNER JOIN major AS m ON mem.link_to_major = m.major_id WHERE e.cost = (SELECT MAX(cost) FROM expense) GROUP BY m.department, e.cost HAVING COUNT(e.expense_id) = (SELECT MAX(dept_count) FROM (SELECT COUNT(e2.expense_id) AS dept_count FROM expense AS e2 INNER JOIN member AS mem2 ON e2.link_to_member = mem2.member_id INNER JOIN major AS m2 ON mem2.link_to_major = m2.major_id WHERE e2.cost = (SELECT MAX(cost) FROM expense) GROUP BY m2.department) AS cost_counts)"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_290", "db_id": "esophageal", "query": "In a medical research study of esophageal cancer patients, we maintain a database recording various attributes including demographic details and lifestyle risk factors. One of the analyses involves evaluating the number of patients with informed consent within different tissue source sites and the proportion of these who verified informed consent. This analysis aims to provide insights into the preparedness levels across different collection sites. We can compute the total number of patients per site using a straightforward query: SELECT tissue_source_site, COUNT(*) AS total_patients FROM patients GROUP BY tissue_source_site. However, to find the number of patients per site with informed consent verified, we use: SELECT tissue_source_site, COUNT(*) AS consent_verified FROM patients WHERE informed_consent_verified = true GROUP BY tissue_source_site. Attempting to combine this information using INNER JOIN, a student utilized the following query but encountered the undesired duplication of the tissue_source_site column: sql SELECT result_total.tissue_source_site, result_total.total_patients, result_verified.consent_verified FROM (SELECT tissue_source_site, COUNT(*) AS total_patients FROM patients GROUP BY tissue_source_site) result_total INNER JOIN (SELECT tissue_source_site, COUNT(*) AS consent_verified FROM patients WHERE informed_consent_verified = true GROUP BY tissue_source_site) result_verified ON result_total.tissue_source_site = result_verified.tissue_source_site;  Furthermore, the student wanted to add a new column calculating the percentage of consent verified but struggled to integrate this calculation into the join query. Lastly, there was also a question on potentially optimizing the query to avoid separate subqueries, seeking a more efficient SQL.", "issue_sql": ["SELECT * FROM\n    (SELECT tissue_source_site, COUNT (*) AS total\n    FROM (SELECT * FROM patients) AS _\n    GROUP BY tissue_source_site) result_total\n    INNER JOIN\n    (SELECT tissue_source_site, COUNT (*) AS processed\n    FROM (SELECT * FROM patients WHERE informed_consent_verified=true) AS _\n    GROUP BY tissue_source_site) result_processed\n    ON result_total.tissue_source_site = result_processed.tissue_source_site;"], "preprocess_sql": ["\n    UPDATE patients\n    SET informed_consent_verified = FALSE\n    WHERE tissue_source_site = '2H' AND patient_id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    "], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["WITH segment_counts AS (SELECT Country, Segment, COUNT(*) AS count_segment, DENSE_RANK() OVER (PARTITION BY Country ORDER BY COUNT(*) DESC NULLS LAST) AS rnk FROM gasstations GROUP BY Country, Segment) SELECT Country, Segment, count_segment FROM segment_counts WHERE rnk = 1"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_291", "db_id": "debit_card_specializing", "query": "In the debit_card_specializing database, there are two tables, sales and initial_purchase. I need to join these tables based on 'CustomerId' and 'GasstationId', and only return the records where 'SaleDate' in sales is greater than or equal to 'FirstPurchaseDate' in initial_purchase. The issue is that each result is returned multiple times, and when I use aggregations and GROUP BY, it sums the amounts incorrectly.", "issue_sql": ["WITH sales AS ( SELECT \"gasstationid\" AS \"GasstationId\", \"customerid\" AS \"CustomerId\", \"date\" AS \"SaleDate\", \"amount\" AS \"Amount\" FROM \"transactions_1k\" ), initial_purchase AS ( SELECT \"GasstationId\", \"CustomerId\", MIN(CAST(\"SaleDate\" AS date)) AS \"FirstPurchaseDate\" FROM sales GROUP BY \"GasstationId\", \"CustomerId\" ), customer_wages AS ( SELECT i.\"CustomerId\", s.* FROM sales s JOIN initial_purchase i ON s.\"CustomerId\" = i.\"CustomerId\" WHERE s.\"SaleDate\" >= i.\"FirstPurchaseDate\" ORDER BY i.\"CustomerId\" DESC ) SELECT * FROM customer_wages"], "preprocess_sql": [], "clean_up_sql": [], "category": "Personalization", "efficiency": false, "sol_sql": ["SELECT pt.ID, pt.SEX, pt.Birthday, ex.Diagnosis FROM patient AS pt JOIN examination AS ex ON pt.ID = ex.ID WHERE ex.Diagnosis = 'SLE' AND ex.\"aCL IgG\" > 3.0"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result"]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_292", "db_id": "california_schools", "query": "In the california_schools database, we need to identify all columns with uppercase names across all user-defined tables and alter them to lowercase. The database contains various tables. Each table has a mix of uppercase and lowercase column names, and we need to standardize them to lowercase to maintain consistency and avoid potential issues in data processing and analysis.", "issue_sql": ["ALTER TABLE (SELECT quote_ident(c.table_schema) || '.' || quote_ident(c.table_name) || ' RENAME \"' || c.column_name || '\" TO ' || quote_ident(lower(c.column_name)) || ';' As ddlsql FROM information_schema.columns As c WHERE c.table_schema NOT IN('information_schema', 'pg_catalog') AND c.column_name <> lower(c.column_name) ORDER BY c.table_schema, c.table_name, c.column_name);"], "preprocess_sql": [], "clean_up_sql": ["ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"cdscode\" TO \"CDSCode\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"academic year\" TO \"Academic Year\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"county code\" TO \"County Code\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"district code\" TO \"District Code\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"school code\" TO \"School Code\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"county name\" TO \"County Name\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"district name\" TO \"District Name\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"school name\" TO \"School Name\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"district type\" TO \"District Type\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"school type\" TO \"School Type\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"educational option type\" TO \"Educational Option Type\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"nslp provision status\" TO \"NSLP Provision Status\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"charter school (y/n)\" TO \"Charter School (Y/N)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"charter school number\" TO \"Charter School Number\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"charter funding type\" TO \"Charter Funding Type\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"irc\" TO \"IRC\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"low grade\" TO \"Low Grade\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"high grade\" TO \"High Grade\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"enrollment (k-12)\" TO \"Enrollment (K-12)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"free meal count (k-12)\" TO \"Free Meal Count (K-12)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"percent (%) eligible free (k-12)\" TO \"Percent (%) Eligible Free (K-12)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"frpm count (k-12)\" TO \"FRPM Count (K-12)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"percent (%) eligible frpm (k-12)\" TO \"Percent (%) Eligible FRPM (K-12)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"enrollment (ages 5-17)\" TO \"Enrollment (Ages 5-17)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"free meal count (ages 5-17)\" TO \"Free Meal Count (Ages 5-17)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"percent (%) eligible free (ages 5-17)\" TO \"Percent (%) Eligible Free (Ages 5-17)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"frpm count (ages 5-17)\" TO \"FRPM Count (Ages 5-17)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"percent (%) eligible frpm (ages 5-17)\" TO \"Percent (%) Eligible FRPM (Ages 5-17)\";", "ALTER TABLE \"public\".\"frpm\" RENAME COLUMN \"2013-14 calpads fall 1 certification status\" TO \"2013-14 CALPADS Fall 1 Certification Status\";"], "category": "Management", "efficiency": false, "sol_sql": ["SELECT\n    (SELECT COUNT(*) FROM bond WHERE bond_id = 'TR000_1_2') AS bond_id_count,\n    bond_type,\n    COUNT(*) AS bond_type_count\nFROM bond\nGROUP BY ROLLUP (bond_type)"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_293", "db_id": "erolp", "query": "In the database 'erolp', there is a table 'product' that contains product details including 'product_id', 'product_name', and 'is_searchable'. A user wants to filter products based on a list of product IDs but only if all the products in the list have 'is_searchable' set to true. The user's initial query incorrectly filters products row-by-row instead of checking the condition for the entire list.", "issue_sql": ["SELECT product_id FROM product WHERE product_id IN (101, 103) AND is_searchable = true"], "preprocess_sql": ["CREATE TABLE product (\n  product_id INT,\n  product_name VARCHAR(255),\n  is_searchable BOOLEAN,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  description TEXT DEFAULT '',\n  price NUMERIC(12, 2) DEFAULT 0.00,\n  stock_quantity INTEGER DEFAULT 0,\n  category_id INTEGER DEFAULT 1,\n  manufacturer VARCHAR(100) DEFAULT 'Unknown',\n  weight_kg NUMERIC(8, 3) DEFAULT 0.000,\n  dimensions JSONB DEFAULT '{\"length\": 0, \"width\": 0, \"height\": 0}'::jsonb,\n  tags TEXT[] DEFAULT ARRAY[]::TEXT[],\n  status VARCHAR(20) DEFAULT 'active',\n  product_uuid UUID DEFAULT gen_random_uuid()\n);", "INSERT INTO product (product_id, product_name, is_searchable, created_at, updated_at, description, price, stock_quantity, category_id, manufacturer, weight_kg, dimensions, tags, status, product_uuid) VALUES \n(101, 'Laptop', true, '2023-01-15T10:00:00Z', '2023-01-15T10:00:00Z', 'High-performance laptop with SSD', 1299.99, 45, 3, 'TechCorp', 2.100, '{\"length\": 35.6, \"width\": 24.8, \"height\": 1.8}'::jsonb, ARRAY['electronics', 'computers', 'portable']::TEXT[], 'active', 'a1b2c3d4-e5f6-4321-8765-1a2b3c4d5e6f'),\n(102, 'Smartphone', true, '2023-01-20T14:30:00Z', '2023-02-05T09:15:00Z', 'Latest model with high-resolution camera', 899.99, 120, 2, 'MobileTech', 0.189, '{\"length\": 15.2, \"width\": 7.1, \"height\": 0.8}'::jsonb, ARRAY['electronics', 'mobile', 'communication']::TEXT[], 'active', 'b2c3d4e5-f6a7-5432-8765-2b3c4d5e6f7a'),\n(103, 'Tablet', false, '2023-02-01T11:45:00Z', '2023-02-01T11:45:00Z', 'Mid-range tablet for everyday use', 499.99, 78, 2, 'MobileTech', 0.450, '{\"length\": 24.5, \"width\": 17.0, \"height\": 0.6}'::jsonb, ARRAY['electronics', 'tablets', 'portable']::TEXT[], 'active', 'c3d4e5f6-a7b8-6543-8765-3c4d5e6f7a8b');"], "clean_up_sql": ["DROP TABLE product;"], "category": "Personalization", "efficiency": false, "sol_sql": ["UPDATE league\nSET name = CONCAT('abc', ',', name)\nFROM (\n    SELECT l.country_id\n    FROM league AS l\n    INNER JOIN country AS c ON l.country_id = c.id\n    GROUP BY l.country_id\n    HAVING l.country_id > 1000\n) AS t2\nWHERE league.country_id = t2.country_id"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    result = execute_queries([\n        \"SELECT COUNT(*) FROM League WHERE country_id > 1000 AND name LIKE 'abc,%';\"\n    ], db_name, conn)[0]\n    \n    updated_count = result[0][0]\n    assert updated_count > 0, f\"Update did not occur. Found {updated_count} rows with updated name.\"\n    return updated_count\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_294", "db_id": "erolp", "query": "In the database 'erolp', there is a table that tracks customer orders. Each order has a unique order ID, a customer ID, and a product ID. The task is to retrieve the order details where the product ID matches 'P101'. If no orders match 'P101', then retrieve the orders where the product ID matches 'P202'. The user attempted to use an OR condition but found that it does not meet the requirement of checking the second condition only if the first condition yields no results.", "issue_sql": ["SELECT * FROM orders WHERE customer_id = 1 OR product_id = 'P202'"], "preprocess_sql": ["CREATE TABLE orders (order_id SERIAL PRIMARY KEY, customer_id INT, product_id VARCHAR(10));", "INSERT INTO orders (customer_id, product_id) VALUES (1, 'P101'), (1, 'P303'), (2, 'P202');"], "clean_up_sql": ["DROP TABLE orders;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH RECURSIVE ranked_results AS (\n  SELECT\n    r.*,\n    ROW_NUMBER() OVER (ORDER BY r.fastestlap ASC NULLS FIRST, d.dob ASC NULLS FIRST) AS ranking\n  FROM\n    results AS r\n  JOIN\n    drivers AS d ON r.driverid = d.driverid\n)\nSELECT * FROM ranked_results\nLIMIT 10"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_295", "db_id": "erolp", "query": "In the database 'erolp', there is a sales log table named 'sales_log' which records daily sales transactions. Each transaction includes the transaction date ('transaction_date'), the transaction amount ('amount'), and the salesperson's name ('salesperson_name'). The table is populated with new entries every day. The task is to identify the salespersons ('salesperson_name') who did not record any sales on specific dates ('transaction_date'). Everything is fine with salesperson 'markus', but we need to find out the salespersons who did not record any sales on certain dates. However, the user attempted to write a query that did not produce the correct results.", "issue_sql": ["SELECT DISTINCT transaction_date, salesperson_name FROM sales_log WHERE salesperson_name NOT IN (SELECT salesperson_name FROM sales_log GROUP BY transaction_date, salesperson_name)"], "preprocess_sql": ["CREATE TABLE sales_log (\n  transaction_date DATE,\n  amount NUMERIC,\n  salesperson_name VARCHAR(50),\n  transaction_id UUID DEFAULT gen_random_uuid(),\n  transaction_time TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n  customer_id INTEGER DEFAULT floor(random() * 1000)::INTEGER,\n  product_code VARCHAR(20) DEFAULT 'PROD-' || floor(random() * 1000)::TEXT,\n  payment_method VARCHAR(30) DEFAULT (ARRAY['Credit Card', 'Cash', 'Bank Transfer', 'PayPal', 'Check'])[floor(random() * 5 + 1)],\n  store_location VARCHAR(100) DEFAULT (ARRAY['North', 'South', 'East', 'West', 'Central'])[floor(random() * 5 + 1)],\n  discount_applied NUMERIC(5,2) DEFAULT round((random() * 15)::numeric, 2),\n  tax_amount NUMERIC(8,2) DEFAULT round((random() * 50)::numeric, 2),\n  is_refunded BOOLEAN DEFAULT false,\n  notes TEXT DEFAULT 'Regular transaction',\n  metadata JSONB DEFAULT '{\"source\": \"in-store\", \"promotion_applied\": false}'::jsonb,\n  last_updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);", "INSERT INTO sales_log (transaction_date, amount, salesperson_name, transaction_id, transaction_time, customer_id, product_code, payment_method, store_location, discount_applied, tax_amount, is_refunded, notes, metadata, last_updated_at) VALUES \n('2022-07-14', 274.5, 'markus', 'a1b2c3d4-e5f6-4a1b-8c2d-3e4f5a6b7c8d', '2022-07-14 09:15:23+00', 123, 'PROD-456', 'Credit Card', 'North', 5.50, 22.45, false, 'Regular sale', '{\"source\": \"in-store\", \"promotion_applied\": false}', '2022-07-14 09:15:23'),\n('2022-07-14', 251.2, 'tess', 'b2c3d4e5-f6a7-4b2c-9d3e-4f5a6b7c8d9e', '2022-07-14 10:30:45+00', 234, 'PROD-789', 'Cash', 'South', 0.00, 20.10, false, 'Cash payment', '{\"source\": \"in-store\", \"promotion_applied\": true}', '2022-07-14 10:30:45'),\n('2022-07-14', 162.6, 'mike', 'c3d4e5f6-a7b8-4c3d-ae4f-5a6b7c8d9e0f', '2022-07-14 14:22:10+00', 345, 'PROD-123', 'PayPal', 'East', 10.25, 13.01, false, 'Online order', '{\"source\": \"online\", \"promotion_applied\": false}', '2022-07-14 14:22:10'),\n('2022-07-15', 286.9, 'markus', 'd4e5f6a7-b8c9-4d4e-bf5a-6b7c8d9e0f1a', '2022-07-15 11:05:33+00', 456, 'PROD-234', 'Credit Card', 'West', 0.00, 22.95, false, 'Premium customer', '{\"source\": \"in-store\", \"promotion_applied\": false}', '2022-07-15 11:05:33'),\n('2022-07-15', 254.8, 'tess', 'e5f6a7b8-c9d0-4e5f-ca6b-7c8d9e0f1a2b', '2022-07-15 15:45:22+00', 567, 'PROD-567', 'Bank Transfer', 'Central', 7.75, 20.38, false, 'Corporate account', '{\"source\": \"in-store\", \"promotion_applied\": true}', '2022-07-15 15:45:22'),\n('2022-07-16', 289.1, 'markus', 'f6a7b8c9-d0e1-4f6a-db7c-8d9e0f1a2b3c', '2022-07-16 09:30:15+00', 678, 'PROD-890', 'Credit Card', 'North', 0.00, 23.13, false, 'Weekend sale', '{\"source\": \"in-store\", \"promotion_applied\": false}', '2022-07-16 09:30:15'),\n('2022-07-17', 295.2, 'markus', 'a7b8c9d0-e1f2-4a7b-ec8d-9e0f1a2b3c4d', '2022-07-17 10:12:40+00', 789, 'PROD-345', 'Cash', 'South', 0.00, 23.62, false, 'Sunday sale', '{\"source\": \"in-store\", \"promotion_applied\": false}', '2022-07-17 10:12:40'),\n('2022-07-17', 260.0, 'tess', 'b8c9d0e1-f2a3-4b8c-fd9e-0f1a2b3c4d5e', '2022-07-17 13:25:55+00', 890, 'PROD-678', 'Credit Card', 'East', 5.00, 20.80, false, 'Discount applied', '{\"source\": \"in-store\", \"promotion_applied\": true}', '2022-07-17 13:25:55'),\n('2022-07-17', 182.3, 'mike', 'c9d0e1f2-a3b4-4c9d-ae0f-1a2b3c4d5e6f', '2022-07-17 16:50:30+00', 901, 'PROD-901', 'PayPal', 'West', 15.00, 14.58, false, 'Online promotion', '{\"source\": \"online\", \"promotion_applied\": true}', '2022-07-17 16:50:30')"], "clean_up_sql": ["DROP TABLE sales_log"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT * FROM transactions_1k WHERE CAST(date::text || ' ' || time AS TIMESTAMP)::date BETWEEN '2012-08-22' AND '2012-08-23' ORDER BY amount DESC NULLS LAST LIMIT 3"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_296", "db_id": "financial", "query": "In the financial database, there are two tables: `Product` and `ProductPrice` where a `product` has many `product_prices`. Each product has a history of prices recorded in the `ProductPrice` table. The task is to identify all products for which the most recent price is lower than the previous price. For example, if a product has prices 100, 150, and then 120, it should be included in the result because the last price (120) is lower than the previous price (150).", "issue_sql": ["SELECT p.product_id, p.product_name FROM Product p JOIN ProductPrice pp ON p.product_id = pp.product_id WHERE pp.price < ( SELECT MAX(price) FROM ProductPrice WHERE product_id = p.product_id ) ORDER BY p.product_id;"], "preprocess_sql": ["CREATE TABLE Product (product_id int, product_name varchar(50), created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, description TEXT DEFAULT '', category VARCHAR(100) DEFAULT 'Uncategorized', is_active BOOLEAN DEFAULT TRUE, stock_quantity INTEGER DEFAULT 0, manufacturer VARCHAR(200) DEFAULT 'Unknown', sku VARCHAR(50) DEFAULT '', weight NUMERIC(8, 2) DEFAULT 0.0, dimensions JSONB DEFAULT '{\"length\": 0, \"width\": 0, \"height\": 0}'::jsonb, tags TEXT[] DEFAULT ARRAY[]::TEXT[], release_date DATE DEFAULT CURRENT_DATE, version VARCHAR(20) DEFAULT '1.0.0', metadata JSONB DEFAULT '{}'::jsonb);", "CREATE TABLE ProductPrice (id serial, product_id int, price int, effective_from TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, effective_to TIMESTAMP WITH TIME ZONE DEFAULT NULL, created_by VARCHAR(100) DEFAULT 'system', currency VARCHAR(3) DEFAULT 'USD', discount_percentage NUMERIC(5, 2) DEFAULT 0.00, is_promotional BOOLEAN DEFAULT FALSE, price_tier VARCHAR(50) DEFAULT 'standard', notes TEXT DEFAULT '', approval_status VARCHAR(20) DEFAULT 'approved', region VARCHAR(50) DEFAULT 'global', tax_rate NUMERIC(5, 2) DEFAULT 0.00, price_history JSONB DEFAULT '{}'::jsonb, external_reference_id UUID DEFAULT gen_random_uuid());", "INSERT INTO Product (product_id, product_name, description, category, is_active, stock_quantity, manufacturer, sku, weight, dimensions, tags, release_date, version, metadata) VALUES (1, 'poetry book', 'A collection of modern poetry', 'Books', TRUE, 120, 'Literary Press', 'BK-POE-001', 0.45, '{\"length\": 21, \"width\": 14, \"height\": 2}'::jsonb, ARRAY['poetry', 'literature', 'paperback']::TEXT[], '2022-03-15', '1.0.0', '{\"bestseller\": true, \"pages\": 186}'::jsonb), (2, 'programming book', 'Comprehensive guide to modern programming', 'Technical', TRUE, 85, 'Tech Publications', 'BK-PRG-002', 1.20, '{\"length\": 28, \"width\": 21, \"height\": 3.5}'::jsonb, ARRAY['programming', 'computer science', 'reference']::TEXT[], '2022-01-10', '2.1.0', '{\"bestseller\": false, \"pages\": 542}'::jsonb);", "INSERT INTO ProductPrice (product_id, price, effective_from, effective_to, created_by, currency, discount_percentage, is_promotional, price_tier, notes, approval_status, region, tax_rate, price_history, external_reference_id) VALUES (1, 4, '2022-01-01 00:00:00+00', '2022-02-01 00:00:00+00', 'admin', 'USD', 0.00, FALSE, 'standard', 'Initial price point', 'approved', 'global', 7.50, '{\"previous\": null}'::jsonb, gen_random_uuid()), (2, 20, '2022-01-01 00:00:00+00', '2022-03-01 00:00:00+00', 'admin', 'USD', 0.00, FALSE, 'premium', 'Technical book pricing', 'approved', 'global', 7.50, '{\"previous\": null}'::jsonb, gen_random_uuid()), (1, 8, '2022-02-01 00:00:00+00', '2022-03-15 00:00:00+00', 'pricing_manager', 'USD', 0.00, FALSE, 'standard', 'Price increase due to demand', 'approved', 'global', 7.50, '{\"previous\": 4}'::jsonb, gen_random_uuid()), (1, 6, '2022-03-15 00:00:00+00', NULL, 'pricing_manager', 'USD', 25.00, TRUE, 'discounted', 'Spring promotion', 'approved', 'global', 7.50, '{\"previous\": 8}'::jsonb, gen_random_uuid()), (2, 22, '2022-03-01 00:00:00+00', NULL, 'pricing_manager', 'USD', 0.00, FALSE, 'premium', 'Minor price adjustment', 'approved', 'global', 7.50, '{\"previous\": 20}'::jsonb, gen_random_uuid());"], "clean_up_sql": ["DROP TABLE Product;", "DROP TABLE ProductPrice;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT state,\n       (array_agg(county ORDER BY cdscode DESC NULLS LAST))[1] AS county,\n       (array_agg(city ORDER BY cdscode DESC NULLS LAST))[1] AS city,\n       (array_agg(cdscode ORDER BY cdscode DESC NULLS LAST))[1] AS cdscode\nFROM schools\nWHERE state IS NOT NULL\nGROUP BY state"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_297", "db_id": "erolp", "query": "In the erolp database, we have a parent table named customer_details which contains customer IDs. There are three child tables: sales, communications, and feedback. Each table has 100 rows and customer_id as a foreign key referencing customer_details. The sales table includes customer_id, amount, and transaction_date. The communications table includes customer_id, email_count, and communication_date. The feedback table includes customer_id, feedback_type, and feedback_date. The feedback_type column has only two possible values: 'positive' and 'negative'. We need to generate a single query that provides the count of customer IDs and the sum of amounts from the sales table, the count of customer IDs from the communications table, and the count of customer IDs along with the count of positive and negative feedback types from the feedback table.", "issue_sql": ["SELECT CD.customer_id, COUNT(S.customer_id) AS total_sales, SUM(S.amount) AS total_amount, COUNT(C.customer_id) AS total_communications, COUNT(F.customer_id) AS total_feedback, COUNT(F.customer_id) FILTER (WHERE F.feedback_type='positive') AS total_positive_feedback, COUNT(F.customer_id) FILTER (WHERE F.feedback_type='negative') AS total_negative_feedback FROM customer_details CD JOIN sales S ON CD.customer_id = S.customer_id JOIN communications C ON CD.customer_id = C.customer_id JOIN feedback F ON CD.customer_id = F.customer_id GROUP BY CD.customer_id"], "preprocess_sql": ["CREATE TABLE customer_details (customer_id INT PRIMARY KEY);", "CREATE TABLE sales (customer_id INT, amount DECIMAL, transaction_date DATE, FOREIGN KEY (customer_id) REFERENCES customer_details(customer_id));", "CREATE TABLE communications (customer_id INT, email_count INT, communication_date DATE, FOREIGN KEY (customer_id) REFERENCES customer_details(customer_id));", "CREATE TABLE feedback (customer_id INT, feedback_type VARCHAR(10), feedback_date DATE, FOREIGN KEY (customer_id) REFERENCES customer_details(customer_id));", "INSERT INTO customer_details (customer_id) VALUES (1), (2), (3);", "INSERT INTO sales (customer_id, amount, transaction_date) VALUES (1, 2, '2022-01-22'), (2, 5, '2022-01-23'), (1, 10, '2022-01-25'), (3, 1, '2022-01-25');", "INSERT INTO communications (customer_id, email_count, communication_date) VALUES (1, 5, '2022-01-22'), (2, 10, '2022-01-22'), (1, 7, '2022-01-23'), (1, 7, '2022-01-24'), (2, 10, '2022-01-25');", "INSERT INTO feedback (customer_id, feedback_type, feedback_date) VALUES (1, 'positive', '2022-01-22'), (2, 'negative', '2022-01-22'), (1, 'negative', '2022-01-23'), (2, 'positive', '2022-01-26'), (2, 'positive', '2022-01-27');"], "clean_up_sql": ["DROP TABLE IF EXISTS customer_details;", "DROP TABLE IF EXISTS sales;", "DROP TABLE IF EXISTS communications;", "DROP TABLE IF EXISTS feedback;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT account.account_id, loan.loan_id, SUM(loan.amount) AS total_amount\nFROM account\nJOIN loan ON account.account_id = loan.account_id\nJOIN trans ON loan.account_id = trans.account_id\nWHERE loan.status LIKE '%A%'\nAND (trans.type LIKE '%PRIJEM%' OR trans.type LIKE '%VYDAJ%')\nGROUP BY loan.loan_id, account.account_id\nORDER BY account.account_id NULLS FIRST"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_298", "db_id": "erolp", "query": "In the context of our e-commerce platform, I need to create a function that concatenates the first name and last name of customers from the 'cust' table to generate a full name for each customer. The 'cust' table contains customer details including their first name, last name, and email address. I have created a function to achieve this, but when I attempt to use it, I encounter an error. The output format should be | customer_id | f_name | l_name | email_address | full_name |\n", "issue_sql": ["CREATE OR REPLACE FUNCTION fn_concat(f_name character varying, l_name character varying) RETURNS character varying AS $$ BEGIN IF cust.f_name IS NULL AND cust.l_name IS NULL THEN RETURN NULL; ELSEIF cust.f_name IS NULL AND cust.l_name IS NOT NULL THEN RETURN cust.l_name; ELSEIF cust.f_name IS NOT NULL AND cust.l_name IS NULL THEN RETURN cust.f_name; ELSE RETURN CONCAT(cust.f_name, ' ', cust.l_name); END IF; END; $$ LANGUAGE plpgsql;", "SELECT * FROM fn_concat(f_name, l_name);"], "preprocess_sql": ["CREATE TABLE cust (customer_id SERIAL PRIMARY KEY, f_name VARCHAR(50), l_name VARCHAR(50), email VARCHAR(100));", "INSERT INTO cust (f_name, l_name, email) VALUES ('Alice', 'Johnson', 'alice.johnson@example.com'), ('Bob', 'Smith', 'bob.smith@example.com'), ('Charlie', 'Brown', 'charlie.brown@example.com');"], "clean_up_sql": ["DROP TABLE cust;"], "category": "Query", "efficiency": false, "sol_sql": ["SELECT customerid,\n       SUM(CASE WHEN EXTRACT(DAY FROM date) = 3 THEN 1 ELSE 0 END) AS number_of_third_day,\n       SUM(CASE WHEN EXTRACT(DAY FROM date) = 24 THEN 1 ELSE 0 END) AS number_of_twenty_fourth_day\nFROM transactions_1k\nWHERE EXTRACT(DAY FROM date) IN (3, 24)\nGROUP BY customerid"], "test_cases": ["          \ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    pred_sqls = remove_distinct(pred_sqls)\n    sol_sqls = remove_distinct(sol_sqls)\n    result = ex_base(pred_sqls, sol_sqls, db_name, conn)\n    assert result == 1, f\"ex_base returned {result} but expected 1.\"\n    return result\n    "]}
{"dialect": "PostgreSQL", "version": "14.12", "instance_id": "PostgreSQL_299", "db_id": "erolp", "query": "In the e-commerce database 'erolp', there is a table named 'orders' that contains a column 'delivery_zones' with type 'text'. This column can store either a single zip code, multiple comma-separated zip codes, or a range of zip codes separated by a hyphen. For example, the data might look like '10001', '10002,10010,10015', or '10001,10010-10025'. We need to find all orders that are destined for the zip code '10015'. The user attempted to use the following SQL query, which works for comma-separated zip codes but fails to handle ranges correctly.", "issue_sql": ["SELECT * FROM orders WHERE '10015' = ANY(string_to_array(orders.delivery_zones, ','))"], "preprocess_sql": ["CREATE TABLE orders (id SERIAL, delivery_zones text)", "INSERT INTO orders (delivery_zones) VALUES ('10001'), ('10001,10002,10015'), ('10003,10004-10024'), ('10007,10009,10018-10030')"], "clean_up_sql": ["DROP TABLE orders;"], "category": "Query", "efficiency": false, "sol_sql": ["WITH rates(n) AS (VALUES (0), (1), (2), (3), (4), (5))\nSELECT r.n AS RATES,\n       SUM(CASE WHEN d.a8 = r.n THEN 1 ELSE 0 END) AS A8,\n       SUM(CASE WHEN d.a9 = r.n THEN 1 ELSE 0 END) AS A9\nFROM rates AS r\nLEFT JOIN district AS d ON d.a8 = r.n OR d.a9 = r.n\nGROUP BY r.n\nORDER BY r.n DESC NULLS LAST"], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n       pred_sqls = remove_distinct(pred_sqls)\n       sol_sqls = remove_distinct(sol_sqls)\n       pred_sqls_result = execute_queries(pred_sqls, db_name, conn)\n       sol_sqls_result = execute_queries(sol_sqls, db_name, conn)\n       assert pred_sqls_result == sol_sqls_result, f\"Expected pred_result and sol_result are the same but pred_result is {pred_sqls_result} and sol_result is {sol_sqls_result}\"\n"]}
